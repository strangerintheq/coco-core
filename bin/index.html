<!DOCTYPE html><html><head>    <meta charset="UTF-8">    <title>Coco Web Core</title>    <style>
body {
  margin: 0;
  overflow: hidden;
  width: 100%;
  height: 100%;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  font-family: Arial, sans-serif;
}
#container {
  position: absolute;
  width: 100%;
  height: 100%;
}
#canvas {
  width: 100%;
  height: 100%;
  background-color: #000;
}
.hidden {
  display: none;
}
#buttons {
  position: absolute;
  margin: 10px;
}
div.button {
  pointer-events: all;
  margin: 2px;
  width: 30px;
  height: 30px;
  border: 2px solid #f5deb3;
  border-radius: 30px;
  position: absolute;
  cursor: pointer;
  text-align: center;
  line-height: 30px;
  color: #f5deb3;
  transition: 300ms;
}
div.button:hover {
  width: 34px;
  height: 34px;
  line-height: 34px;
  margin: 0;
}
#compass {
  position: absolute;
  width: 200px;
  height: 200px;
  bottom: 0;
  margin-left: -75px;
  left: 50%;
  pointer-events: all;
}
#switch-globe {
  left: 0;
}
#settings {
  left: 50px;
}
div.form {
  background-color: rgba(0,0,0,0.5);
  border-radius: 5px;
  position: absolute;
  box-shadow: 0 0 10px 0 #d3d3d3;
  overflow: hidden;
  opacity: 0;
  pointer-events: none;
}
div.form.form-transition {
  transition: 200ms;
}
div.form.visible {
  opacity: 1;
  pointer-events: all;
}
.form-title {
  width: 100%;
  position: absolute;
  text-align: center;
  font-size: 20px;
  color: #f0e68c;
  cursor: move;
  height: 35px;
  line-height: 35px;
}
.form-buttons {
  position: absolute;
  bottom: 7px;
  right: 7px;
  text-align: right;
}
div.form-button {
  width: 119px;
  color: #d3d3d3;
  display: inline-block;
  margin: 5px;
  height: 25px;
  line-height: 25px;
  text-align: center;
  cursor: pointer;
  transition: 100ms;
  border-radius: 3px;
  background-color: rgba(0,0,0,0.3);
  box-shadow: 0 0 5px 0 #d3d3d3;
}
div.form-button:hover {
  box-shadow: 0 0 10px 0 #fff;
  transition: 200ms;
  background-color: rgba(0,0,0,0.1);
}
div.form-button.selected {
  color: #f5deb3;
  transition: 300ms;
}
.form-content {
  position: absolute;
  top: 40px;
}
.form-field {
  line-height: 25px;
  height: 25px;
}
.form-field-title {
  color: #fff;
  margin-left: 10px;
  display: inline-block;
  cursor: default;
}
.form-field-value {
  color: #f5deb3;
  display: inline-block;
  margin-left: 10px;
  cursor: default;
}
div.form-top-button {
  position: absolute;
  top: 5px;
  right: 5px;
  box-shadow: 0 0 5px 0 #d3d3d3;
  width: 21px;
  height: 21px;
  cursor: pointer;
  margin: 2px;
  border-radius: 5px;
  transition: 300ms;
}
div.form-top-button:hover {
  transition: 300ms;
  box-shadow: 0 0 10px 0 #fff;
}
div.form-minimized {
  height: 35px !important;
  width: 150px !important;
  border-radius: 0;
  transition: 300ms;
  bottom: 10px !important;
  top: auto !important;
  margin-top: 0 !important;
  box-shadow: 0 0 5px 0 #808080;
}
div.form-minimized div.form-title {
  cursor: pointer !important;
}
div.form-minimized:hover {
  box-shadow: 0 0 10px 0 #d3d3d3;
  transition: 300ms;
}
#form-settings {
  width: 300px;
  height: 200px;
  left: 100px;
  bottom: 200px;
}
#form-settings1 {
  width: 300px;
  height: 200px;
  left: 500px;
  bottom: 200px;
}</style></head><body>    <div id="container">    <canvas id="canvas"></canvas></div><div id="buttons">    <div id="switch-globe" class="button">        <svg viewBox="-55 -55 700 700">    <path        fill='white'        d="M505.123,87.08c-27.133-27.133-58.742-48.441-93.947-63.332C374.705,8.321,335.988,0.5,296.101,0.5    c-39.887,0-78.604,7.821-115.074,23.248C145.822,38.638,114.214,59.946,87.08,87.08c-27.134,27.134-48.442,58.742-63.333,93.948    C8.321,217.498,0.5,256.214,0.5,296.102c0,39.887,7.821,78.604,23.248,115.074c14.89,35.205,36.198,66.813,63.332,93.947    s58.742,48.442,93.947,63.333c36.471,15.426,75.188,23.247,115.074,23.247c39.887,0,78.604-7.821,115.075-23.247    c35.205-14.891,66.812-36.199,93.947-63.333c27.135-27.133,48.441-58.742,63.332-93.947    c15.426-36.471,23.248-75.188,23.248-115.074c0-39.887-7.822-78.604-23.248-115.074    C553.564,145.822,532.258,114.213,505.123,87.08z M456.451,274.682c-1.363-37.479-6.293-73.628-14.439-106.704    c19.564-7.662,37.543-16.875,53.395-27.343c29.373,37.601,48.334,83.727,52.557,134.046H456.451z M317.521,47.506    c28.795,11.331,53.932,45.084,71.322,92.512c-22.607,5.676-46.719,9.249-71.322,10.566V47.506z M274.681,47.506v103.079    c-24.78-1.33-48.83-4.949-71.311-10.601C220.761,92.575,245.893,58.834,274.681,47.506z M191.077,181.121    c26.651,6.871,54.639,11.012,83.604,12.375v81.186h-96.062C179.929,241.216,184.279,209.604,191.077,181.121z M274.681,317.521    v81.187c-28.964,1.362-56.954,5.503-83.604,12.374c-6.798-28.482-11.147-60.095-12.458-93.561H274.681L274.681,317.521z     M274.681,441.617v103.079c-28.788-11.327-53.92-45.068-71.311-92.479C225.851,446.566,249.901,442.947,274.681,441.617z     M317.521,544.697V441.619c24.604,1.316,48.715,4.89,71.322,10.566C371.453,499.612,346.316,533.366,317.521,544.697z     M401.121,411.103c-26.51-6.791-54.812-10.982-83.6-12.378v-81.203h96.061C412.273,350.995,407.922,382.615,401.121,411.103z     M317.521,274.682v-81.203c28.787-1.396,57.09-5.587,83.6-12.378c6.801,28.487,11.152,60.107,12.463,93.581H317.521z     M465.764,108.745c-10.943,6.701-23.07,12.762-36.146,18.061c-3.467-9.588-7.242-18.793-11.322-27.543    c-5.775-12.378-12.068-23.693-18.846-33.894C423.852,76.316,446.201,91.019,465.764,108.745z M192.754,65.368    c-6.777,10.201-13.073,21.516-18.846,33.894c-4.08,8.746-7.852,17.947-11.319,27.531c-13.009-5.256-25.136-11.294-36.157-18.044    C145.996,91.021,168.349,76.317,192.754,65.368z M96.795,140.636c15.85,10.46,33.85,19.677,53.398,27.336    c-8.148,33.077-13.079,69.228-14.441,106.709H44.24C48.462,224.362,67.423,178.237,96.795,140.636z M135.752,317.521    c1.362,37.482,6.294,73.633,14.441,106.71c-19.548,7.658-37.548,16.875-53.398,27.335    c-29.372-37.601-48.333-83.726-52.556-134.045H135.752z M126.432,483.454c11.021-6.751,23.147-12.789,36.157-18.045    c3.467,9.584,7.239,18.785,11.319,27.531c5.774,12.378,12.069,23.692,18.846,33.894    C168.349,515.886,145.996,501.182,126.432,483.454z M399.447,526.835c6.777-10.201,13.072-21.516,18.848-33.894    c4.08-8.75,7.854-17.955,11.322-27.544c13.076,5.3,25.201,11.361,36.146,18.062C446.201,501.185,423.852,515.888,399.447,526.835z     M495.406,451.567c-15.852-10.468-33.83-19.682-53.395-27.343c8.146-33.074,13.076-69.224,14.439-106.703h91.512    C543.74,367.841,524.779,413.967,495.406,451.567z" />	<path	    fill='white'	    d="M296.101,592.203c-39.954,0-78.736-7.835-115.269-23.286c-35.264-14.916-66.926-36.261-94.106-63.44    c-27.18-27.18-48.524-58.842-63.439-94.106C7.835,374.84,0,336.058,0,296.102c0-39.955,7.835-78.737,23.287-115.269    c14.916-35.265,36.26-66.927,63.439-94.106c27.181-27.18,58.842-48.523,94.106-63.439C217.364,7.835,256.146,0,296.101,0    c39.956,0,78.738,7.835,115.269,23.287c35.267,14.917,66.929,36.26,94.106,63.439c27.179,27.177,48.522,58.839,63.439,94.106    c15.452,36.533,23.287,75.315,23.287,115.269c0,39.953-7.835,78.735-23.287,115.269c-14.918,35.27-36.262,66.931-63.439,94.106    c-27.182,27.181-58.844,48.525-94.106,63.44C374.839,584.368,336.057,592.203,296.101,592.203z M296.101,1    c-39.82,0-78.472,7.808-114.879,23.208c-35.145,14.865-66.699,36.137-93.789,63.225c-27.088,27.088-48.36,58.644-63.226,93.789    C8.808,217.63,1,256.281,1,296.102c0,39.821,7.808,78.473,23.208,114.88c14.865,35.145,36.137,66.7,63.225,93.788    c27.088,27.089,58.644,48.36,93.789,63.226c36.409,15.399,75.06,23.208,114.879,23.208c39.821,0,78.472-7.809,114.88-23.208    c35.143-14.864,66.698-36.137,93.788-63.226c27.086-27.084,48.358-58.639,63.225-93.788c15.4-36.41,23.209-75.062,23.209-114.88    c0-39.819-7.809-78.47-23.209-114.879c-14.866-35.148-36.138-66.703-63.225-93.789c-27.087-27.087-58.642-48.359-93.788-63.225    C374.573,8.808,335.922,1,296.101,1z M317.021,545.432v-104.34l0.526,0.028c24.69,1.32,48.719,4.881,71.418,10.58l0.539,0.136    l-0.191,0.521c-17.858,48.702-43.29,81.661-71.609,92.805L317.021,545.432z M318.021,442.147v101.812    c27.676-11.257,52.558-43.673,70.161-91.424C365.866,446.971,342.267,443.477,318.021,442.147z M275.181,545.431l-0.683-0.27    c-28.312-11.14-53.739-44.086-71.597-92.771l-0.191-0.521l0.539-0.136c22.762-5.722,46.786-9.293,71.406-10.614l0.527-0.028    V545.431z M204.032,452.567c17.603,47.734,42.481,80.138,70.149,91.391V442.146C250.004,443.475,226.409,446.98,204.032,452.567z     M398.073,527.999l0.958-1.44c6.747-10.156,13.076-21.538,18.811-33.828c4.014-8.607,7.817-17.86,11.306-27.503l0.176-0.488    l0.481,0.195c13.067,5.296,25.254,11.385,36.22,18.098l0.569,0.349l-0.494,0.448c-19.804,17.944-42.16,32.567-66.447,43.462    L398.073,527.999z M429.91,466.057c-3.449,9.494-7.204,18.607-11.162,27.096c-5.485,11.757-11.514,22.687-17.933,32.515    c23.383-10.682,44.942-24.848,64.116-42.13C454.295,477.072,442.519,471.194,429.91,466.057z M194.128,527.998l-1.579-0.708    c-24.292-10.897-46.65-25.521-66.454-43.466l-0.495-0.448l0.569-0.349c10.959-6.713,23.149-12.797,36.231-18.082l0.481-0.194    l0.177,0.488c3.486,9.637,7.288,18.886,11.302,27.49c5.734,12.291,12.062,23.672,18.81,33.828L194.128,527.998z M127.264,483.532    c19.173,17.282,40.736,31.45,64.122,42.134c-6.418-9.827-12.447-20.758-17.931-32.515c-3.958-8.485-7.711-17.595-11.159-27.084    C149.674,471.194,137.893,477.067,127.264,483.532z M495.516,452.239l-0.385-0.255c-15.855-10.471-33.789-19.653-53.302-27.294    l-0.407-0.16l0.104-0.425c8.212-33.339,13.064-69.205,14.425-106.603l0.018-0.481h92.538l-0.046,0.542    c-4.114,49.034-22.324,95.479-52.661,134.312L495.516,452.239z M442.602,423.919c19.262,7.572,36.986,16.646,52.694,26.977    c29.935-38.462,47.948-84.388,52.123-132.874h-90.485C455.553,355.153,450.73,390.778,442.602,423.919z M96.686,452.238    l-0.284-0.364c-30.335-38.834-48.545-85.278-52.66-134.311l-0.046-0.542h92.538l0.018,0.481    c1.359,37.393,6.213,73.261,14.427,106.608l0.105,0.426l-0.408,0.16c-19.526,7.649-37.461,16.83-53.305,27.286L96.686,452.238z     M44.784,318.021c4.174,48.485,22.188,94.41,52.122,132.873c15.697-10.316,33.422-19.388,52.698-26.969    c-8.133-33.151-12.954-68.774-14.333-105.904H44.784z M401.489,411.713l-0.492-0.126c-26.565-6.806-54.659-10.965-83.5-12.363    l-0.476-0.022v-82.18h97.08l-0.02,0.52c-1.285,32.871-5.482,64.389-12.475,93.678L401.489,411.713z M318.021,398.249    c28.563,1.415,56.393,5.533,82.731,12.243c6.869-28.932,11.01-60.038,12.309-92.471h-95.04V398.249z M190.708,411.693    l-0.118-0.495c-6.988-29.28-11.184-60.791-12.471-93.657l-0.021-0.52h97.083v82.163l-0.477,0.022    c-28.867,1.358-56.961,5.517-83.503,12.359L190.708,411.693z M179.139,318.021c1.301,32.429,5.44,63.527,12.307,92.449    c26.316-6.747,54.146-10.864,82.736-12.239v-80.21H179.139z M548.507,275.182h-92.538l-0.018-0.482    c-1.36-37.396-6.213-73.262-14.425-106.602l-0.104-0.425l0.407-0.16c19.517-7.643,37.449-16.826,53.302-27.294l0.385-0.255    l0.284,0.364c30.337,38.834,48.547,85.278,52.661,134.312L548.507,275.182z M456.934,274.182h90.485    c-4.175-48.486-22.188-94.412-52.123-132.875c-15.705,10.329-33.429,19.403-52.694,26.977    C450.731,201.427,455.553,237.048,456.934,274.182z M414.104,275.182h-97.082v-82.18l0.476-0.023    c28.841-1.398,56.935-5.558,83.5-12.363l0.492-0.126l0.118,0.494c6.991,29.287,11.189,60.804,12.477,93.678L414.104,275.182z     M318.021,274.182h95.042c-1.301-32.436-5.441-63.542-12.311-92.471c-26.339,6.71-54.168,10.829-82.731,12.244V274.182z     M275.181,275.182h-97.083l0.021-0.52c1.287-32.866,5.483-64.376,12.471-93.658l0.118-0.495l0.493,0.127    c26.542,6.843,54.637,11.001,83.503,12.359l0.477,0.022V275.182z M179.139,274.182h95.042v-80.209    c-28.589-1.376-56.418-5.494-82.736-12.241C184.579,210.655,180.44,241.753,179.139,274.182z M136.234,275.182H43.696l0.046-0.542    c4.114-49.032,22.324-95.476,52.659-134.311l0.284-0.364l0.385,0.254c15.844,10.457,33.778,19.638,53.305,27.288l0.408,0.16    l-0.105,0.425c-8.213,33.344-13.067,69.212-14.427,106.608L136.234,275.182z M44.784,274.182h90.486    c1.38-37.134,6.201-72.756,14.333-105.904c-19.276-7.582-37.001-16.653-52.698-26.97    C66.971,179.771,48.958,225.697,44.784,274.182z M275.181,151.112l-0.527-0.028c-24.617-1.321-48.641-4.893-71.406-10.615    l-0.539-0.135l0.191-0.522c17.858-48.684,43.285-81.631,71.597-92.771l0.683-0.269V151.112z M204.032,139.635    c22.379,5.587,45.975,9.093,70.149,10.422V48.245C246.513,59.498,221.635,91.901,204.032,139.635z M317.021,151.111V46.772    l0.683,0.269c28.319,11.144,53.751,44.102,71.609,92.805l0.191,0.522l-0.539,0.135c-22.7,5.699-46.729,9.259-71.418,10.581    L317.021,151.111z M318.021,48.245v101.812c24.245-1.33,47.844-4.824,70.161-10.389C370.579,91.916,345.697,59.5,318.021,48.245z     M429.323,127.464l-0.177-0.488c-3.479-9.624-7.283-18.876-11.305-27.501c-5.737-12.298-12.066-23.679-18.809-33.828l-0.958-1.441    l1.579,0.708c24.287,10.896,46.643,25.518,66.445,43.461l0.494,0.448l-0.569,0.349c-10.958,6.71-23.145,12.799-36.22,18.098    L429.323,127.464z M400.817,66.538c6.415,9.821,12.442,20.751,17.931,32.514c3.966,8.506,7.721,17.62,11.162,27.096    c12.616-5.14,24.393-11.018,35.021-17.48C445.76,91.385,424.2,77.22,400.817,66.538z M162.883,127.451l-0.481-0.194    c-13.081-5.286-25.271-11.369-36.231-18.082l-0.569-0.349l0.495-0.448C145.9,90.434,168.258,75.81,192.55,64.912l1.579-0.708    l-0.958,1.441c-6.75,10.161-13.079,21.542-18.81,33.829c-4.014,8.604-7.816,17.854-11.302,27.49L162.883,127.451z     M127.264,108.671c10.63,6.464,22.411,12.337,35.032,17.464c3.447-9.489,7.201-18.599,11.159-27.084    c5.481-11.752,11.509-22.682,17.931-32.514C168,77.221,146.438,91.388,127.264,108.671z" /></svg>    </div>    <div id="settings" class="button">        <svg viewBox="-0.2 1 24 24">  <path    fill='white'    d="M20,14.5v-2.9l-1.8-0.3c-0.1-0.4-0.3-0.8-0.6-1.4l1.1-1.5l-2.1-2.1l-1.5,1.1c-0.5-0.3-1-0.5-1.4-0.6L13.5,5h-2.9l-0.3,1.8  C9.8,6.9,9.4,7.1,8.9,7.4L7.4,6.3L5.3,8.4l1,1.5c-0.3,0.5-0.4,0.9-0.6,1.4L4,11.5v2.9l1.8,0.3c0.1,0.5,0.3,0.9,0.6,1.4l-1,1.5  l2.1,2.1l1.5-1c0.4,0.2,0.9,0.4,1.4,0.6l0.3,1.8h3l0.3-1.8c0.5-0.1,0.9-0.3,1.4-0.6l1.5,1.1l2.1-2.1l-1.1-1.5c0.3-0.5,0.5-1,0.6-1.4  L20,14.5z M12,16c-1.7,0-3-1.3-3-3s1.3-3,3-3s3,1.3,3,3S13.7,16,12,16z"/></svg>    </div></div><div id="compass">    <svg id='controls-svg' viewBox="-111 -100 222 200">    <style>        .controls-round {    fill: rgba(0, 0, 0, 0.2);    r: 80;    opacity: 1;    transition: 300ms;}.one {    stroke-width: 5;    stroke:  rgba(0, 0, 0, 1);}.two {    stroke-width: 4;    stroke: lightgray;}.controls-knob-active-area {    fill: transparent;    r: 15;    cursor: pointer;    pointer-events: all;}path.arrow {    fill: transparent;    stroke-linecap: round;    cursor: pointer;    transition: 400ms;    pointer-events: all;}path.arrow:hover {    stroke: darkgray;}.controls-knob-circle {    fill: lightgray;    r: 8;    transition: 300ms;    /*opacity: 0.2;*/    opacity: 1;}.controls-knob-text {    stroke: gray;    pointer-events: none;    fill: none;    stroke-width: 2;    transition: 300ms;    /*opacity: 0.2;*/    opacity: 1;}.track {    fill: none;    stroke-linecap: round;    transition: 300ms;    /*opacity: 0;*/    opacity: 1;}g#controls-globe{    pointer-events: all;    cursor: pointer;}/*svg:hover path.track {*/    /*stroke: lightgray;*/    /*opacity: 1;*//*}*//*svg:hover circle.controls-knob-circle {*/    /*fill: lightgray;*/    /*opacity: 1;*//*}*//*svg:hover path.controls-knob-text {*/    /*stroke: gray;*/    /*opacity: 1;*//*}*//*svg:hover circle#controls-round {*/    /*opacity: 1;*//*}*/    </style>    <circle class="controls-round one"/>    <circle class="controls-round two"/>    <g id="controls-heading" transform="rotate(0)">        <g id="controls-globe" transform="translate(-42.5 -39) scale(0.15)"><style>.continents {	fill: white;	stroke: black;	stroke-width: 1;	stroke-linecap: round;	stroke-linejoin: round; }</style>   <circle r="133.416626" cy="261" cx="283" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="null" stroke-width="0.6875" stroke="#000000" fill="#000000"/>  <g fill-rule="evenodd" transform="matrix(1.419847,0,0,1.419847,15.32198,-182.2152) ">   <polyline class="continents" points="191.606 365.541 191.267 366.511 191.144 370.781 190.259 372.746 187.038 373.902 185.647 376.619 185.712 380.586 188.232 382.501 192.032 384.794 196.194 388.875 198.91 392.056 201.068 392.181 201.275 394.522 200.224 396.878 200.617 398.496 200.845 398.676 210.18 396.833 219.178 394.131 227.846 390.499 238.068 384.863 247.126 378.234 247.285 375.548 248.828 371.555 251.658 367.562 253.247 365.197 250.9 363.43 249.644 363.256 246.623 364.576 240.708 365.919 235.872 366.564 231.891 361.948 225.602 362.068 220.95 361.264 215.542 358.999 211.252 359.984 205.355 360.082 203.034 361.19 198.711 359.676 195.851 360.981 193.386 362.99 192.004 364.417 189.792 363.953 186.379 363.654 183.487 361.546 182.946 360.104 183.797 357.584 183.961 355.437 181.973 354.006 178.929 353.176 175.524 353.227 175.131 351.609 176.193 349.602 176.697 346.18 174.688 344.966 172.023 345.897 170.965 347.716 169.014 348.291 166.479 347.435 163.032 344.638 162.655 341.047 163.129 337.797 165.972 333.965 169.722 333.177 172.064 333.493 173.671 334.38 175.283 334.166 177.081 333.227 180.118 333.521 182.995 334.742 185.018 337.757 186.646 340.068 188.436 339.507 187.874 336.639 186.755 334.302 187.265 331.417 188.665 329.05 192.196 326.486 194.327 324.65 194.482 321.239 195.879 317.42 197.631 314.853 198.881 314.488 199.591 312.681 201.33 309.952 202.936 309.2 204.56 310.06 205.798 308.62 208.474 307.125 210.419 306.011 209.68 304.217 206.993 304.637 205.74 304.276 205.553 302.329 203.751 301.815 201.976 303.264 200.018 304.216 199.815 303.327 201.761 301.299 204.959 299.633 206.947 299.424 209.633 298.277 210.49 296.294 209.562 293.771 206.845 290.591 201.952 286.893 199.074 286.585 197.456 286.262 195.824 284.14 190.976 282.07 189.185 282.631 189.208 285.696 189.434 289.649 190.715 291.058 189.661 292.688 189.184 296.127 188.67 299.2 186.672 297.421 185.232 295.112 185.014 292.422 182.671 291.38 179.063 290.541 177.775 288.595 178.09 284.445 180.215 281.157 183.584 277.88 186.606 275.647 187.995 273.844 186.373 272.07 184.23 272.832 181.897 272.139 181.501 269.795 181.289 267.642 179.681 267.669 179.194 270.759 177.755 272.035 176.524 271.154 176.455 267.374 175.537 264.896 173.542 263.842 171.917 261.342 169.233 261.575 167.629 263.053 169.617 264.788 170.016 266.944 172.362 268.711 172.034 271.061 164.781 265.433 160.996 262.082 158.987 259.228 158.971 256.701 158.198 253.322 156.56 252.606 153.531 252.662 152.273 253.403 150.655 253.081 148.873 253.265 148.19 255.09 147.475 256.359 144.051 255.712 141.928 257.172 140.712 259.73 140.013 261.886 138.046 261.575 136.044 259.985 136.788 262.316 139.866 263.701 143.278 264.913 146.164 266.484 147.275 269.503 147.495 272.919 146.312 277.977 144.75 283.217 144.436 287.368 144.484 289.723 145.053 292.213 142.925 294.775 140.987 298.066 139.078 302.404 138.24 307.638 137.613 315.026 138.366 317.707 139.864 322.721 140.974 326.653 142.65 331.319 144.814 333.622 146.629 334.297 144.809 332.171 143.868 329.487 143.31 326.432 142.744 323.753 144.155 323.375 144.902 325.518 146.209 330.717 148.972 336.252 149.735 339.283 149.021 341.278 150.69 343.768 153.925 345.327 158.82 349.752 161.858 350.958 166.556 352.478 171.937 354.727 174.659 356.5 177.188 358.763 179.216 363.23 183.174 364.783 185.709 365.639 188.568 365.248 191.606 365.541"/>   <polyline class="continents" points="181.506 345.213 183.652 344.264 187.072 345.099 191.02 346.303 194.058 346.596 196.775 347.831 196.072 349.262 192.848 349.692 190.158 347.747 186.896 346.172 181.506 345.213"/>   <polyline class="continents" points="197.674 348.698 197.535 350.136 199.866 351.017 202.02 351.33 205.767 350.731 203.242 349.309 203.414 348.425 201.96 347.901 197.674 348.698"/>   <polyline class="continents" points="211.029 296.098 212.297 297.346 214.657 299.274 217.173 301.376 217.915 302.983 213.957 303.071 211.439 300.242 210.517 298.256 211.029 296.098"/>   <polyline class="continents" points="194.186 281.479 191.852 280.786 188.978 280.29 191.822 278.098 191.96 275.021 190.673 273.074 187.257 272.05 184.913 271.008 182.559 267.977 184.501 266.137 187.211 266.836 190.629 268.586 193.877 270.306 195.163 273.166 196.251 274.035 198.939 275.254 200.601 278.12 199.171 279.744 198.682 282.109 196.547 282.494 194.186 281.479"/>   <polyline class="continents" points="207.24 278.714 210.48 280.81 211.931 281.524 215.149 280.556 219.053 279.216 215.279 277.854 214.009 275.88 214.326 272.455 214.609 266.531 216.742 264.507 216.707 261.282 213.271 257.919 209.649 255.28 205.311 253.91 201.726 251.638 197.585 251.534 194.38 252.662 192.783 254.677 190.983 254.89 190.819 253.453 188.298 253.483 185.278 254.802 185.824 256.783 184.436 260.225 185.907 262.363 188.762 264.105 189.992 259.762 191.394 258.12 192.346 261.153 194.854 263.632 197.198 264.675 200.833 267.474 203.915 270.311 204.681 275.707 206.851 276.907 207.24 278.714"/>   <polyline class="continents" points="219.417 263.924 219.832 266.966 220.905 268.588 222.876 269.437 225.371 266.531 226.387 262.895 224.225 261.318 221.895 262.077 220.845 263.519 219.417 263.924"/>   <polyline class="continents" points="257.423 249.036 258.705 252.085 258.556 255.119 259.297 257.639 261.834 259.221 261.657 261.208 259.532 261.941 258.098 261.81 256.157 262.735 260.112 264.476 259.594 266.097 256.001 266.146 256.387 268.14 257.305 270.619 257.358 273.511 258.996 276.172 260.273 278.683 262.27 280.463 261.384 281.702 261.044 282.977 260.36 285.715 258.233 287.363 254.806 285.264 254.607 283.272 252.592 281.52 252.576 278.994 254.331 277.152 254.141 274.479 250.881 273.629 249.273 273.656 248.187 271.873 248.501 267.722 246.125 263.267 243.775 261.687 243.008 258.845 242.407 254.887 239.508 250.601 238.749 247.382 236.401 246.529 233.904 245.124 232.441 244.25 231.555 245.185 232.837 246.594 230.71 248.242 232.672 248.742 234.861 250.335 237.214 252.641 240.1 254.211 237.24 255.516 236.37 257.337 233.844 256.83 230.798 255.274 228.401 251.339 226.583 249.94 222.458 247.863 219.384 246.29 217.218 243.261 219.689 241.791 224.163 240.995 223.616 239.015 221.815 238.502 221.29 239.586 218.217 239.653 218.743 237.654 216.771 236.807 215.497 235.021 211.885 232.731 206.455 229.04 205.372 229.623 204.352 230.894 202.023 231.653 200.556 230.967 197.869 230.474 194.3 230.728 192.517 231.826 188.77 232.426 185.36 231.939 183.012 231.086 182.65 229.296 179.044 229.184 177.632 230.477 173.876 230.727 170.474 231.504 170.502 233.466 168.718 234.565 164.957 235.004 163.549 236.108 164.099 237.9 162.49 238.841 158.019 239.447 157.688 241.071 157.538 243.075 156.106 243.974 153.63 246.547 151.848 248.372 149.557 250.223 146.695 250.802 147.407 249.721 148.804 247.541 148.42 246.273 146.116 246.323 144.842 244.538 143.728 242.738 145.496 240.752 147.435 239.101 149.047 238.885 150.482 236.158 150.067 233.117 152.213 232.167 155.22 230.687 155.376 227.276 153.736 225.834 152.121 225.324 160.468 222.33 167.484 220.375 174.294 219.055 182.822 218.08 190.406 217.89 199.289 218.473 210.317 220.354 221.098 223.606 228.444 226.775 236.028 230.779 242.436 234.965 248.451 239.478 253.729 244.446 257.274 248.18 257.423 249.036"/>   <polyline class="continents" points="236.587 260.027 234.981 260.78 235.696 262.369 237.365 264.859 237.915 266.65 238.668 269.331 241.212 271.451 242.977 271.599 242.263 270.009 240.064 268.066 239.881 266.961 242.051 267.857 244.408 269.059 246.555 269.75 246.541 267.949 246.616 267.767 246.692 267.585 246.74 267.386 246.743 267.199 246.751 266.821 246.714 266.455 246.632 266.1 246.571 265.833 246.513 265.682 246.494 265.593 245.057 264.736 240.553 262.843 238.571 261.951 236.587 260.027"/>   <polyline class="continents" points="263.598 256.088 263.44 258.469 264.194 261.149 263.475 262.607 262.241 262.64 263.328 264.422 265.515 267.235 265.728 271.028 263.766 270.528 262.502 270.732 262.201 275.043 262.43 278.809 261.909 280.618 262.115 283.873 261.056 285.692 260.397 288.026 261.488 291.26 263.331 295.536 263.193 298.614 263.091 304.918 263.884 310.635 265.371 315.299 267.749 320.481 270.837 323.854 274.445 324.693 276.543 321.387 277.967 319.226 279.918 318.345 280.392 312.54 280.449 307.162 280.216 301.64 279.526 295.148 278.064 287.526 276.248 281.018 274.202 275.243 271.648 269.495 269.03 264.394 265.85 259.284 263.598 256.088"/>  </g> </g>        <g id="controls-heading-knob" transform="translate(0 -80)">            <circle class="controls-knob-circle one"/>            <circle class="controls-knob-circle two"/>            <path class="controls-knob-text" d="M-4,6 L-3,-4 L3,4 L4,-6"/>            <circle class="controls-knob-active-area"/>        </g>        <path id='controls-up-button' d="M-20,-35 L0,-63 L20,-35" class="arrow one"/>        <path id='controls-up-button' d="M-20,-35 L0,-63 L20,-35" class="arrow two"/>        <path id='controls-down-button' d="M-20,-35 L0,-63 L20,-35" class="arrow one" transform="rotate(180)"/>        <path id='controls-down-button' d="M-20,-35 L0,-63 L20,-35" class="arrow two" transform="rotate(180)"/>        <path id='controls-left-button' d="M-20,-35 L0,-63 L20,-35" class="arrow one" transform="rotate(270)"/>        <path id='controls-left-button' d="M-20,-35 L0,-63 L20,-35" class="arrow two" transform="rotate(270)"/>        <path id='controls-right-button' d="M-20,-35 L0,-63 L20,-35" class="arrow one" transform="rotate(90)"/>        <path id='controls-right-button' d="M-20,-35 L0,-63 L20,-35" class="arrow two" transform="rotate(90)"/>    </g>    <g id="controls-tilt">        <path d="M-100,-80 L-100,80" class="track one"/>        <path d="M-100,-80 L-100,80" class="track two"/>        <g id="controls-tilt-knob" transform="translate(-100 -80)">            <circle class="controls-knob-circle one"/>            <circle class="controls-knob-circle two"/>            <path class="controls-knob-text" d="M-5,-4 L5,-4 M0,-4 L0,6"/>            <circle class="controls-knob-active-area"/>        </g>    </g>    <g id="controls-range">        <path d="M100,-80 L100,80" class="track one"/>        <path d="M100,-80 L100,80" class="track two"/>        <g id="controls-range-knob" transform="translate(100 0)">            <circle class="controls-knob-circle one"/>            <circle class="controls-knob-circle two"/>            <path class="controls-knob-text" d="M-5,-4 L4,-4 L-4,4 L5,4"/>            <circle class="controls-knob-active-area"/>        </g>    </g></svg></div>    <script> (function(modules) { 
 	var installedModules = {};
 	function __webpack_require__(moduleId) {
 		if(installedModules[moduleId])
 			return installedModules[moduleId].exports;
 		var module = installedModules[moduleId] = {
 			exports: {},
 			id: moduleId,
 			loaded: false
 		};
 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
 		module.loaded = true;
 		return module.exports;
 	}
 	__webpack_require__.m = modules;
 	__webpack_require__.c = installedModules;
 	__webpack_require__.p = "";
 	return __webpack_require__(0);
 })
 ([
 function(module, exports, __webpack_require__) {
	__webpack_require__(1);	__webpack_require__(2);	__webpack_require__(92);	__webpack_require__(94);	__webpack_require__(95);
 },
 function(module, exports) {
	WorldWind = {	    configuration: {	        gpuCacheSize: 250e6	    },	    VERSION: "0.0.0",	    ABSOLUTE: "absolute",	    AFTER_REDRAW: "afterRedraw",	    BEFORE_REDRAW: "beforeRedraw",	    BEGAN: "began",	    CANCELLED: "cancelled",	    CHANGED: "changed",	    CLAMP_TO_GROUND: "clampToGround",	    EARTH_RADIUS: 6371e3,	    EAST: "east",	    ENDED: "ended",	    FAILED: "failed",	    GREAT_CIRCLE: "greatCircle",	    LINEAR: "linear",	    MULTI_POINT: "multiPoint",	    NORTH: "north",	    NULL: "null",	    OFFSET_FRACTION: "fraction",	    OFFSET_INSET_PIXELS: "insetPixels",	    OFFSET_PIXELS: "pixels",	    POINT: "point",	    POLYLINE: "polyline",	    POLYGON: "polygon",	    POSSIBLE: "possible",	    RECOGNIZED: "recognized",	    REDRAW_EVENT_TYPE: "WorldWindRedraw",	    RELATIVE_TO_GLOBE: "relativeToGlobe",	    RELATIVE_TO_GROUND: "relativeToGround",	    RELATIVE_TO_SCREEN: "relativeToScreen",	    RHUMB_LINE: "rhumbLine",	    SOUTH: "south",	    WEST: "west"	}; },
 function(module, exports, __webpack_require__) {
	var WorldWindow = __webpack_require__(3);	var AtmosphereLayer = __webpack_require__(82);	var SingleImageLayer = __webpack_require__(87);	var Globe3D = __webpack_require__(49);	var Globe2D = __webpack_require__(57);	var ZeroElevationModel = __webpack_require__(59);	var mainGlobe = new Globe3D(new ZeroElevationModel(), null);	var alterGlobe = new Globe2D();	var earth = new WorldWindow('canvas', mainGlobe);	earth.addLayer(new SingleImageLayer('day.jpg'));	earth.addLayer(new AtmosphereLayer('night.png'));	earth.redraw();	watch(earth.navigator, 'heading', navigatorStateChanged);	watch(earth.navigator, 'tilt', navigatorStateChanged);	watch(earth.navigator, 'range', navigatorStateChanged);	var events = __webpack_require__(91);	events.listen(events.SWITCH_GLOBE, function () {	    earth.globe = [alterGlobe, alterGlobe = earth.globe][0]; 	    earth.redraw();	});	var rotationInterval;	var directions = ['up', 'down', 'left', 'right'];	events.listen(events.CONTROLS_CHANGED, function(state) {	    var loc = earth.navigator.lookAtLocation;	    var param = state.parameter;	    if (directions.indexOf(param) > -1) {	        handleArrow();	    } else {	        earth.navigator[param] = state.value;	        earth.redraw();	    }	    function handleArrow() {	        var amount = 0.07 * earth.navigator.range / 1e6;	        var sign = 'up' == param || 'right' == param ? 1 : -1;	        var horizontal = 'left' == param || 'right' == param;	        if (state.value) {	            clearInterval(rotationInterval);	            rotationInterval = setInterval(rotate, 25);	        } else {	            clearInterval(rotationInterval);	        }	        function rotate() {	            loc[horizontal ? 'longitude' : 'latitude'] += sign * amount;	            earth.redraw();	        }	    }	});	events.listen(events.ROTATE_TO, function (state) {	});	function navigatorStateChanged(value, parameter) {	    var state = {};	    state[parameter] = value;	    events.post(events.NAVIGATOR_STATE_CHANGED, state);	}	function watch(object, propertyName, callback) {	    var oldValue = object[propertyName];	    var newValue = oldValue;	    Object.defineProperty(object, propertyName, {	        get: getter,	        set: setter	    });	    function getter() {	        return newValue;	    }	    function setter(val) {	        oldValue = newValue;	        if (oldValue != val) {	            callback(val, propertyName);	        }	        return newValue = val;	    }	}
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(63),	        __webpack_require__(30),	        __webpack_require__(48),	        __webpack_require__(49),	        __webpack_require__(57),	        __webpack_require__(60),	        __webpack_require__(61),	        __webpack_require__(9),	        __webpack_require__(4),	        __webpack_require__(23),	        __webpack_require__(64),	        __webpack_require__(20),	        __webpack_require__(31),	        __webpack_require__(75),	        __webpack_require__(77),	        __webpack_require__(54),	        __webpack_require__(24)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              DrawContext,	              EarthElevationModel,	              FrameStatistics,	              Globe,	              Globe2D,	              GoToAnimator,	              GpuResourceCache,	              Logger,	              LookAtNavigator,	              NavigatorState,	              PickedObjectList,	              Rectangle,	              Sector,	              SurfaceShape,	              SurfaceShapeTileBuilder,	              Terrain,	              Vec2) {	        "use strict";	        var WorldWindow = function (canvasName, elevationModel) {	            if (!(window.WebGLRenderingContext)) {	                throw new ArgumentError(	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "constructor",	                        "The specified canvas does not support WebGL."));	            }	            var canvas = document.getElementById(canvasName);	            var gl = this.createContext(canvas);	            this.drawContext = new DrawContext(gl);	            this.eventListeners = {};	            this.redrawRequested = true;	            this.redrawRequestId = null;	            this.canvas = canvas;	            this.depthBits = gl.getParameter(gl.DEPTH_BITS);	            this.viewport = new Rectangle(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);	            this.globe = new Globe(elevationModel || new EarthElevationModel());	            this.layers = [];	            this.navigator = new LookAtNavigator(this);	            this.verticalExaggeration = 1;	            this.deepPicking = false;	            this.subsurfaceMode = false;	            this.surfaceOpacity = 1;	            this.frameStatistics = new FrameStatistics();	            this.goToAnimator = new GoToAnimator(this);	            this._redrawCallbacks = [];	            this._orderedRenderingFilters = [	                function (dc) {	                    thisWindow.declutter(dc, 1);	                },	                function (dc) {	                    thisWindow.declutter(dc, 2);	                }	            ];	            this.pixelScale = 1;	            var thisWindow = this;	            function handleContextLost(event) {	                thisWindow.handleContextLost(event);	            }	            this.canvas.addEventListener("webglcontextlost", handleContextLost, false);	            function handleContextRestored(event) {	                thisWindow.handleContextRestored(event);	            }	            this.canvas.addEventListener("webglcontextrestored", handleContextRestored, false);	            function handleRedrawEvent(event) {	                thisWindow.handleRedrawEvent(event)	            }	            this.canvas.addEventListener(WorldWind.REDRAW_EVENT_TYPE, handleRedrawEvent, false);	            window.addEventListener(WorldWind.REDRAW_EVENT_TYPE, handleRedrawEvent, false);	            this.animationFrameLoop();	        };	        Object.defineProperties(WorldWindow.prototype, {	            orderedRenderingFilters: {	                get: function () {	                    return this._orderedRenderingFilters;	                }	            },	            redrawCallbacks: {	                get: function () {	                    return this._redrawCallbacks;	                }	            }	        });	        WorldWindow.prototype.canvasCoordinates = function (x, y) {	            var bbox = this.canvas.getBoundingClientRect(),	                xc = x - (bbox.left + this.canvas.clientLeft),	                yc = y - (bbox.top + this.canvas.clientTop);	            return new Vec2(xc, yc);	        };	        WorldWindow.prototype.addEventListener = function (type, listener) {	            var thisWorldWindow = this;	            var entry = this.eventListeners[type];	            if (!entry) {	                entry = {	                    listeners: [],	                    callback: function (event) { 	                        event.worldWindow = thisWorldWindow;	                        for (var i = 0, len = entry.listeners.length; i < len; i++) {	                            entry.listeners[i](event);	                        }	                    }	                };	                this.eventListeners[type] = entry;	            }	            var index = entry.listeners.indexOf(listener);	            if (index == -1) { 	                entry.listeners.splice(0, 0, listener); 	                if (entry.listeners.length == 1) { 	                    this.canvas.addEventListener(type, entry.callback, false);	                }	            }	        };	        WorldWindow.prototype.removeEventListener = function (type, listener) {	            var entry = this.eventListeners[type];	            if (!entry) {	                return; 	            }	            var index = entry.listeners.indexOf(listener);	            if (index != -1) {	                entry.listeners.splice(index, 1); 	                if (entry.listeners.length == 0) { 	                    this.canvas.removeEventListener(type, entry.callback, false);	                }	            }	        };	        WorldWindow.prototype.redraw = function () {	            this.redrawRequested = true; 	        };	        WorldWindow.prototype.pick = function (pickPoint) {	            if (this.drawContext.currentGlContext.isContextLost()) {	                return new PickedObjectList();	            }	            this.resize();	            this.resetDrawContext();	            this.drawContext.pickingMode = true;	            this.drawContext.pickPoint = pickPoint;	            this.drawFrame();	            return this.drawContext.objectsAtPickPoint;	        };	        WorldWindow.prototype.pickTerrain = function (pickPoint) {	            if (this.drawContext.currentGlContext.isContextLost()) {	                return new PickedObjectList();	            }	            this.resize();	            this.resetDrawContext();	            this.drawContext.pickingMode = true;	            this.drawContext.pickTerrainOnly = true;	            this.drawContext.pickPoint = pickPoint;	            this.drawFrame();	            return this.drawContext.objectsAtPickPoint;	        };	        WorldWindow.prototype.pickShapesInRegion = function (rectangle) {	            if (this.drawContext.currentGlContext.isContextLost()) {	                return new PickedObjectList();	            }	            this.resize();	            this.resetDrawContext();	            this.drawContext.pickingMode = true;	            this.drawContext.regionPicking = true;	            this.drawContext.pickRectangle =	                new Rectangle(rectangle.x, this.canvas.height - rectangle.y, rectangle.width, rectangle.height);	            this.drawFrame();	            return this.drawContext.objectsAtPickPoint;	        };	        WorldWindow.prototype.createContext = function (canvas) {	            var glAttrs = {antialias: false, stencil: true},	                gl = canvas.getContext("webgl", glAttrs);	            if (!gl) {	                gl = canvas.getContext("experimental-webgl", glAttrs);	            }	            var actualAttributes = gl.getContextAttributes();	            this.hasStencilBuffer = actualAttributes.stencil;	            return gl;	        };	        WorldWindow.prototype.handleContextLost = function (event) {	            Logger.log(Logger.LEVEL_INFO, "WebGL context event: " + event.statusMessage);	            event.preventDefault();	            this.drawContext.contextLost();	            window.cancelAnimationFrame(this.redrawRequestId);	        };	        WorldWindow.prototype.handleContextRestored = function (event) {	            Logger.log(Logger.LEVEL_INFO, "WebGL context event: " + event.statusMessage);	            this.drawContext.contextRestored();	            this.redraw();	            this.animationFrameLoop();	        };	        WorldWindow.prototype.handleRedrawEvent = function (event) {	            this.redraw(); 	        };	        WorldWindow.prototype.animationFrameLoop = function () {	            this.redrawIfNeeded();	            var thisWindow = this;	            function animationFrameCallback() {	                thisWindow.animationFrameLoop();	            }	            this.redrawRequestId = window.requestAnimationFrame(animationFrameCallback);	        };	        WorldWindow.prototype.redrawIfNeeded = function () {	            this.resize();	            if (!this.redrawRequested) {	                return;	            }	            try {	                this.redrawRequested = false;	                this.drawContext.previousRedrawTimestamp = this.drawContext.timestamp;	                this.callRedrawCallbacks(WorldWind.BEFORE_REDRAW);	                this.resetDrawContext();	                this.drawFrame();	            } catch (e) {	                Logger.logMessage(Logger.LEVEL_SEVERE, "WorldWindow", "redrawIfNeeded",	                    "Exception occurred during redrawing.\n" + e.toString());	            } finally {	                this.callRedrawCallbacks(WorldWind.AFTER_REDRAW);	                if (this.drawContext.redrawRequested) {	                    this.redrawRequested = true;	                }	            }	        };	        WorldWindow.prototype.resize = function () {	            var gl = this.drawContext.currentGlContext,	                width = gl.canvas.clientWidth * this.pixelScale,	                height = gl.canvas.clientHeight * this.pixelScale;	            if (gl.canvas.width != width ||	                gl.canvas.height != height) {	                gl.canvas.width = width;	                gl.canvas.height = height;	                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);	                this.viewport = new Rectangle(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);	                this.redrawRequested = true;	            }	        };	        WorldWindow.prototype.resetDrawContext = function () {	            this.globe.offset = 0;	            var dc = this.drawContext;	            dc.reset();	            dc.globe = this.globe;	            dc.layers = this.layers;	            dc.navigatorState = this.navigator.currentState();	            dc.verticalExaggeration = this.verticalExaggeration;	            dc.surfaceOpacity = this.surfaceOpacity;	            dc.deepPicking = this.deepPicking;	            dc.frameStatistics = this.frameStatistics;	            dc.pixelScale = this.pixelScale;	            dc.update();	        };	        WorldWindow.prototype.drawFrame = function () {	            try {	                this.drawContext.frameStatistics.beginFrame();	                this.beginFrame();	                if (this.drawContext.globe.is2D() && this.drawContext.globe.continuous) {	                    this.do2DContiguousRepaint();	                } else {	                    this.doNormalRepaint();	                }	            } finally {	                this.endFrame();	                this.drawContext.frameStatistics.endFrame();	            }	        };	        WorldWindow.prototype.doNormalRepaint = function () {	            this.createTerrain();	            this.clearFrame();	            this.deferOrderedRendering = false;	            if (this.drawContext.pickingMode) {	                if (this.drawContext.makePickFrustum()) {	                    this.doPick();	                    this.resolvePick();	                }	            } else {	                this.doDraw();	                if (this.subsurfaceMode && this.hasStencilBuffer) {	                    this.redrawSurface();	                    this.drawScreenRenderables();	                }	            }	        };	        WorldWindow.prototype.do2DContiguousRepaint = function () {	            this.createTerrain2DContiguous();	            this.clearFrame();	            if (this.drawContext.pickingMode) {	                if (this.drawContext.makePickFrustum()) {	                    this.pick2DContiguous();	                    this.resolvePick();	                }	            } else {	                this.draw2DContiguous();	            }	        };	        WorldWindow.prototype.resolvePick = function () {	            if (this.drawContext.pickTerrainOnly) {	                this.resolveTerrainPick();	            } else if (this.drawContext.regionPicking) {	                this.resolveRegionPick();	            } else {	                this.resolveTopPick();	            }	        };	        WorldWindow.prototype.beginFrame = function () {	            var gl = this.drawContext.currentGlContext;	            gl.enable(gl.BLEND);	            gl.enable(gl.CULL_FACE);	            gl.enable(gl.DEPTH_TEST);	            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);	            gl.depthFunc(gl.LEQUAL);	            if (this.drawContext.pickingMode) {	                this.drawContext.makePickFramebuffer();	                this.drawContext.bindFramebuffer(this.drawContext.pickFramebuffer);	            }	        };	        WorldWindow.prototype.endFrame = function () {	            var gl = this.drawContext.currentGlContext;	            gl.disable(gl.BLEND);	            gl.disable(gl.CULL_FACE);	            gl.disable(gl.DEPTH_TEST);	            gl.blendFunc(gl.ONE, gl.ZERO);	            gl.depthFunc(gl.LESS);	            gl.clearColor(0, 0, 0, 1);	            this.drawContext.bindFramebuffer(null);	            this.drawContext.bindProgram(null);	        };	        WorldWindow.prototype.clearFrame = function () {	            var dc = this.drawContext,	                gl = dc.currentGlContext;	            gl.clearColor(dc.clearColor.red, dc.clearColor.green, dc.clearColor.blue, dc.clearColor.alpha);	            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);	        };	        WorldWindow.prototype.doDraw = function () {	            this.drawContext.renderShapes = true;	            if (this.subsurfaceMode && this.hasStencilBuffer) {	                this.drawContext.currentGlContext.disable(this.drawContext.currentGlContext.STENCIL_TEST);	                this.drawContext.surfaceShapeTileBuilder.clear();	                this.drawLayers(true);	                this.drawSurfaceRenderables();	                this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);	                if (!this.deferOrderedRendering) {	                    this.drawContext.currentGlContext.clear(	                        this.drawContext.currentGlContext.DEPTH_BUFFER_BIT | this.drawContext.currentGlContext.STENCIL_BUFFER_BIT);	                    this.drawContext.currentGlContext.enable(this.drawContext.currentGlContext.STENCIL_TEST);	                    this.drawContext.currentGlContext.stencilFunc(this.drawContext.currentGlContext.ALWAYS, 1, 1);	                    this.drawContext.currentGlContext.stencilOp(	                        this.drawContext.currentGlContext.REPLACE, this.drawContext.currentGlContext.REPLACE, this.drawContext.currentGlContext.REPLACE);	                    this.drawOrderedRenderables();	                    this.drawContext.screenCreditController.drawCredits(this.drawContext);	                }	            } else {	                this.drawContext.surfaceShapeTileBuilder.clear();	                this.drawLayers(true);	                this.drawSurfaceRenderables();	                this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);	                if (!this.deferOrderedRendering) {	                    this.drawOrderedRenderables();	                    this.drawScreenRenderables();	                }	                this.drawContext.screenCreditController.drawCredits(this.drawContext);	            }	        };	        WorldWindow.prototype.redrawSurface = function () {	            this.drawContext.currentGlContext.enable(this.drawContext.currentGlContext.STENCIL_TEST);	            this.drawContext.currentGlContext.stencilFunc(this.drawContext.currentGlContext.EQUAL, 1, 1);	            this.drawContext.currentGlContext.stencilOp(	                this.drawContext.currentGlContext.KEEP, this.drawContext.currentGlContext.KEEP, this.drawContext.currentGlContext.KEEP);	            this.drawContext.surfaceShapeTileBuilder.clear();	            this.drawLayers(false);	            this.drawSurfaceRenderables();	            this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);	            this.drawContext.currentGlContext.disable(this.drawContext.currentGlContext.STENCIL_TEST);	        };	        WorldWindow.prototype.doPick = function () {	            if (this.drawContext.terrain) {	                this.drawContext.terrain.pick(this.drawContext);	            }	            if (!this.drawContext.pickTerrainOnly) {	                if (this.subsurfaceMode && this.hasStencilBuffer) {	                    this.drawContext.currentGlContext.disable(this.drawContext.currentGlContext.STENCIL_TEST);	                    this.drawContext.surfaceShapeTileBuilder.clear();	                    this.drawLayers(true);	                    this.drawSurfaceRenderables();	                    this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);	                    if (!this.deferOrderedRendering) {	                        this.drawContext.currentGlContext.clear(	                            this.drawContext.currentGlContext.DEPTH_BUFFER_BIT | this.drawContext.currentGlContext.STENCIL_BUFFER_BIT);	                        this.drawContext.currentGlContext.enable(this.drawContext.currentGlContext.STENCIL_TEST);	                        this.drawContext.currentGlContext.stencilFunc(this.drawContext.currentGlContext.ALWAYS, 1, 1);	                        this.drawContext.currentGlContext.stencilOp(	                            this.drawContext.currentGlContext.REPLACE, this.drawContext.currentGlContext.REPLACE, this.drawContext.currentGlContext.REPLACE);	                        this.drawOrderedRenderables();	                        this.drawContext.terrain.pick(this.drawContext);	                        this.drawScreenRenderables();	                    }	                } else {	                    this.drawContext.surfaceShapeTileBuilder.clear();	                    this.drawLayers(true);	                    this.drawSurfaceRenderables();	                    this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);	                    if (!this.deferOrderedRendering) {	                        this.drawOrderedRenderables();	                        this.drawScreenRenderables();	                    }	                }	            }	        };	        WorldWindow.prototype.createTerrain = function () {	            var dc = this.drawContext;	            dc.terrain = this.globe.tessellator.tessellate(dc);	            dc.frameStatistics.setTerrainTileCount(dc.terrain ? dc.terrain.surfaceGeometry.length : 0);	        };	        WorldWindow.prototype.makeCurrent = function (offset) {	            var dc = this.drawContext;	            dc.globe.offset = offset;	            dc.globeStateKey = dc.globe.stateKey;	            switch (offset) {	                case -1:	                    dc.terrain = this.terrainLeft;	                    break;	                case 0:	                    dc.terrain = this.terrainCenter;	                    break;	                case 1:	                    dc.terrain = this.terrainRight;	                    break;	            }	        };	        WorldWindow.prototype.createTerrain2DContiguous = function () {	            var dc = this.drawContext;	            this.terrainCenter = null;	            dc.globe.offset = 0;	            dc.globeStateKey = dc.globe.stateKey;	            if (dc.globe.intersectsFrustum(dc.navigatorState.frustumInModelCoordinates)) {	                this.terrainCenter = dc.globe.tessellator.tessellate(dc);	            }	            this.terrainRight = null;	            dc.globe.offset = 1;	            dc.globeStateKey = dc.globe.stateKey;	            if (dc.globe.intersectsFrustum(dc.navigatorState.frustumInModelCoordinates)) {	                this.terrainRight = dc.globe.tessellator.tessellate(dc);	            }	            this.terrainLeft = null;	            dc.globe.offset = -1;	            dc.globeStateKey = dc.globe.stateKey;	            if (dc.globe.intersectsFrustum(dc.navigatorState.frustumInModelCoordinates)) {	                this.terrainLeft = dc.globe.tessellator.tessellate(dc);	            }	        };	        WorldWindow.prototype.draw2DContiguous = function () {	            var drawing = "";	            if (this.terrainCenter) {	                drawing += " 0 ";	                this.makeCurrent(0);	                this.deferOrderedRendering = this.terrainLeft || this.terrainRight;	                this.doDraw();	            }	            if (this.terrainRight) {	                drawing += " 1 ";	                this.makeCurrent(1);	                this.deferOrderedRendering = this.terrainLeft || this.terrainLeft;	                this.doDraw();	            }	            this.deferOrderedRendering = false;	            if (this.terrainLeft) {	                drawing += " -1 ";	                this.makeCurrent(-1);	                this.doDraw();	            }	            if (this.subsurfaceMode && this.hasStencilBuffer) {	                this.deferOrderedRendering = true;	                if (this.terrainCenter) {	                    drawing += " 0 ";	                    this.makeCurrent(0);	                    this.redrawSurface();	                }	                if (this.terrainRight) {	                    drawing += " 1 ";	                    this.makeCurrent(1);	                    this.redrawSurface();	                }	                if (this.terrainLeft) {	                    drawing += " -1 ";	                    this.makeCurrent(-1);	                    this.redrawSurface();	                }	            }	            this.drawScreenRenderables();	        };	        WorldWindow.prototype.pick2DContiguous = function () {	            if (this.terrainCenter) {	                this.makeCurrent(0);	                this.deferOrderedRendering = this.terrainLeft || this.terrainRight;	                this.doPick();	            }	            if (this.terrainRight) {	                this.makeCurrent(1);	                this.deferOrderedRendering = this.terrainLeft || this.terrainLeft;	                this.doPick();	            }	            this.deferOrderedRendering = false;	            if (this.terrainLeft) {	                this.makeCurrent(-1);	                this.doPick();	            }	        };	        WorldWindow.prototype.drawLayers = function (accumulateOrderedRenderables) {	            var beginTime = Date.now(),	                dc = this.drawContext,	                layers = dc.layers,	                layer;	            dc.accumulateOrderedRenderables = accumulateOrderedRenderables;	            for (var i = 0, len = layers.length; i < len; i++) {	                layer = layers[i];	                if (layer) {	                    dc.currentLayer = layer;	                    try {	                        layer.render(dc);	                    } catch (e) {	                        Logger.log(Logger.LEVEL_SEVERE, "Error while rendering layer " + layer.displayName + ".\n"	                            + e.toString());	                    }	                }	            }	            var now = Date.now();	            dc.frameStatistics.layerRenderingTime = now - beginTime;	        };	        WorldWindow.prototype.addLayer = function (layer) {	            this.layers.push(layer);	        };	        WorldWindow.prototype.removeLayer = function (layer) {	            if (!layer)	                return;	            var index = -1;	            for (var i = 0, len = this.layers.length; i < len; i++) {	                if (this.layers[i] == layer) {	                    index = i;	                    break;	                }	            }	            if (index >= 0) {	                this.layers.splice(index, 1);	            }	        };	        WorldWindow.prototype.insertLayer = function (index, layer) {	            if (layer) {	                this.layers.splice(index, 0, layer);	            }	        };	        WorldWindow.prototype.drawSurfaceRenderables = function () {	            var dc = this.drawContext,	                sr;	            dc.reverseSurfaceRenderables();	            while (sr = dc.popSurfaceRenderable()) {	                try {	                    sr.renderSurface(dc);	                } catch (e) {	                    Logger.logMessage(Logger.LEVEL_WARNING, "WorldWindow", "drawSurfaceRenderables",	                        "Error while rendering a surface renderable.\n" + e.message);	                }	            }	        };	        WorldWindow.prototype.drawOrderedRenderables = function () {	            var beginTime = Date.now(),	                dc = this.drawContext,	                or;	            dc.sortOrderedRenderables();	            if (this._orderedRenderingFilters) {	                for (var f = 0; f < this._orderedRenderingFilters.length; f++) {	                    this._orderedRenderingFilters[f](this.drawContext);	                }	            }	            dc.orderedRenderingMode = true;	            while (or = dc.popOrderedRenderable()) {	                try {	                    or.renderOrdered(dc);	                } catch (e) {	                    Logger.logMessage(Logger.LEVEL_WARNING, "WorldWindow", "drawOrderedRenderables",	                        "Error while rendering an ordered renderable.\n" + e.message);	                }	            }	            dc.orderedRenderingMode = false;	            dc.frameStatistics.orderedRenderingTime = Date.now() - beginTime;	        };	        WorldWindow.prototype.drawScreenRenderables = function () {	            var dc = this.drawContext,	                or;	            while (or = dc.nextScreenRenderable()) {	                try {	                    or.renderOrdered(dc);	                } catch (e) {	                    Logger.logMessage(Logger.LEVEL_WARNING, "WorldWindow", "drawOrderedRenderables",	                        "Error while rendering a screen renderable.\n" + e.message);	                }	            }	        };	        WorldWindow.prototype.resolveTopPick = function () {	            if (this.drawContext.objectsAtPickPoint.objects.length == 0) {	                return; 	            }	            var pickedObjects = this.drawContext.objectsAtPickPoint,	                pickColor = this.drawContext.readPickColor(this.drawContext.pickPoint),	                topObject = null,	                terrainObject = null;	            if (pickColor) {	                for (var i = 0, len = pickedObjects.objects.length; i < len; i++) {	                    var po = pickedObjects.objects[i];	                    if (po.isTerrain) {	                        terrainObject = po;	                    }	                    if (po.color.equals(pickColor)) {	                        po.isOnTop = true;	                        topObject = po;	                        if (terrainObject) {	                            break; 	                        }	                    }	                }	                if (!this.drawContext.deepPicking) {	                    pickedObjects.clear();	                    if (topObject) {	                        pickedObjects.add(topObject);	                    }	                    if (terrainObject && terrainObject != topObject) {	                        pickedObjects.add(terrainObject);	                    }	                }	            } else {	                pickedObjects.clear(); 	            }	        };	        WorldWindow.prototype.resolveTerrainPick = function () {	            var pickedObjects = this.drawContext.objectsAtPickPoint,	                po;	            for (var i = 0, len = pickedObjects.objects.length; i < len; i++) {	                po = pickedObjects.objects[i];	                if (po.isTerrain) {	                    po.isOnTop = true;	                    break;	                }	            }	        };	        WorldWindow.prototype.resolveRegionPick = function () {	            if (this.drawContext.objectsAtPickPoint.objects.length == 0) {	                return; 	            }	            var pickedObjects = this.drawContext.objectsAtPickPoint,	                uniquePickColors = this.drawContext.readPickColors(this.drawContext.pickRectangle),	                po,	                color;	            for (var i = 0, len = pickedObjects.objects.length; i < len; i++) {	                po = pickedObjects.objects[i];	                if (!po) continue;	                var poColor = po.color.toByteString();	                color = uniquePickColors[poColor];	                if (color) {	                    po.isOnTop = true;	                } else if (po.userObject instanceof SurfaceShape) {	                    pickedObjects.objects.splice(i, 1);	                    i -= 1;	                }	            }	        };	        WorldWindow.prototype.callRedrawCallbacks = function (stage) {	            for (var i = 0, len = this._redrawCallbacks.length; i < len; i++) {	                try {	                    this._redrawCallbacks[i](this, stage);	                } catch (e) {	                    Logger.log(Logger.LEVEL_SEVERE, "Exception calling redraw callback.\n" + e.toString());	                }	            }	        };	        WorldWindow.prototype.goTo = function (position, completionCallback) {	            this.goToAnimator.goTo(position, completionCallback);	        };	        WorldWindow.prototype.declutter = function (dc, groupId) {	            var declutterables = [];	            for (var i = 0; i < dc.orderedRenderables.length; i++) {	                var orderedRenderable = dc.orderedRenderables[i].orderedRenderable;	                if (orderedRenderable.declutterGroup === groupId) {	                    declutterables.push(orderedRenderable);	                }	            }	            var rects = [];	            for (var j = 0; j < declutterables.length; j++) {	                var declutterable = declutterables[j],	                    screenBounds = declutterable.screenBounds;	                if (screenBounds && screenBounds.intersectsRectangles(rects)) {	                    declutterable.targetVisibility = 0;	                } else {	                    declutterable.targetVisibility = 1;	                    if (screenBounds) {	                        rects.push(screenBounds);	                    }	                }	            }	        };	        return WorldWindow;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(11),	        __webpack_require__(26),	        __webpack_require__(12),	        __webpack_require__(6),	        __webpack_require__(15),	        __webpack_require__(18),	        __webpack_require__(9),	        __webpack_require__(13),	        __webpack_require__(22),	        __webpack_require__(5),	        __webpack_require__(27),	        __webpack_require__(17),	        __webpack_require__(28),	        __webpack_require__(29),	        __webpack_require__(24),	        __webpack_require__(16),	        __webpack_require__(19)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,	              DragRecognizer,	              Frustum,	              GestureRecognizer,	              Line,	              Location,	              Logger,	              Matrix,	              Navigator,	              PanRecognizer,	              PinchRecognizer,	              Position,	              RotationRecognizer,	              TiltRecognizer,	              Vec2,	              Vec3,	              WWMath) {	        "use strict";	        var LookAtNavigator = function (worldWindow) {	            Navigator.call(this, worldWindow);	            function preventDefaultListener(event) {	                event.preventDefault();	            }	            worldWindow.addEventListener("mousedown", preventDefaultListener);	            worldWindow.addEventListener("touchstart", preventDefaultListener);	            worldWindow.addEventListener("contextmenu", preventDefaultListener);	            worldWindow.addEventListener("wheel", preventDefaultListener);	            if (window.PointerEvent) {	                worldWindow.canvas.style.setProperty("touch-action", "none");	            }	            this.lookAtLocation = new Location(30, -110);	            this.range = 10e6; 	            this.enable2DLimits = true;	            var thisNavigator = this;	            this.primaryDragRecognizer = new DragRecognizer(worldWindow, function (recognizer) {	                thisNavigator.handlePanOrDrag(recognizer);	            });	            this.secondaryDragRecognizer = new DragRecognizer(worldWindow, function (recognizer) {	                thisNavigator.handleSecondaryDrag(recognizer);	            });	            this.secondaryDragRecognizer.button = 2; 	            this.panRecognizer = new PanRecognizer(worldWindow, function (recognizer) {	                thisNavigator.handlePanOrDrag(recognizer);	            });	            this.pinchRecognizer = new PinchRecognizer(worldWindow, function (recognizer) {	                thisNavigator.handlePinch(recognizer);	            });	            this.rotationRecognizer = new RotationRecognizer(worldWindow, function (recognizer) {	                thisNavigator.handleRotation(recognizer);	            });	            this.tiltRecognizer = new TiltRecognizer(worldWindow, function (recognizer) {	                thisNavigator.handleTilt(recognizer);	            });	            worldWindow.addEventListener("wheel", function (event) {	                thisNavigator.handleWheelEvent(event);	            });	            this.panRecognizer.recognizeSimultaneouslyWith(this.pinchRecognizer);	            this.panRecognizer.recognizeSimultaneouslyWith(this.rotationRecognizer);	            this.pinchRecognizer.recognizeSimultaneouslyWith(this.rotationRecognizer);	            this.panRecognizer.requireRecognizerToFail(this.tiltRecognizer);	            this.pinchRecognizer.requireRecognizerToFail(this.tiltRecognizer);	            this.rotationRecognizer.requireRecognizerToFail(this.tiltRecognizer);	            this.beginPoint = new Vec2(0, 0);	            this.lastPoint = new Vec2(0, 0);	            this.beginHeading = 0;	            this.beginTilt = 0;	            this.beginRange = 0;	            this.lastRotation = 0;	        };	        LookAtNavigator.prototype = Object.create(Navigator.prototype);	        LookAtNavigator.prototype.currentState = function () {	            this.applyLimits();	            var globe = this.worldWindow.globe,	                lookAtPosition = new Position(this.lookAtLocation.latitude, this.lookAtLocation.longitude, 0),	                modelview = Matrix.fromIdentity();	            modelview.multiplyByLookAtModelview(lookAtPosition, this.range, this.heading, this.tilt, this.roll, globe);	            return this.currentStateForModelview(modelview);	        };	        LookAtNavigator.prototype.handlePanOrDrag = function (recognizer) {	            if (this.worldWindow.globe.is2D()) {	                this.handlePanOrDrag2D(recognizer);	            } else {	                this.handlePanOrDrag3D(recognizer);	            }	        };	        LookAtNavigator.prototype.handlePanOrDrag3D = function (recognizer) {	            var state = recognizer.state,	                tx = recognizer.translationX,	                ty = recognizer.translationY;	            if (state == WorldWind.BEGAN) {	                this.lastPoint.set(0, 0);	            } else if (state == WorldWind.CHANGED) {	                var canvas = this.worldWindow.canvas,	                    globe = this.worldWindow.globe,	                    globeRadius = WWMath.max(globe.equatorialRadius, globe.polarRadius),	                    distance = WWMath.max(1, this.range),	                    metersPerPixel = WWMath.perspectivePixelSize(canvas.clientWidth, canvas.clientHeight, distance),	                    forwardMeters = (ty - this.lastPoint[1]) * metersPerPixel,	                    sideMeters = -(tx - this.lastPoint[0]) * metersPerPixel,	                    forwardDegrees = (forwardMeters / globeRadius) * Angle.RADIANS_TO_DEGREES,	                    sideDegrees = (sideMeters / globeRadius) * Angle.RADIANS_TO_DEGREES;	                var sinHeading = Math.sin(this.heading * Angle.DEGREES_TO_RADIANS),	                    cosHeading = Math.cos(this.heading * Angle.DEGREES_TO_RADIANS);	                this.lookAtLocation.latitude += forwardDegrees * cosHeading - sideDegrees * sinHeading;	                this.lookAtLocation.longitude += forwardDegrees * sinHeading + sideDegrees * cosHeading;	                this.lastPoint.set(tx, ty);	                this.applyLimits();	                this.worldWindow.redraw();	            }	        };	        LookAtNavigator.prototype.handlePanOrDrag2D = function (recognizer) {	            var state = recognizer.state,	                x = recognizer.clientX,	                y = recognizer.clientY,	                tx = recognizer.translationX,	                ty = recognizer.translationY;	            if (state == WorldWind.BEGAN) {	                this.beginPoint.set(x, y);	                this.lastPoint.set(x, y);	            } else if (state == WorldWind.CHANGED) {	                var x1 = this.lastPoint[0],	                    y1 = this.lastPoint[1],	                    x2 = this.beginPoint[0] + tx,	                    y2 = this.beginPoint[1] + ty;	                this.lastPoint.set(x2, y2);	                var navState = this.currentState(),	                    globe = this.worldWindow.globe,	                    ray = navState.rayFromScreenPoint(this.worldWindow.canvasCoordinates(x1, y1)),	                    point1 = new Vec3(0, 0, 0),	                    point2 = new Vec3(0, 0, 0),	                    origin = new Vec3(0, 0, 0);	                if (!globe.intersectsLine(ray, point1)) {	                    return;	                }	                ray = navState.rayFromScreenPoint(this.worldWindow.canvasCoordinates(x2, y2));	                if (!globe.intersectsLine(ray, point2)) {	                    return;	                }	                var modelview = Matrix.fromIdentity();	                modelview.copy(navState.modelview);	                modelview.multiplyByTranslation(point2[0] - point1[0], point2[1] - point1[1], point2[2] - point1[2]);	                modelview.extractEyePoint(ray.origin);	                modelview.extractForwardVector(ray.direction);	                if (!globe.intersectsLine(ray, origin)) {	                    return;	                }	                var params = modelview.extractViewingParameters(origin, this.roll, globe, {});	                this.lookAtLocation.copy(params.origin);	                this.range = params.range;	                this.heading = params.heading;	                this.tilt = params.tilt;	                this.roll = params.roll;	                this.applyLimits();	                this.worldWindow.redraw();	            }	        };	        LookAtNavigator.prototype.handleSecondaryDrag = function (recognizer) {	            var state = recognizer.state,	                tx = recognizer.translationX,	                ty = recognizer.translationY;	            if (state == WorldWind.BEGAN) {	                this.beginHeading = this.heading;	                this.beginTilt = this.tilt;	            } else if (state == WorldWind.CHANGED) {	                var headingDegrees = 180 * tx / this.worldWindow.canvas.clientWidth,	                    tiltDegrees = 90 * ty / this.worldWindow.canvas.clientHeight;	                this.heading = this.beginHeading + headingDegrees;	                this.tilt = this.beginTilt + tiltDegrees;	                this.applyLimits();	                this.worldWindow.redraw();	            }	        };	        LookAtNavigator.prototype.handlePinch = function (recognizer) {	            var state = recognizer.state,	                scale = recognizer.scale;	            if (state == WorldWind.BEGAN) {	                this.beginRange = this.range;	            } else if (state == WorldWind.CHANGED) {	                if (scale != 0) {	                    this.range = this.beginRange / scale;	                    this.applyLimits();	                    this.worldWindow.redraw();	                }	            }	        };	        LookAtNavigator.prototype.handleRotation = function (recognizer) {	            var state = recognizer.state,	                rotation = recognizer.rotation;	            if (state == WorldWind.BEGAN) {	                this.lastRotation = 0;	            } else if (state == WorldWind.CHANGED) {	                this.heading -= rotation - this.lastRotation;	                this.lastRotation = rotation;	                this.applyLimits();	                this.worldWindow.redraw();	            }	        };	        LookAtNavigator.prototype.handleTilt = function (recognizer) {	            var state = recognizer.state,	                ty = recognizer.translationY;	            if (state == WorldWind.BEGAN) {	                this.beginTilt = this.tilt;	            } else if (state == WorldWind.CHANGED) {	                var tiltDegrees = -90 * ty / this.worldWindow.canvas.clientHeight;	                this.tilt = this.beginTilt + tiltDegrees;	                this.applyLimits();	                this.worldWindow.redraw();	            }	        };	        LookAtNavigator.prototype.handleWheelEvent = function (event) {	            var normalizedDelta;	            if (event.deltaMode == WheelEvent.DOM_DELTA_PIXEL) {	                normalizedDelta = event.deltaY;	            } else if (event.deltaMode == WheelEvent.DOM_DELTA_LINE) {	                normalizedDelta = event.deltaY * 40;	            } else if (event.deltaMode == WheelEvent.DOM_DELTA_PAGE) {	                normalizedDelta = event.deltaY * 400;	            }	            var scale = 1 + (normalizedDelta / 1000);	            this.range *= scale;	            this.applyLimits();	            this.worldWindow.redraw();	        };	        LookAtNavigator.prototype.applyLimits = function () {	            this.lookAtLocation.latitude = WWMath.clamp(this.lookAtLocation.latitude, -90, 90);	            this.lookAtLocation.longitude = Angle.normalizedDegreesLongitude(this.lookAtLocation.longitude);	            this.range = WWMath.clamp(this.range, 1, Number.MAX_VALUE);	            this.heading = Angle.normalizedDegrees(this.heading);	            this.tilt = WWMath.clamp(this.tilt, 0, 90);	            this.roll = Angle.normalizedDegrees(this.roll);	            if (this.worldWindow.globe.is2D() && this.enable2DLimits) {	                var maxRange = 2 * Math.PI * this.worldWindow.globe.equatorialRadius;	                this.range = WWMath.clamp(this.range, 1, maxRange);	                this.tilt = 0;	            }	        };	        return LookAtNavigator;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function (GestureRecognizer) {	        "use strict";	        var PanRecognizer = function (target, callback) {	            GestureRecognizer.call(this, target, callback);	            this.minNumberOfTouches = 1;	            this.maxNumberOfTouches = Number.MAX_VALUE;	            this.interpretDistance = 20;	        };	        PanRecognizer.prototype = Object.create(GestureRecognizer.prototype);	        PanRecognizer.prototype.mouseDown = function (event) {	            if (this.state == WorldWind.POSSIBLE) {	                this.state = WorldWind.FAILED; 	            }	        };	        PanRecognizer.prototype.touchMove = function (touch) {	            if (this.state == WorldWind.POSSIBLE) {	                if (this.shouldInterpret()) {	                    if (this.shouldRecognize()) {	                        this.state = WorldWind.BEGAN;	                    } else {	                        this.state = WorldWind.FAILED;	                    }	                }	            } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {	                this.state = WorldWind.CHANGED;	            }	        };	        PanRecognizer.prototype.touchEnd = function (touch) {	            if (this.touchCount == 0) { 	                if (this.state == WorldWind.POSSIBLE) {	                    this.state = WorldWind.FAILED;	                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {	                    this.state = WorldWind.ENDED;	                }	            }	        };	        PanRecognizer.prototype.touchCancel = function (touch) {	            if (this.touchCount == 0) { 	                if (this.state == WorldWind.POSSIBLE) {	                    this.state = WorldWind.FAILED;	                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {	                    this.state = WorldWind.CANCELLED;	                }	            }	        };	        PanRecognizer.prototype.prepareToRecognize = function () {	            this.translationX = 0;	            this.translationY = 0;	        };	        PanRecognizer.prototype.shouldInterpret = function () {	            var dx = this.translationX,	                dy = this.translationY,	                distance = Math.sqrt(dx * dx + dy * dy);	            return distance > this.interpretDistance; 	        };	        PanRecognizer.prototype.shouldRecognize = function () {	            var touchCount = this.touchCount;	            return touchCount != 0	                && touchCount >= this.minNumberOfTouches	                && touchCount <= this.maxNumberOfTouches	        };	        return PanRecognizer;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(9),	        __webpack_require__(10)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Logger,	              Touch) {	        "use strict";	        var GestureRecognizer = function (target, callback) {	            this.target = target;	            this.enabled = true;	            this._state = WorldWind.POSSIBLE;	            this._nextState = null;	            this._clientX = 0;	            this._clientY = 0;	            this._clientStartX = 0;	            this._clientStartY = 0;	            this._translationX = 0;	            this._translationY = 0;	            this._translationWeight = 0.4;	            this._mouseButtonMask = 0;	            this._touches = [];	            this._touchCentroidShiftX = 0;	            this._touchCentroidShiftY = 0;	            this._gestureCallbacks = [];	            this._canRecognizeWith = [];	            this._requiresFailureOf = [];	            this._requiredToFailBy = [];	            if (callback) {	                this._gestureCallbacks.push(callback);	            }	            GestureRecognizer.allRecognizers.push(this);	            var thisRecognizer = this;	            function eventListener(event) {	                thisRecognizer.handleEvent(event);	            }	            if (window.PointerEvent) {	                target.addEventListener("pointerdown", eventListener, false);	                window.addEventListener("pointermove", eventListener, false); 	                window.addEventListener("pointercancel", eventListener, false); 	                window.addEventListener("pointerup", eventListener, false); 	            } else {	                target.addEventListener("mousedown", eventListener, false);	                window.addEventListener("mousemove", eventListener, false); 	                window.addEventListener("mouseup", eventListener, false); 	                target.addEventListener("touchstart", eventListener, false);	                target.addEventListener("touchmove", eventListener, false);	                target.addEventListener("touchend", eventListener, false);	                target.addEventListener("touchcancel", eventListener, false);	            }	        };	        GestureRecognizer.allRecognizers = [];	        Object.defineProperties(GestureRecognizer.prototype, {	            state: {	                get: function () {	                    return this._state;	                },	                set: function (value) {	                    this.transitionToState(value);	                }	            },	            clientX: {	                get: function () {	                    return this._clientX;	                },	                set: function (value) {	                    this._clientX = value;	                }	            },	            clientY: {	                get: function () {	                    return this._clientY;	                },	                set: function (value) {	                    this._clientY = value;	                }	            },	            translationX: {	                get: function () {	                    return this._translationX;	                },	                set: function (value) {	                    this._translationX = value;	                    this._clientStartX = this._clientX;	                    this._touchCentroidShiftX = 0;	                }	            },	            translationY: {	                get: function () {	                    return this._translationY;	                },	                set: function (value) {	                    this._translationY = value;	                    this._clientStartY = this._clientY;	                    this._touchCentroidShiftY = 0;	                }	            },	            mouseButtonMask: {	                get: function () {	                    return this._mouseButtonMask;	                }	            },	            touchCount: {	                get: function () {	                    return this._touches.length;	                }	            },	            gestureCallbacks: {	                get: function () {	                    return this._gestureCallbacks;	                }	            }	        });	        GestureRecognizer.prototype.touch = function (index) {	            return this._touches[index];	        };	        GestureRecognizer.prototype.recognizeSimultaneouslyWith = function (recognizer) {	            var index = this._canRecognizeWith.indexOf(recognizer);	            if (index == -1) {	                this._canRecognizeWith.push(recognizer);	                recognizer._canRecognizeWith.push(this);	            }	        };	        GestureRecognizer.prototype.canRecognizeSimultaneouslyWith = function (recognizer) {	            var index = this._canRecognizeWith.indexOf(recognizer);	            return index != -1;	        };	        GestureRecognizer.prototype.requireRecognizerToFail = function (recognizer) {	            var index = this._requiresFailureOf.indexOf(recognizer);	            if (index == -1) {	                this._requiresFailureOf.push(recognizer);	                recognizer._requiredToFailBy.push(this);	            }	        };	        GestureRecognizer.prototype.requiresRecognizerToFail = function (recognizer) {	            var index = this._requiresFailureOf.indexOf(recognizer);	            return index != -1;	        };	        GestureRecognizer.prototype.requiredToFailByRecognizer = function (recognizer) {	            var index = this._requiredToFailBy.indexOf(recognizer);	            return index != -1;	        };	        GestureRecognizer.prototype.reset = function () {	            this._state = WorldWind.POSSIBLE;	            this._nextState = null;	            this._clientX = 0;	            this._clientY = 0;	            this._clientStartX = 0;	            this._clientStartY = 0;	            this._translationX = 0;	            this._translationY = 0;	            this._mouseButtonMask = 0;	            this._touches = [];	            this._touchCentroidShiftX = 0;	            this._touchCentroidShiftY = 0;	        };	        GestureRecognizer.prototype.prepareToRecognize = function () {	        };	        GestureRecognizer.prototype.mouseDown = function (event) {	        };	        GestureRecognizer.prototype.mouseMove = function (event) {	        };	        GestureRecognizer.prototype.mouseUp = function (event) {	        };	        GestureRecognizer.prototype.touchStart = function (touch) {	        };	        GestureRecognizer.prototype.touchMove = function (touch) {	        };	        GestureRecognizer.prototype.touchCancel = function (touch) {	        };	        GestureRecognizer.prototype.touchEnd = function (touch) {	        };	        GestureRecognizer.prototype.transitionToState = function (newState) {	            this._nextState = null; 	            if (newState == WorldWind.FAILED) {	                this._state = newState;	                this.updateRecognizersWaitingForFailure();	                this.resetIfEventsEnded();	            } else if (newState == WorldWind.RECOGNIZED) {	                this.tryToRecognize(newState); 	                if (this._state == newState) {	                    this.prepareToRecognize();	                    this.callGestureCallbacks();	                    this.resetIfEventsEnded();	                }	            } else if (newState == WorldWind.BEGAN) {	                this.tryToRecognize(newState); 	                if (this._state == newState) {	                    this.prepareToRecognize();	                    this.callGestureCallbacks();	                }	            } else if (newState == WorldWind.CHANGED) {	                this._state = newState;	                this.callGestureCallbacks();	            } else if (newState == WorldWind.CANCELLED) {	                this._state = newState;	                this.callGestureCallbacks();	                this.resetIfEventsEnded();	            } else if (newState == WorldWind.ENDED) {	                this._state = newState;	                this.callGestureCallbacks();	                this.resetIfEventsEnded();	            }	        };	        GestureRecognizer.prototype.updateRecognizersWaitingForFailure = function () {	            for (var i = 0, len = this._requiredToFailBy.length; i < len; i++) {	                var recognizer = this._requiredToFailBy[i];	                if (recognizer._nextState != null) {	                    recognizer.transitionToState(recognizer._nextState);	                }	            }	        };	        GestureRecognizer.prototype.tryToRecognize = function (newState) {	            if (GestureRecognizer.allRecognizers.some(this.canBePreventedByRecognizer, this)) {	                this.transitionToState(WorldWind.FAILED);	                return;	            }	            if (GestureRecognizer.allRecognizers.some(this.isWaitingForRecognizerToFail, this)) {	                this._nextState = newState;	                return;	            }	            var prevented = GestureRecognizer.allRecognizers.filter(this.canPreventRecognizer, this);	            for (var i = 0, len = prevented.length; i < len; i++) {	                prevented[i].transitionToState(WorldWind.FAILED);	            }	            this._state = newState;	        };	        GestureRecognizer.prototype.canPreventRecognizer = function (that) {	            return this != that && this.target == that.target && that.state == WorldWind.POSSIBLE &&	                (this.requiredToFailByRecognizer(that) || !this.canRecognizeSimultaneouslyWith(that));	        };	        GestureRecognizer.prototype.canBePreventedByRecognizer = function (that) {	            return this != that && this.target == that.target && that.state == WorldWind.RECOGNIZED &&	                (this.requiresRecognizerToFail(that) || !this.canRecognizeSimultaneouslyWith(that));	        };	        GestureRecognizer.prototype.isWaitingForRecognizerToFail = function (that) {	            return this != that && this.target == that.target && that.state == WorldWind.POSSIBLE &&	                this.requiresRecognizerToFail(that);	        };	        GestureRecognizer.prototype.callGestureCallbacks = function () {	            for (var i = 0, len = this._gestureCallbacks.length; i < len; i++) {	                this._gestureCallbacks[i](this);	            }	        };	        GestureRecognizer.prototype.handleEvent = function (event) {	            if (!this.enabled) {	                return;	            }	            if (event.defaultPrevented && this.state == WorldWind.POSSIBLE) {	                return; 	            }	            var i, len;	            try {	                if (event.type == "mousedown") {	                    this.handleMouseDown(event);	                } else if (event.type == "mousemove") {	                    this.handleMouseMove(event);	                } else if (event.type == "mouseup") {	                    this.handleMouseUp(event);	                } else if (event.type == "touchstart") {	                    for (i = 0, len = event.changedTouches.length; i < len; i++) {	                        this.handleTouchStart(event.changedTouches.item(i));	                    }	                } else if (event.type == "touchmove") {	                    for (i = 0, len = event.changedTouches.length; i < len; i++) {	                        this.handleTouchMove(event.changedTouches.item(i));	                    }	                } else if (event.type == "touchcancel") {	                    for (i = 0, len = event.changedTouches.length; i < len; i++) {	                        this.handleTouchCancel(event.changedTouches.item(i));	                    }	                } else if (event.type == "touchend") {	                    for (i = 0, len = event.changedTouches.length; i < len; i++) {	                        this.handleTouchEnd(event.changedTouches.item(i));	                    }	                } else if (event.type == "pointerdown" && event.pointerType == "mouse") {	                    this.handleMouseDown(event);	                } else if (event.type == "pointermove" && event.pointerType == "mouse") {	                    this.handleMouseMove(event);	                } else if (event.type == "pointercancel" && event.pointerType == "mouse") {	                } else if (event.type == "pointerup" && event.pointerType == "mouse") {	                    this.handleMouseUp(event);	                } else if (event.type == "pointerdown" && event.pointerType == "touch") {	                    this.handleTouchStart(event);	                } else if (event.type == "pointermove" && event.pointerType == "touch") {	                    this.handleTouchMove(event);	                } else if (event.type == "pointercancel" && event.pointerType == "touch") {	                    this.handleTouchCancel(event);	                } else if (event.type == "pointerup" && event.pointerType == "touch") {	                    this.handleTouchEnd(event);	                } else {	                    Logger.logMessage(Logger.LEVEL_INFO, "GestureRecognizer", "handleEvent",	                        "Unrecognized event type: " + event.type);	                }	            } catch (e) {	                Logger.logMessage(Logger.LEVEL_SEVERE, "GestureRecognizer", "handleEvent",	                    "Error handling event.\n" + e.toString());	            }	        };	        GestureRecognizer.prototype.handleMouseDown = function (event) {	            if (event.type == "mousedown" && this._touches.length > 0) {	                return; 	            }	            var buttonBit = (1 << event.button);	            if (buttonBit & this._mouseButtonMask != 0) {	                return; 	            }	            if (this._mouseButtonMask == 0) { 	                this._clientX = event.clientX;	                this._clientY = event.clientY;	                this._clientStartX = event.clientX;	                this._clientStartY = event.clientY;	                this._translationX = 0;	                this._translationY = 0;	            }	            this._mouseButtonMask |= buttonBit;	            this.mouseDown(event);	        };	        GestureRecognizer.prototype.handleMouseMove = function (event) {	            if (this._mouseButtonMask == 0) {	                return; 	            }	            if (this._clientX == event.clientX && this._clientY == event._clientY) {	                return; 	            }	            var dx = event.clientX - this._clientStartX,	                dy = event.clientY - this._clientStartY,	                w = this._translationWeight;	            this._clientX = event.clientX;	            this._clientY = event.clientY;	            this._translationX = this._translationX * (1 - w) + dx * w;	            this._translationY = this._translationY * (1 - w) + dy * w;	            this.mouseMove(event);	        };	        GestureRecognizer.prototype.handleMouseUp = function (event) {	            var buttonBit = (1 << event.button);	            if (buttonBit & this._mouseButtonMask == 0) {	                return; 	            }	            this._mouseButtonMask &= ~buttonBit;	            this.mouseUp(event);	            if (this._mouseButtonMask == 0) {	                this.resetIfEventsEnded(); 	            }	        };	        GestureRecognizer.prototype.handleTouchStart = function (event) {	            var touch = new Touch(event.identifier || event.pointerId, event.clientX, event.clientY); 	            this._touches.push(touch);	            if (this._touches.length == 1) { 	                this._clientX = event.clientX;	                this._clientY = event.clientY;	                this._clientStartX = event.clientX;	                this._clientStartY = event.clientY;	                this._translationX = 0;	                this._translationY = 0;	                this._touchCentroidShiftX = 0;	                this._touchCentroidShiftY = 0;	            } else {	                this.touchesAddedOrRemoved();	            }	            this.touchStart(touch);	        };	        GestureRecognizer.prototype.handleTouchMove = function (event) {	            var index = this.indexOfTouchWithId(event.identifier || event.pointerId); 	            if (index == -1) {	                return; 	            }	            var touch = this._touches[index];	            if (touch.clientX == event.clientX && touch.clientY == event.clientY) {	                return; 	            }	            touch.clientX = event.clientX;	            touch.clientY = event.clientY;	            var centroid = this.touchCentroid(),	                dx = centroid.clientX - this._clientStartX + this._touchCentroidShiftX,	                dy = centroid.clientY - this._clientStartY + this._touchCentroidShiftY,	                w = this._translationWeight;	            this._clientX = centroid.clientX;	            this._clientY = centroid.clientY;	            this._translationX = this._translationX * (1 - w) + dx * w;	            this._translationY = this._translationY * (1 - w) + dy * w;	            this.touchMove(touch);	        };	        GestureRecognizer.prototype.handleTouchCancel = function (event) {	            var index = this.indexOfTouchWithId(event.identifier || event.pointerId); 	            if (index == -1) {	                return; 	            }	            var touch = this._touches[index];	            this._touches.splice(index, 1);	            this.touchesAddedOrRemoved();	            this.touchCancel(touch);	            this.resetIfEventsEnded();	        };	        GestureRecognizer.prototype.handleTouchEnd = function (event) {	            var index = this.indexOfTouchWithId(event.identifier || event.pointerId); 	            if (index == -1) {	                return; 	            }	            var touch = this._touches[index];	            this._touches.splice(index, 1);	            this.touchesAddedOrRemoved();	            this.touchEnd(touch);	            this.resetIfEventsEnded();	        };	        GestureRecognizer.prototype.resetIfEventsEnded = function () {	            if (this._state != WorldWind.POSSIBLE && this._mouseButtonMask == 0 && this._touches.length == 0) {	                this.reset();	            }	        };	        GestureRecognizer.prototype.touchesAddedOrRemoved = function () {	            this._touchCentroidShiftX += this._clientX;	            this._touchCentroidShiftY += this._clientY;	            var centroid = this.touchCentroid();	            this._clientX = centroid.clientX;	            this._clientY = centroid.clientY;	            this._touchCentroidShiftX -= this._clientX;	            this._touchCentroidShiftY -= this._clientY;	        };	        GestureRecognizer.prototype.touchCentroid = function () {	            var x = 0,	                y = 0;	            for (var i = 0, len = this._touches.length; i < len; i++) {	                var touch = this._touches[i];	                x += touch.clientX / len;	                y += touch.clientY / len;	            }	            return {clientX: x, clientY: y};	        };	        GestureRecognizer.prototype.indexOfTouchWithId = function (identifier) {	            for (var i = 0, len = this._touches.length; i < len; i++) {	                if (this._touches[i].identifier == identifier) {	                    return i;	                }	            }	            return -1;	        };	        return GestureRecognizer;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbstractError) {	        "use strict";	        var ArgumentError = function (message) {	            AbstractError.call(this, "ArgumentError", message);	            var stack;	            try {	                throw new Error();	            } catch (e) {	                stack = e.stack;	            }	            this.stack = stack;	        };	        ArgumentError.prototype = Object.create(AbstractError.prototype);	        return ArgumentError;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {	    "use strict";	    var AbstractError = function (name, message) {	        this.name = name;	        this.message = message;	    };	    AbstractError.prototype.toString = function () {	        var str = this.name + ': ' + this.message;	        if (this.stack) {	            str += '\n' + this.stack.toString();	        }	        return str;	    };	    return AbstractError;	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {	    "use strict";	    var Logger = {	        LEVEL_NONE: 0,	        LEVEL_SEVERE: 1,	        LEVEL_WARNING: 2,	        LEVEL_INFO: 3,	        setLoggingLevel: function (level) {	            loggingLevel = level;	        },	        getLoggingLevel: function () {	            return loggingLevel;	        },	        log: function (level, message) {	            if (message && level > 0 && level <= loggingLevel) {	                if (level === Logger.LEVEL_SEVERE) {	                    console.error(message);	                } else if (level === Logger.LEVEL_WARNING) {	                    console.warn(message);	                } else if (level === Logger.LEVEL_INFO) {	                    console.info(message);	                } else {	                    console.log(message);	                }	            }	        },	        makeMessage: function (className, functionName, message) {	            var msg = this.messageTable[message] ? this.messageTable[message] : message;	            return className + "." + functionName + ": " + msg;	        },	        logMessage: function (level, className, functionName, message) {	            var msg = this.makeMessage(className, functionName, message);	            this.log(level, msg);	            return msg;	        },	        messageTable: { 	            abstractInvocation: "The function called is abstract and must be overridden in a subclass.",	            indexOutOfRange: "The specified index is out of range.",	            invalidHeight: "The specified height is zero or negative.",	            invalidWidth: "The specified width is zero or negative.",	            invalidSize: "The specified size is zero or negative.",	            missingAltitudeMode: "The specified altitude mode is null or undefined.",	            missingAttributeName: "The specified DBase attribute file name is null or undefined.",	            missingArray: "The specified array is null, undefined or of insufficient length.",	            missingBoundaries: "The specified boundaries array is null or undefined.",	            missingBuffer: "The specified buffer descriptor is null or undefined.",	            missingColor: "The specified color is null or undefined.",	            missingDc: "The specified draw context is null or undefined.",	            missingDomElement: "The specified DOM element is null or undefined.",	            missingEntry: "The specified entry is null or undefined.",	            missingFont: "The specified font is null or undefined.",	            missingFrustum: "The specified frustum is null or undefined.",	            missingFunction: "The specified function is null or undefined.",	            missingGlContext: "The specified WebGL rendering context is null or undefined.",	            missingGlobe: "The specified globe is null or undefined.",	            missingImage: "The specified image is null or undefined.",	            missingIndices: "The specified indices array is null or undefined.",	            missingKey: "The specified key is null or undefined.",	            missingLevel: "The specified level is null or undefined.",	            missingLine: "The specified line is null or undefined.",	            missingList: "The specified list is null or undefined.",	            missingListener: "The specified listener is null or undefined",	            missingLocation: "The specified location is null or undefined.",	            missingMatrix: "The specified matrix is null or undefined.",	            missingNavigatorState: "The specified navigator state is null or undefined.",	            missingOffset: "The specified offset is null or undefined.",	            missingPath: "The specified path is null or undefined.",	            missingPlacename: "The specified place name is null or undefined.",	            missingPlane: "The specified plane is null or undefined.",	            missingPoint: "The specified point is null or undefined.",	            missingPoints: "The specified points array is null or undefined.",	            missingPosition: "The specified position is null or undefined.",	            missingPositions: "The specified positions array is null or undefined.",	            missingProgram: "The specified program is null or undefined.",	            missingProjection: "The specified projection is null or undefined.",	            missingRectangle: "The specified rectangle is null or undefined.",	            missingRenderable: "The specified renderable is null or undefined.",	            missingResource: "The specified resource is null or undefined.",	            missingResult: "The specified result variable is null or undefined.",	            missingResults: "The specified results array is null or undefined.",	            missingSector: "The specified sector is null or undefined.",	            missingShapeType: "The specified shape type is null or undefined.",	            missingSize: "The specified size is null or undefined.",	            missingText: "The specified text is null or undefined.",	            missingTexture: "The specified texture is null or undefined.",	            missingTile: "The specified tile is null or undefined.",	            missingType: "The specified type is null or undefined.",	            missingUrl: "The specified URL is null or undefined",	            missingVector: "The specified vector is null or undefined.",	            missingVertex: "The specified vertex is null or undefined.",	            missingViewport: "The specified viewport is null or undefined.",	            missingWorldWindow: "The specified World Window is null or undefined.",	            notYetImplemented: "This function is not yet implemented"	        }	    };	    var loggingLevel = 1; 	    return Logger;	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {	        "use strict";	        var Touch = function (identifier, clientX, clientY) {	            this.identifier = identifier;	            this._clientX = clientX;	            this._clientY = clientY;	            this._clientStartX = clientX;	            this._clientStartY = clientY;	        };	        Object.defineProperties(Touch.prototype, {	            clientX: {	                get: function () {	                    return this._clientX;	                },	                set: function (value) {	                    this._clientX = value;	                }	            },	            clientY: {	                get: function () {	                    return this._clientY;	                },	                set: function (value) {	                    this._clientY = value;	                }	            },	            translationX: {	                get: function () {	                    return this._clientX - this._clientStartX;	                },	                set: function (value) {	                    this._clientStartX = this._clientX - value;	                }	            },	            translationY: {	                get: function () {	                    return this._clientY - this._clientStartY;	                },	                set: function (value) {	                    this._clientStartY = this._clientY - value;	                }	            }	        });	        return Touch;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {	    "use strict";	    var Angle = {	        DEGREES_TO_RADIANS: Math.PI / 180.0,	        RADIANS_TO_DEGREES: 180.0 / Math.PI,	        TWO_PI: 2 * Math.PI,	        HALF_PI: Math.PI / 2,	        normalizedDegrees: function (degrees) {	            var angle = degrees % 360;	            return angle > 180 ? angle - 360 : angle < -180 ? 360 + angle : angle;	        },	        normalizedDegreesLatitude: function (degrees) {	            var lat = degrees % 180;	            return lat > 90 ? 180 - lat : lat < -90 ? -180 - lat : lat;	        },	        normalizedDegreesLongitude: function (degrees) {	            var lon = degrees % 360;	            return lon > 180 ? lon - 360 : lon < -180 ? 360 + lon : lon;	        },	        normalizedRadians: function (radians) {	            var angle = radians % this.TWO_PI;	            return angle > Math.PI ? angle - this.TWO_PI : angle < -Math.PI ? this.TWO_PI + angle : angle;	        },	        normalizedRadiansLatitude: function (radians) {	            var lat = radians % Math.PI;	            return lat > this.HALF_PI ? Math.PI - lat : lat < -this.HALF_PI ? -Math.PI - lat : lat;	        },	        normalizedRadiansLongitude: function (radians) {	            var lon = radians % this.TWO_PI;	            return lon > Math.PI ? lon - this.TWO_PI : lon < -Math.PI ? this.TWO_PI + lon : lon;	        },	        isValidLatitude: function (degrees) {	            return degrees >= -90 && degrees <= 90;	        },	        isValidLongitude: function (degrees) {	            return degrees >= -180 && degrees <= 180;	        },	        toString: function (degrees) {	            return degrees.toString() + '\u00B0';	        },	        toDecimalDegreesString: function (degrees) {	            return degrees.toString() + '\u00B0';	        },	        toDMSString: function (degrees) {	            var sign,	                temp,	                d,	                m,	                s;	            sign = degrees < 0 ? -1 : 1;	            temp = sign * degrees;	            d = Math.floor(temp);	            temp = (temp - d) * 60;	            m = Math.floor(temp);	            temp = (temp - m) * 60;	            s = Math.round(temp);	            if (s == 60) {	                m++;	                s = 0;	            }	            if (m == 60) {	                d++;	                m = 0;	            }	            return (sign == -1 ? "-" : "") + d + "\u00B0" + " " + m + "\u2019" + " " + s + "\u201D";	        },	        toDMString: function (degrees) {	            var sign,	                temp,	                d,	                m,	                s,	                mf;	            sign = degrees < 0 ? -1 : 1;	            temp = sign * degrees;	            d = Math.floor(temp);	            temp = (temp - d) * 60;	            m = Math.floor(temp);	            temp = (temp - m) * 60;	            s = Math.round(temp);	            if (s == 60) {	                m++;	                s = 0;	            }	            if (m == 60) {	                d++;	                m = 0;	            }	            mf = s == 0 ? m : m + s / 60;	            return (sign == -1 ? "-" : "") + d + "\u00B0" + " " + mf + "\u2019";	        }	    };	    return Angle;	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(13),	        __webpack_require__(14),	        __webpack_require__(9)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Matrix,	              Plane,	              Logger) {	        "use strict";	        var Frustum = function (left, right, bottom, top, near, far) {	            this._left = left;	            this._right = right;	            this._bottom = bottom;	            this._top = top;	            this._near = near;	            this._far = far;	            this._planes = [this._left, this._right, this._top, this._bottom, this._near, this._far];	        };	        Object.defineProperties(Frustum.prototype, {	            left: {	                get: function() {	                    return this._left;	                }	            },	            right: {	                get: function() {	                    return this._right;	                }	            },	            bottom: {	                get: function() {	                    return this._bottom;	                }	            },	            top: {	                get: function() {	                    return this._top;	                }	            },	            near: {	                get: function() {	                    return this._near;	                }	            },	            far: {	                get: function() {	                    return this._far;	                }	            }	        });	        Frustum.prototype.transformByMatrix = function (matrix) {	            this._left.transformByMatrix(matrix);	            this._right.transformByMatrix(matrix);	            this._bottom.transformByMatrix(matrix);	            this._top.transformByMatrix(matrix);	            this._near.transformByMatrix(matrix);	            this._far.transformByMatrix(matrix);	            return this;	        };	        Frustum.prototype.normalize = function () {	            this._left.normalize();	            this._right.normalize();	            this._bottom.normalize();	            this._top.normalize();	            this._near.normalize();	            this._far.normalize();	            return this;	        };	        Frustum.unitFrustum = function () {	            return new Frustum(	                new Plane(1, 0, 0, 1), 	                new Plane(-1, 0, 0, 1), 	                new Plane(0, 1, 1, 1), 	                new Plane(0, -1, 0, 1), 	                new Plane(0, 0, -1, 1), 	                new Plane(0, 0, 1, 1) 	            );	        };	        Frustum.fromProjectionMatrix = function (matrix) {	            var x, y, z, w, d, left, right, top, bottom, near, far;	            x = matrix[12] + matrix[0];	            y = matrix[13] + matrix[1];	            z = matrix[14] + matrix[2];	            w = matrix[15] + matrix[3];	            d = Math.sqrt(x * x + y * y + z * z); 	            left = new Plane(x / d, y / d, z / d, w / d);	            x = matrix[12] - matrix[0];	            y = matrix[13] - matrix[1];	            z = matrix[14] - matrix[2];	            w = matrix[15] - matrix[3];	            d = Math.sqrt(x * x + y * y + z * z); 	            right = new Plane(x / d, y / d, z / d, w / d);	            x = matrix[12] + matrix[4];	            y = matrix[13] + matrix[5];	            z = matrix[14] + matrix[6];	            w = matrix[15] + matrix[7];	            d = Math.sqrt(x * x + y * y + z * z); 	            bottom = new Plane(x / d, y / d, z / d, w / d);	            x = matrix[12] - matrix[4];	            y = matrix[13] - matrix[5];	            z = matrix[14] - matrix[6];	            w = matrix[15] - matrix[7];	            d = Math.sqrt(x * x + y * y + z * z); 	            top = new Plane(x / d, y / d, z / d, w / d);	            x = matrix[12] + matrix[8];	            y = matrix[13] + matrix[9];	            z = matrix[14] + matrix[10];	            w = matrix[15] + matrix[11];	            d = Math.sqrt(x * x + y * y + z * z); 	            near = new Plane(x / d, y / d, z / d, w / d);	            x = matrix[12] - matrix[8];	            y = matrix[13] - matrix[9];	            z = matrix[14] - matrix[10];	            w = matrix[15] - matrix[11];	            d = Math.sqrt(x * x + y * y + z * z); 	            far = new Plane(x / d, y / d, z / d, w / d);	            return new Frustum(left, right, bottom, top, near, far);	        };	        Frustum.prototype.containsPoint = function (point) {	            if (this._far.dot(point) <= 0)	                return false;	            if (this._left.dot(point) <= 0)	                return false;	            if (this._right.dot(point) <= 0)	                return false;	            if (this._top.dot(point) <= 0)	                return false;	            if (this._bottom.dot(point) <= 0)	                return false;	            if (this._near.dot(point) <= 0)	                return false;	            return true;	        };	        Frustum.prototype.intersectsSegment = function (pointA, pointB) {	            if (this.containsPoint(pointA) || this.containsPoint(pointB))	                return true;	            if (pointA.equals(pointB))	                return false;	            for (var i = 0, len = this._planes.length; i < len; i++) {	                if (this._planes[i].onSameSide(pointA, pointB) < 0)	                    return false;	                if (this._planes[i].clip(pointA, pointB) != null)	                    return true;	            }	            return false; 	        };	        return Frustum;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(11),	        __webpack_require__(7),	        __webpack_require__(9),	        __webpack_require__(14),	        __webpack_require__(17),	        __webpack_require__(20),	        __webpack_require__(21),	        __webpack_require__(16),	        __webpack_require__(19)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,	              ArgumentError,	              Logger,	              Plane,	              Position,	              Rectangle,	              Texture,	              Vec3,	              WWMath) {	        "use strict";	        var Matrix = function (m11, m12, m13, m14,	                               m21, m22, m23, m24,	                               m31, m32, m33, m34,	                               m41, m42, m43, m44) {	            this[0] = m11;	            this[1] = m12;	            this[2] = m13;	            this[3] = m14;	            this[4] = m21;	            this[5] = m22;	            this[6] = m23;	            this[7] = m24;	            this[8] = m31;	            this[9] = m32;	            this[10] = m33;	            this[11] = m34;	            this[12] = m41;	            this[13] = m42;	            this[14] = m43;	            this[15] = m44;	        };	        Matrix.prototype = new Float64Array(16);	        Matrix.fromIdentity = function () {	            return new Matrix(	                1, 0, 0, 0,	                0, 1, 0, 0,	                0, 0, 1, 0,	                0, 0, 0, 1	            );	        };	        Matrix.principalAxesFromPoints = function (points, axis1, axis2, axis3) {	            var covariance = Matrix.fromIdentity();	            covariance.setToCovarianceOfPoints(points);	            covariance.eigensystemFromSymmetricMatrix(axis1, axis2, axis3);	            axis1.normalize();	            axis2.normalize();	            axis3.normalize();	        };	        Matrix.prototype.set = function (m11, m12, m13, m14,	                                         m21, m22, m23, m24,	                                         m31, m32, m33, m34,	                                         m41, m42, m43, m44) {	            this[0] = m11;	            this[1] = m12;	            this[2] = m13;	            this[3] = m14;	            this[4] = m21;	            this[5] = m22;	            this[6] = m23;	            this[7] = m24;	            this[8] = m31;	            this[9] = m32;	            this[10] = m33;	            this[11] = m34;	            this[12] = m41;	            this[13] = m42;	            this[14] = m43;	            this[15] = m44;	            return this;	        };	        Matrix.prototype.setToIdentity = function () {	            this[0] = 1;	            this[1] = 0;	            this[2] = 0;	            this[3] = 0;	            this[4] = 0;	            this[5] = 1;	            this[6] = 0;	            this[7] = 0;	            this[8] = 0;	            this[9] = 0;	            this[10] = 1;	            this[11] = 0;	            this[12] = 0;	            this[13] = 0;	            this[14] = 0;	            this[15] = 1;	        };	        Matrix.prototype.copy = function (matrix) {	            this[0] = matrix[0];	            this[1] = matrix[1];	            this[2] = matrix[2];	            this[3] = matrix[3];	            this[4] = matrix[4];	            this[5] = matrix[5];	            this[6] = matrix[6];	            this[7] = matrix[7];	            this[8] = matrix[8];	            this[9] = matrix[9];	            this[10] = matrix[10];	            this[11] = matrix[11];	            this[12] = matrix[12];	            this[13] = matrix[13];	            this[14] = matrix[14];	            this[15] = matrix[15];	        };	        Matrix.prototype.equals = function (matrix) {	            return matrix	                && this[0] == matrix[0]	                && this[1] == matrix[1]	                && this[2] == matrix[2]	                && this[3] == matrix[3]	                && this[4] == matrix[4]	                && this[5] == matrix[5]	                && this[6] == matrix[6]	                && this[7] == matrix[7]	                && this[8] == matrix[8]	                && this[9] == matrix[9]	                && this[10] == matrix[10]	                && this[11] == matrix[11]	                && this[12] == matrix[12]	                && this[13] == matrix[13]	                && this[14] == matrix[14]	                && this[15] == matrix[15];	        };	        Matrix.prototype.columnMajorComponents = function (result) {	            result[0] = this[0];	            result[1] = this[4];	            result[2] = this[8];	            result[3] = this[12];	            result[4] = this[1];	            result[5] = this[5];	            result[6] = this[9];	            result[7] = this[13];	            result[8] = this[2];	            result[9] = this[6];	            result[10] = this[10];	            result[11] = this[14];	            result[12] = this[3];	            result[13] = this[7];	            result[14] = this[11];	            result[15] = this[15];	            return result;	        };	        Matrix.prototype.setToTranslation = function (x, y, z) {	            this[0] = 1;	            this[1] = 0;	            this[2] = 0;	            this[3] = x;	            this[4] = 0;	            this[5] = 1;	            this[6] = 0;	            this[7] = y;	            this[8] = 0;	            this[9] = 0;	            this[10] = 1;	            this[11] = z;	            this[12] = 0;	            this[13] = 0;	            this[14] = 0;	            this[15] = 1;	            return this;	        };	        Matrix.prototype.setTranslation = function (x, y, z) {	            this[3] = x;	            this[7] = y;	            this[11] = z;	            return this;	        };	        Matrix.prototype.setToScale = function (xScale, yScale, zScale) {	            this[0] = xScale;	            this[1] = 0;	            this[2] = 0;	            this[3] = 0;	            this[4] = 0;	            this[5] = yScale;	            this[6] = 0;	            this[7] = 0;	            this[8] = 0;	            this[9] = 0;	            this[10] = zScale;	            this[11] = 0;	            this[12] = 0;	            this[13] = 0;	            this[14] = 0;	            this[15] = 1;	            return this;	        };	        Matrix.prototype.setScale = function (xScale, yScale, zScale) {	            this[0] = xScale;	            this[5] = yScale;	            this[10] = zScale;	            return this;	        };	        Matrix.prototype.setToTransposeOfMatrix = function (matrix) {	            this[0] = matrix[0];	            this[1] = matrix[4];	            this[2] = matrix[8];	            this[3] = matrix[12];	            this[4] = matrix[1];	            this[5] = matrix[5];	            this[6] = matrix[9];	            this[7] = matrix[13];	            this[8] = matrix[2];	            this[9] = matrix[6];	            this[10] = matrix[10];	            this[11] = matrix[14];	            this[12] = matrix[3];	            this[13] = matrix[7];	            this[14] = matrix[11];	            this[15] = matrix[15];	            return this;	        };	        Matrix.prototype.setToMultiply = function (matrixA, matrixB) {	            var ma = matrixA,	                mb = matrixB;	            this[0] = ma[0] * mb[0] + ma[1] * mb[4] + ma[2] * mb[8] + ma[3] * mb[12];	            this[1] = ma[0] * mb[1] + ma[1] * mb[5] + ma[2] * mb[9] + ma[3] * mb[13];	            this[2] = ma[0] * mb[2] + ma[1] * mb[6] + ma[2] * mb[10] + ma[3] * mb[14];	            this[3] = ma[0] * mb[3] + ma[1] * mb[7] + ma[2] * mb[11] + ma[3] * mb[15];	            this[4] = ma[4] * mb[0] + ma[5] * mb[4] + ma[6] * mb[8] + ma[7] * mb[12];	            this[5] = ma[4] * mb[1] + ma[5] * mb[5] + ma[6] * mb[9] + ma[7] * mb[13];	            this[6] = ma[4] * mb[2] + ma[5] * mb[6] + ma[6] * mb[10] + ma[7] * mb[14];	            this[7] = ma[4] * mb[3] + ma[5] * mb[7] + ma[6] * mb[11] + ma[7] * mb[15];	            this[8] = ma[8] * mb[0] + ma[9] * mb[4] + ma[10] * mb[8] + ma[11] * mb[12];	            this[9] = ma[8] * mb[1] + ma[9] * mb[5] + ma[10] * mb[9] + ma[11] * mb[13];	            this[10] = ma[8] * mb[2] + ma[9] * mb[6] + ma[10] * mb[10] + ma[11] * mb[14];	            this[11] = ma[8] * mb[3] + ma[9] * mb[7] + ma[10] * mb[11] + ma[11] * mb[15];	            this[12] = ma[12] * mb[0] + ma[13] * mb[4] + ma[14] * mb[8] + ma[15] * mb[12];	            this[13] = ma[12] * mb[1] + ma[13] * mb[5] + ma[14] * mb[9] + ma[15] * mb[13];	            this[14] = ma[12] * mb[2] + ma[13] * mb[6] + ma[14] * mb[10] + ma[15] * mb[14];	            this[15] = ma[12] * mb[3] + ma[13] * mb[7] + ma[14] * mb[11] + ma[15] * mb[15];	            return this;	        };	        Matrix.prototype.setToCovarianceOfPoints = function (points) {	            var mean,	                dx,	                dy,	                dz,	                count = 0,	                c11 = 0,	                c22 = 0,	                c33 = 0,	                c12 = 0,	                c13 = 0,	                c23 = 0,	                vec = new Vec3(0, 0, 0);	            mean = Vec3.averageOfBuffer(points, new Vec3(0, 0, 0));	            for (var i = 0, len = points.length / 3; i < len; i++) {	                vec[0] = points[i * 3];	                vec[1] = points[i * 3 + 1];	                vec[2] = points[i * 3 + 2];	                dx = vec[0] - mean[0];	                dy = vec[1] - mean[1];	                dz = vec[2] - mean[2];	                ++count;	                c11 += dx * dx;	                c22 += dy * dy;	                c33 += dz * dz;	                c12 += dx * dy; 	                c13 += dx * dz; 	                c23 += dy * dz; 	            }	            this[0] = c11 / count;	            this[1] = c12 / count;	            this[2] = c13 / count;	            this[3] = 0;	            this[4] = c12 / count;	            this[5] = c22 / count;	            this[6] = c23 / count;	            this[7] = 0;	            this[8] = c13 / count;	            this[9] = c23 / count;	            this[10] = c33 / count;	            this[11] = 0;	            this[12] = 0;	            this[13] = 0;	            this[14] = 0;	            this[15] = 0;	            return this;	        };	        Matrix.prototype.multiplyByTranslation = function (x, y, z) {	            this.multiply(	                1, 0, 0, x,	                0, 1, 0, y,	                0, 0, 1, z,	                0, 0, 0, 1);	            return this;	        };	        Matrix.prototype.multiplyByRotation = function (x, y, z, angleDegrees) {	            var c = Math.cos(angleDegrees * Angle.DEGREES_TO_RADIANS),	                s = Math.sin(angleDegrees * Angle.DEGREES_TO_RADIANS);	            this.multiply(	                c + (1 - c) * x * x, (1 - c) * x * y - s * z, (1 - c) * x * z + s * y, 0,	                (1 - c) * x * y + s * z, c + (1 - c) * y * y, (1 - c) * y * z - s * x, 0,	                (1 - c) * x * z - s * y, (1 - c) * y * z + s * x, c + (1 - c) * z * z, 0,	                0, 0, 0, 1);	            return this;	        };	        Matrix.prototype.multiplyByScale = function (xScale, yScale, zScale) {	            this.multiply(	                xScale, 0, 0, 0,	                0, yScale, 0, 0,	                0, 0, zScale, 0,	                0, 0, 0, 1);	            return this;	        };	        Matrix.prototype.setToUnitYFlip = function () {	            this[0] = 1;	            this[1] = 0;	            this[2] = 0;	            this[3] = 0;	            this[4] = 0;	            this[5] = -1;	            this[6] = 0;	            this[7] = 1;	            this[8] = 0;	            this[9] = 0;	            this[10] = 1;	            this[11] = 0;	            this[12] = 0;	            this[13] = 0;	            this[14] = 0;	            this[15] = 1;	            return this;	        };	        Matrix.prototype.multiplyByLocalCoordinateTransform = function (origin, globe) {	            var xAxis = new Vec3(0, 0, 0),	                yAxis = new Vec3(0, 0, 0),	                zAxis = new Vec3(0, 0, 0);	            WWMath.localCoordinateAxesAtPoint(origin, globe, xAxis, yAxis, zAxis);	            this.multiply(	                xAxis[0], yAxis[0], zAxis[0], origin[0],	                xAxis[1], yAxis[1], zAxis[1], origin[1],	                xAxis[2], yAxis[2], zAxis[2], origin[2],	                0, 0, 0, 1);	            return this;	        };	        Matrix.prototype.multiplyByTextureTransform = function (texture) {	            var sx = texture.originalImageWidth / texture.imageWidth,	                sy = texture.originalImageHeight / texture.imageHeight;	            this.multiply(	                sx, 0, 0, 0,	                0, -sy, 0, sy,	                0, 0, 1, 0,	                0, 0, 0, 1);	            return this;	        };	        Matrix.prototype.extractTranslation = function (result) {	            result[0] = this[3];	            result[1] = this[7];	            result[2] = this[11];	            return result;	        };	        Matrix.prototype.extractRotationAngles = function (result) {	            var x = Math.atan2(this[6], this[10]),	                y = Math.atan2(-this[2], Math.sqrt(this[0] * this[0] + this[1] * this[1])),	                cx = Math.cos(x),	                sx = Math.sin(x),	                z = Math.atan2(sx * this[8] - cx * this[4], cx * this[5] - sx * this[9]);	            result[0] = x * Angle.RADIANS_TO_DEGREES;	            result[1] = y * Angle.RADIANS_TO_DEGREES;	            result[2] = z * Angle.RADIANS_TO_DEGREES;	            return result;	        };	        Matrix.prototype.multiplyByFirstPersonModelview = function (eyePosition, heading, tilt, roll, globe) {	            var c,	                s,	                ex, ey, ez,	                xx, xy, xz,	                yx, yy, yz,	                zx, zy, zz,	                eyePoint = new Vec3(0, 0, 0),	                xAxis = new Vec3(0, 0, 0),	                yAxis = new Vec3(0, 0, 0),	                zAxis = new Vec3(0, 0, 0);	            c = Math.cos(roll * Angle.DEGREES_TO_RADIANS);	            s = Math.sin(roll * Angle.DEGREES_TO_RADIANS);	            this.multiply(	                c, s, 0, 0,	                -s, c, 0, 0,	                0, 0, 1, 0,	                0, 0, 0, 1);	            c = Math.cos(tilt * Angle.DEGREES_TO_RADIANS);	            s = Math.sin(tilt * Angle.DEGREES_TO_RADIANS);	            this.multiply(1, 0, 0, 0,	                0, c, s, 0,	                0, -s, c, 0,	                0, 0, 0, 1);	            c = Math.cos(heading * Angle.DEGREES_TO_RADIANS);	            s = Math.sin(heading * Angle.DEGREES_TO_RADIANS);	            this.multiply(c, -s, 0, 0,	                s, c, 0, 0,	                0, 0, 1, 0,	                0, 0, 0, 1);	            globe.computePointFromPosition(eyePosition.latitude, eyePosition.longitude, eyePosition.altitude, eyePoint);	            ex = eyePoint[0];	            ey = eyePoint[1];	            ez = eyePoint[2];	            WWMath.localCoordinateAxesAtPoint(eyePoint, globe, xAxis, yAxis, zAxis);	            xx = xAxis[0];	            xy = xAxis[1];	            xz = xAxis[2];	            yx = yAxis[0];	            yy = yAxis[1];	            yz = yAxis[2];	            zx = zAxis[0];	            zy = zAxis[1];	            zz = zAxis[2];	            this.multiply(xx, xy, xz, -xx * ex - xy * ey - xz * ez,	                yx, yy, yz, -yx * ex - yy * ey - yz * ez,	                zx, zy, zz, -zx * ex - zy * ey - zz * ez,	                0, 0, 0, 1);	            return this;	        };	        Matrix.prototype.multiplyByLookAtModelview = function (lookAtPosition, range, heading, tilt, roll, globe) {	            this.multiplyByTranslation(0, 0, -range);	            this.multiplyByFirstPersonModelview(lookAtPosition, heading, tilt, roll, globe);	            return this;	        };	        Matrix.prototype.setToPerspectiveProjection = function (viewportWidth, viewportHeight, nearDistance, farDistance) {	            var nearRect = WWMath.perspectiveFrustumRectangle(viewportWidth, viewportHeight, nearDistance),	                left = nearRect.getMinX(),	                right = nearRect.getMaxX(),	                bottom = nearRect.getMinY(),	                top = nearRect.getMaxY();	            this[0] = 2 * nearDistance / (right - left);	            this[1] = 0;	            this[2] = (right + left) / (right - left);	            this[3] = 0;	            this[4] = 0;	            this[5] = 2 * nearDistance / (top - bottom);	            this[6] = (top + bottom) / (top - bottom);	            this[7] = 0;	            this[8] = 0;	            this[9] = 0;	            this[10] = -(farDistance + nearDistance) / (farDistance - nearDistance);	            this[11] = -2 * nearDistance * farDistance / (farDistance - nearDistance);	            this[12] = 0;	            this[13] = 0;	            this[14] = -1;	            this[15] = 0;	            return this;	        };	        Matrix.prototype.setToScreenProjection = function (viewportWidth, viewportHeight) {	            this[0] = 2 / viewportWidth;	            this[1] = 0;	            this[2] = 0;	            this[3] = -1;	            this[4] = 0;	            this[5] = 2 / viewportHeight;	            this[6] = 0;	            this[7] = -1;	            this[8] = 0;	            this[9] = 0;	            this[10] = 2;	            this[11] = -1;	            this[12] = 0;	            this[13] = 0;	            this[14] = 0;	            this[15] = 1;	            return this;	        };	        Matrix.prototype.extractEyePoint = function (result) {	            result[0] = -(this[0] * this[3]) - (this[4] * this[7]) - (this[8] * this[11]);	            result[1] = -(this[1] * this[3]) - (this[5] * this[7]) - (this[9] * this[11]);	            result[2] = -(this[2] * this[3]) - (this[6] * this[7]) - (this[10] * this[11]);	            return result;	        };	        Matrix.prototype.extractForwardVector = function (result) {	            result[0] = -this[8];	            result[1] = -this[9];	            result[2] = -this[10];	            return result;	        };	        Matrix.prototype.extractViewingParameters = function (origin, roll, globe, result) {	            var originPos = new Position(0, 0, 0),	                modelviewLocal = Matrix.fromIdentity(),	                range,	                ct,	                st,	                tilt,	                cr, sr,	                ch, sh,	                heading;	            globe.computePositionFromPoint(origin[0], origin[1], origin[2], originPos);	            modelviewLocal.copy(this);	            modelviewLocal.multiplyByLocalCoordinateTransform(origin, globe);	            range = -modelviewLocal[11];	            ct = modelviewLocal[10];	            st = Math.sqrt(modelviewLocal[2] * modelviewLocal[2] + modelviewLocal[6] * modelviewLocal[6]);	            tilt = Math.atan2(st, ct) * Angle.RADIANS_TO_DEGREES;	            cr = Math.cos(roll * Angle.DEGREES_TO_RADIANS);	            sr = Math.sin(roll * Angle.DEGREES_TO_RADIANS);	            ch = cr * modelviewLocal[0] - sr * modelviewLocal[4];	            sh = sr * modelviewLocal[5] - cr * modelviewLocal[1];	            heading = Math.atan2(sh, ch) * Angle.RADIANS_TO_DEGREES;	            result['origin'] = originPos;	            result['range'] = range;	            result['heading'] = heading;	            result['tilt'] = tilt;	            result['roll'] = roll;	            return result;	        };	        Matrix.prototype.offsetProjectionDepth = function (depthOffset) {	            this[10] *= 1 + depthOffset;	            return this;	        };	        Matrix.prototype.multiplyMatrix = function (matrix) {	            var ma = this,	                mb = matrix,	                ma0, ma1, ma2, ma3;	            ma0 = ma[0];	            ma1 = ma[1];	            ma2 = ma[2];	            ma3 = ma[3];	            ma[0] = (ma0 * mb[0]) + (ma1 * mb[4]) + (ma2 * mb[8]) + (ma3 * mb[12]);	            ma[1] = (ma0 * mb[1]) + (ma1 * mb[5]) + (ma2 * mb[9]) + (ma3 * mb[13]);	            ma[2] = (ma0 * mb[2]) + (ma1 * mb[6]) + (ma2 * mb[10]) + (ma3 * mb[14]);	            ma[3] = (ma0 * mb[3]) + (ma1 * mb[7]) + (ma2 * mb[11]) + (ma3 * mb[15]);	            ma0 = ma[4];	            ma1 = ma[5];	            ma2 = ma[6];	            ma3 = ma[7];	            ma[4] = (ma0 * mb[0]) + (ma1 * mb[4]) + (ma2 * mb[8]) + (ma3 * mb[12]);	            ma[5] = (ma0 * mb[1]) + (ma1 * mb[5]) + (ma2 * mb[9]) + (ma3 * mb[13]);	            ma[6] = (ma0 * mb[2]) + (ma1 * mb[6]) + (ma2 * mb[10]) + (ma3 * mb[14]);	            ma[7] = (ma0 * mb[3]) + (ma1 * mb[7]) + (ma2 * mb[11]) + (ma3 * mb[15]);	            ma0 = ma[8];	            ma1 = ma[9];	            ma2 = ma[10];	            ma3 = ma[11];	            ma[8] = (ma0 * mb[0]) + (ma1 * mb[4]) + (ma2 * mb[8]) + (ma3 * mb[12]);	            ma[9] = (ma0 * mb[1]) + (ma1 * mb[5]) + (ma2 * mb[9]) + (ma3 * mb[13]);	            ma[10] = (ma0 * mb[2]) + (ma1 * mb[6]) + (ma2 * mb[10]) + (ma3 * mb[14]);	            ma[11] = (ma0 * mb[3]) + (ma1 * mb[7]) + (ma2 * mb[11]) + (ma3 * mb[15]);	            ma0 = ma[12];	            ma1 = ma[13];	            ma2 = ma[14];	            ma3 = ma[15];	            ma[12] = (ma0 * mb[0]) + (ma1 * mb[4]) + (ma2 * mb[8]) + (ma3 * mb[12]);	            ma[13] = (ma0 * mb[1]) + (ma1 * mb[5]) + (ma2 * mb[9]) + (ma3 * mb[13]);	            ma[14] = (ma0 * mb[2]) + (ma1 * mb[6]) + (ma2 * mb[10]) + (ma3 * mb[14]);	            ma[15] = (ma0 * mb[3]) + (ma1 * mb[7]) + (ma2 * mb[11]) + (ma3 * mb[15]);	            return this;	        };	        Matrix.prototype.multiply = function (m00, m01, m02, m03,	                                              m10, m11, m12, m13,	                                              m20, m21, m22, m23,	                                              m30, m31, m32, m33) {	            var ma = this,	                ma0, ma1, ma2, ma3;	            ma0 = ma[0];	            ma1 = ma[1];	            ma2 = ma[2];	            ma3 = ma[3];	            ma[0] = (ma0 * m00) + (ma1 * m10) + (ma2 * m20) + (ma3 * m30);	            ma[1] = (ma0 * m01) + (ma1 * m11) + (ma2 * m21) + (ma3 * m31);	            ma[2] = (ma0 * m02) + (ma1 * m12) + (ma2 * m22) + (ma3 * m32);	            ma[3] = (ma0 * m03) + (ma1 * m13) + (ma2 * m23) + (ma3 * m33);	            ma0 = ma[4];	            ma1 = ma[5];	            ma2 = ma[6];	            ma3 = ma[7];	            ma[4] = (ma0 * m00) + (ma1 * m10) + (ma2 * m20) + (ma3 * m30);	            ma[5] = (ma0 * m01) + (ma1 * m11) + (ma2 * m21) + (ma3 * m31);	            ma[6] = (ma0 * m02) + (ma1 * m12) + (ma2 * m22) + (ma3 * m32);	            ma[7] = (ma0 * m03) + (ma1 * m13) + (ma2 * m23) + (ma3 * m33);	            ma0 = ma[8];	            ma1 = ma[9];	            ma2 = ma[10];	            ma3 = ma[11];	            ma[8] = (ma0 * m00) + (ma1 * m10) + (ma2 * m20) + (ma3 * m30);	            ma[9] = (ma0 * m01) + (ma1 * m11) + (ma2 * m21) + (ma3 * m31);	            ma[10] = (ma0 * m02) + (ma1 * m12) + (ma2 * m22) + (ma3 * m32);	            ma[11] = (ma0 * m03) + (ma1 * m13) + (ma2 * m23) + (ma3 * m33);	            ma0 = ma[12];	            ma1 = ma[13];	            ma2 = ma[14];	            ma3 = ma[15];	            ma[12] = (ma0 * m00) + (ma1 * m10) + (ma2 * m20) + (ma3 * m30);	            ma[13] = (ma0 * m01) + (ma1 * m11) + (ma2 * m21) + (ma3 * m31);	            ma[14] = (ma0 * m02) + (ma1 * m12) + (ma2 * m22) + (ma3 * m32);	            ma[15] = (ma0 * m03) + (ma1 * m13) + (ma2 * m23) + (ma3 * m33);	            return this;	        };	        Matrix.prototype.invertMatrix = function (matrix) {	            var A = [[], [], [], []];	            A[0][0] = matrix[0];	            A[0][1] = matrix[1];	            A[0][2] = matrix[2];	            A[0][3] = matrix[3];	            A[1][0] = matrix[4];	            A[1][1] = matrix[5];	            A[1][2] = matrix[6];	            A[1][3] = matrix[7];	            A[2][0] = matrix[8];	            A[2][1] = matrix[9];	            A[2][2] = matrix[10];	            A[2][3] = matrix[11];	            A[3][0] = matrix[12];	            A[3][1] = matrix[13];	            A[3][2] = matrix[14];	            A[3][3] = matrix[15];	            var index = [],	                d = Matrix.ludcmp(A, index),	                i,	                j;	            for (i = 0; i < 4; i += 1) {	                d *= A[i][i];	            }	            if (Math.abs(d) < 1.0e-8)	                return null;	            var Y = [[], [], [], []],	                col = [];	            for (j = 0; j < 4; j += 1) {	                for (i = 0; i < 4; i += 1) {	                    col[i] = 0.0;	                }	                col[j] = 1.0;	                Matrix.lubksb(A, index, col);	                for (i = 0; i < 4; i += 1) {	                    Y[i][j] = col[i];	                }	            }	            this[0] = Y[0][0];	            this[1] = Y[0][1];	            this[2] = Y[0][2];	            this[3] = Y[0][3];	            this[4] = Y[1][0];	            this[5] = Y[1][1];	            this[6] = Y[1][2];	            this[7] = Y[1][3];	            this[8] = Y[2][0];	            this[9] = Y[2][1];	            this[10] = Y[2][2];	            this[11] = Y[2][3];	            this[12] = Y[3][0];	            this[13] = Y[3][1];	            this[14] = Y[3][2];	            this[15] = Y[3][3];	            return this;	        };	        Matrix.lubksb = function (A, index, b) {	            var ii = -1,	                i,	                j,	                sum;	            for (i = 0; i < 4; i += 1) {	                var ip = index[i];	                sum = b[ip];	                b[ip] = b[i];	                if (ii != -1) {	                    for (j = ii; j <= i - 1; j += 1) {	                        sum -= A[i][j] * b[j];	                    }	                }	                else if (sum != 0.0) {	                    ii = i;	                }	                b[i] = sum;	            }	            for (i = 3; i >= 0; i -= 1) {	                sum = b[i];	                for (j = i + 1; j < 4; j += 1) {	                    sum -= A[i][j] * b[j];	                }	                b[i] = sum / A[i][i];	            }	        };	        Matrix.ludcmp = function (A, index) {	            var TINY = 1.0e-20,	                vv = [], 	                d = 1.0,	                temp,	                i,	                j,	                k,	                big,	                sum,	                imax,	                dum;	            for (i = 0; i < 4; i += 1) {	                big = 0.0;	                for (j = 0; j < 4; j += 1) {	                    if ((temp = Math.abs(A[i][j])) > big) {	                        big = temp;	                    }	                }	                if (big == 0.0) {	                    return 0.0; 	                }	                else {	                    vv[i] = 1.0 / big;	                }	            }	            for (j = 0; j < 4; j += 1) {	                for (i = 0; i < j; i += 1) {	                    sum = A[i][j];	                    for (k = 0; k < i; k += 1) {	                        sum -= A[i][k] * A[k][j];	                    }	                    A[i][j] = sum;	                }	                big = 0.0;	                imax = -1;	                for (i = j; i < 4; i += 1) {	                    sum = A[i][j];	                    for (k = 0; k < j; k++) {	                        sum -= A[i][k] * A[k][j];	                    }	                    A[i][j] = sum;	                    if ((dum = vv[i] * Math.abs(sum)) >= big) {	                        big = dum;	                        imax = i;	                    }	                }	                if (j != imax) {	                    for (k = 0; k < 4; k += 1) {	                        dum = A[imax][k];	                        A[imax][k] = A[j][k];	                        A[j][k] = dum;	                    }	                    d = -d;	                    vv[imax] = vv[j];	                }	                index[j] = imax;	                if (A[j][j] == 0.0)	                    A[j][j] = TINY;	                if (j != 3) {	                    dum = 1.0 / A[j][j];	                    for (i = j + 1; i < 4; i += 1) {	                        A[i][j] *= dum;	                    }	                }	            }	            return d;	        };	        Matrix.prototype.invertOrthonormalMatrix = function (matrix) {	            var a = matrix;	            this[0] = a[0];	            this[1] = a[4];	            this[2] = a[8];	            this[3] = 0.0 - (a[0] * a[3]) - (a[4] * a[7]) - (a[8] * a[11]);	            this[4] = a[1];	            this[5] = a[5];	            this[6] = a[9];	            this[7] = 0.0 - (a[1] * a[3]) - (a[5] * a[7]) - (a[9] * a[11]);	            this[8] = a[2];	            this[9] = a[6];	            this[10] = a[10];	            this[11] = 0.0 - (a[2] * a[3]) - (a[6] * a[7]) - (a[10] * a[11]);	            this[12] = 0;	            this[13] = 0;	            this[14] = 0;	            this[15] = 1;	            return this;	        };	        Matrix.prototype.eigensystemFromSymmetricMatrix = function (result1, result2, result3) {	            var epsilon = 1.0e-10,	                m11 = this[0],	                m12 = this[1],	                m13 = this[2],	                m22 = this[5],	                m23 = this[6],	                m33 = this[10],	                r = [	                    [1, 0, 0],	                    [0, 1, 0],	                    [0, 0, 1]	                ],	                maxSweeps = 32,	                u, u2, u2p1, t, c, s, temp, i, i1, i2, i3;	            for (var a = 0; a < maxSweeps; a++) {	                if (WWMath.fabs(m12) < epsilon && WWMath.fabs(m13) < epsilon && WWMath.fabs(m23) < epsilon)	                    break;	                if (m12 != 0) {	                    u = (m22 - m11) * 0.5 / m12;	                    u2 = u * u;	                    u2p1 = u2 + 1;	                    t = (u2p1 != u2) ? ((u < 0) ? -1 : 1) * (Math.sqrt(u2p1) - WWMath.fabs(u)) : 0.5 / u;	                    c = 1 / Math.sqrt(t * t + 1);	                    s = c * t;	                    m11 -= t * m12;	                    m22 += t * m12;	                    m12 = 0;	                    temp = c * m13 - s * m23;	                    m23 = s * m13 + c * m23;	                    m13 = temp;	                    for (i = 0; i < 3; i++) {	                        temp = c * r[i][0] - s * r[i][1];	                        r[i][1] = s * r[i][0] + c * r[i][1];	                        r[i][0] = temp;	                    }	                }	                if (m13 != 0) {	                    u = (m33 - m11) * 0.5 / m13;	                    u2 = u * u;	                    u2p1 = u2 + 1;	                    t = (u2p1 != u2) ? ((u < 0) ? -1 : 1) * (Math.sqrt(u2p1) - WWMath.fabs(u)) : 0.5 / u;	                    c = 1 / Math.sqrt(t * t + 1);	                    s = c * t;	                    m11 -= t * m13;	                    m33 += t * m13;	                    m13 = 0;	                    temp = c * m12 - s * m23;	                    m23 = s * m12 + c * m23;	                    m12 = temp;	                    for (i = 0; i < 3; i++) {	                        temp = c * r[i][0] - s * r[i][2];	                        r[i][2] = s * r[i][0] + c * r[i][2];	                        r[i][0] = temp;	                    }	                }	                if (m23 != 0) {	                    u = (m33 - m22) * 0.5 / m23;	                    u2 = u * u;	                    u2p1 = u2 + 1;	                    t = (u2p1 != u2) ? ((u < 0) ? -1 : 1) * (Math.sqrt(u2p1) - WWMath.fabs(u)) : 0.5 / u;	                    c = 1 / Math.sqrt(t * t + 1);	                    s = c * t;	                    m22 -= t * m23;	                    m33 += t * m23;	                    m23 = 0;	                    temp = c * m12 - s * m13;	                    m13 = s * m12 + c * m13;	                    m12 = temp;	                    for (i = 0; i < 3; i++) {	                        temp = c * r[i][1] - s * r[i][2];	                        r[i][2] = s * r[i][1] + c * r[i][2];	                        r[i][1] = temp;	                    }	                }	            }	            i1 = 0;	            i2 = 1;	            i3 = 2;	            if (m11 < m22) {	                temp = m11;	                m11 = m22;	                m22 = temp;	                temp = i1;	                i1 = i2;	                i2 = temp;	            }	            if (m22 < m33) {	                temp = m22;	                m22 = m33;	                m33 = temp;	                temp = i2;	                i2 = i3;	                i3 = temp;	            }	            if (m11 < m22) {	                temp = m11;	                m11 = m22;	                m22 = temp;	                temp = i1;	                i1 = i2;	                i2 = temp;	            }	            result1[0] = r[0][i1];	            result1[1] = r[1][i1];	            result1[2] = r[2][i1];	            result2[0] = r[0][i2];	            result2[1] = r[1][i2];	            result2[2] = r[2][i2];	            result3[0] = r[0][i3];	            result3[1] = r[1][i3];	            result3[2] = r[2][i3];	            result1.normalize();	            result2.normalize();	            result3.normalize();	            result1.multiply(m11);	            result2.multiply(m22);	            result3.multiply(m33);	        };	        Matrix.prototype.upper3By3 = function () {	            var result = Matrix.fromIdentity();	            result[0] = this[0];	            result[1] = this[1];	            result[2] = this[2];	            result[4] = this[4];	            result[5] = this[5];	            result[6] = this[6];	            result[8] = this[8];	            result[9] = this[9];	            result[10] = this[10];	            return result;	        };	        return Matrix;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(15),	        __webpack_require__(9),	        __webpack_require__(16)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Line,	              Logger,	              Vec3) {	        "use strict";	        var Plane = function (x, y, z, distance) {	            this.normal = new Vec3(x, y, z);	            this.distance = distance;	        };	        Plane.fromPoints = function(pa, pb, pc) {	            var vab = new Vec3(pb[0], pb[1], pb[2]);	            vab.subtract(pa);	            var vac = new Vec3(pc[0], pc[1], pc[2]);	            vac.subtract(pa);	            vab.cross(vac);	            vab.normalize();	            var d = -vab.dot(pa);	            return new Plane(vab[0], vab[1], vab[2], d);	        };	        Plane.prototype.dot = function (vector) {	            return this.normal.dot(vector) + this.distance;	        };	        Plane.prototype.distanceToPoint = function (point) {	            return this.dot(point);	        };	        Plane.prototype.transformByMatrix = function (matrix){	            var x = matrix[0] * this.normal[0] + matrix[1] * this.normal[1] + matrix[2] * this.normal[2] + matrix[3] * this.distance,	                y = matrix[4] * this.normal[0] + matrix[5] * this.normal[1] + matrix[6] * this.normal[2] + matrix[7] * this.distance,	                z = matrix[8] * this.normal[0] + matrix[9] * this.normal[1] + matrix[10] * this.normal[2] + matrix[11] * this.distance,	                distance = matrix[12] * this.normal[0] + matrix[13] * this.normal[1] + matrix[14] * this.normal[2] + matrix[15] * this.distance;	            this.normal[0] = x;	            this.normal[1] = y;	            this.normal[2] = z;	            this.distance = distance;	            return this;	        };	        Plane.prototype.normalize = function () {	            var magnitude = this.normal.magnitude();	            if (magnitude === 0)	                return this;	            this.normal.divide(magnitude);	            this.distance /= magnitude;	            return this;	        };	        Plane.prototype.intersectsSegment = function(endPoint1, endPoint2) {	            var distance1 = this.dot(endPoint1),	                distance2 = this.dot(endPoint2);	            return distance1 * distance2 <= 0;	        };	        Plane.prototype.intersectsSegmentAt = function (endPoint1, endPoint2, result) {	            var distance1 = this.dot(endPoint1),	                distance2 = this.dot(endPoint2);	            if (distance1 === 0 && distance2 === 0) {	                result[0] = endPoint1[0];	                result[1] = endPoint1[1];	                result[2] = endPoint1[2];	                return true;	            }	            else if (distance1 === distance2) {	                return false;	            }	            var weight1 = -distance1 / (distance2 - distance1),	                weight2 = 1 - weight1;	            result[0] = weight1 * endPoint1[0] + weight2 * endPoint2[0];	            result[1] = weight1 * endPoint1[1] + weight2 * endPoint2[1];	            result[2] = weight1 * endPoint1[2] + weight2 * endPoint2[2];	            return distance1 * distance2 <= 0;	        };	        Plane.prototype.onSameSide = function (pointA, pointB) {	            var da = this.distanceToPoint(pointA),	                db = this.distanceToPoint(pointB);	            if (da < 0 && db < 0)	                return -1;	            if (da > 0 && db > 0)	                return 1;	            return 0;	        };	        Plane.prototype.clip = function (pointA, pointB) {	            if (pointA.equals(pointB)) {	                return null;	            }	            var line = Line.fromSegment(pointA, pointB),	                lDotV = this.normal.dot(line.direction),	                lDotS, t, p;	            if (lDotV === 0) { 	                lDotS = this.dot(line.origin);	                if (lDotS === 0) {	                    return [pointA, pointB]; 	                } else {	                    return null; 	                }	            }	            t = -this.dot(line.origin) / lDotV; 	            if (t < 0 || t > 1) { 	                return null;	            }	            p = line.pointAt(t, new Vec3(0, 0, 0));	            if (lDotV > 0) {	                return [p, pointB];	            } else {	                return [pointA, p];	            }	        };	        return Plane;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(9),	        __webpack_require__(16)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Logger,	              Vec3) {	        "use strict";	        var Line = function (origin, direction) {	            this.origin = origin;	            this.direction = direction;	        };	        Line.fromSegment = function (pointA, pointB) {	            var origin = new Vec3(pointA[0], pointA[1], pointA[2]),	                direction = new Vec3(pointB[0] - pointA[0], pointB[1] - pointA[1], pointB[2] - pointA[2]);	            return new Line(origin, direction);	        };	        Line.prototype.pointAt = function (distance, result) {	            result[0] = this.origin[0] + this.direction[0] * distance;	            result[1] = this.origin[1] + this.direction[1] * distance;	            result[2] = this.origin[2] + this.direction[2] * distance;	            return result;	        };	        return Line;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(9),	        __webpack_require__(7)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Logger,	              ArgumentError) {	        "use strict";	        var Vec3 = function Vec3(x, y, z) {	            this[0] = x;	            this[1] = y;	            this[2] = z;	        };	        Vec3.prototype = new Float64Array(3);	        Vec3.ZERO = new Vec3(0, 0, 0);	        Vec3.average = function (vectors, result) {	            var count = vectors.length,	                vec;	            result[0] = 0;	            result[1] = 0;	            result[2] = 0;	            for (var i = 0, len = vectors.length; i < len; i++) {	                vec = vectors[i];	                result[0] += vec[0] / count;	                result[1] += vec[1] / count;	                result[2] += vec[2] / count;	            }	            return result;	        };	        Vec3.averageOfBuffer = function (points, result) {	            var count = points.length / 3;	            result[0] = 0;	            result[1] = 0;	            result[2] = 0;	            for (var i = 0; i < count; i++) {	                result[0] += points[i * 3] / count;	                result[1] += points[i * 3 + 1] / count;	                result[2] += points[i * 3 + 2] / count;	            }	            return result;	        };	        Vec3.areColinear = function (a, b, c) {	           var ab = new Vec3(a[0]-b[0],a[1]-b[1],a[2]-b[2]).normalize(),	               bc = new Vec3(c[0]-b[0],c[1]-b[1],c[2]-b[2]).normalize();	            return Math.abs(ab.dot(bc)) > 0.999;	        };	        Vec3.computeTriangleNormal = function (a, b, c) {	            var x = ((b[1] - a[1]) * (c[2] - a[2])) - ((b[2] - a[2]) * (c[1] - a[1])),	                y = ((b[2] - a[2]) * (c[0] - a[0])) - ((b[0] - a[0]) * (c[2] - a[2])),	                z = ((b[0] - a[0]) * (c[1] - a[1])) - ((b[1] - a[1]) * (c[0] - a[0])),	                length = (x * x) + (y * y) + (z * z);	            if (length === 0) {	                return new Vec3(x, y, z);	            }	            length = Math.sqrt(length);	            return new Vec3(x / length, y / length, z / length);	        };	        Vec3.findThreeIndependentVertices = function (coords, stride) {	            var xstride = (stride && stride > 0) ? stride : 3;	            if (!coords || coords.length < 3 * xstride) {	                return null;	            }	            var a = new Vec3(coords[0], coords[1], coords[2]),	                b = null,	                c = null,	                k = xstride;	            for (; k < coords.length; k += xstride) {	                b = new Vec3(coords[k], coords[k + 1], coords[k + 2]);	                if (!(b[0] === a[0] && b[1] === a[1] && b[2] === a[2])) {	                    break;	                }	                b = null;	            }	            if (!b) {	                return null;	            }	            for (k += xstride; k < coords.length; k += xstride) {	                c = new Vec3(coords[k], coords[k + 1], coords[k + 2]);	                if (!((c[0] === a[0] && c[1] === a[1] && c[2] === a[2])	                    || (c[0] === b[0] && c[1] === b[1] && c[2] === b[2]))) {	                    if (!Vec3.areColinear(a, b, c))	                        break;	                }	                c = null;	            }	            return c ? [a, b, c] : null;	        };	        Vec3.computeBufferNormal = function (coords, stride) {	            var vertices = Vec3.findThreeIndependentVertices(coords, stride);	            return vertices ? Vec3.computeTriangleNormal(vertices[0], vertices[1], vertices[2]) : null;	        };	        Vec3.prototype.set = function (x, y, z) {	            this[0] = x;	            this[1] = y;	            this[2] = z;	            return this;	        };	        Vec3.prototype.copy = function (vector) {	            this[0] = vector[0];	            this[1] = vector[1];	            this[2] = vector[2];	            return this;	        };	        Vec3.prototype.equals = function (vector) {	            return this[0] === vector[0] && this[1] === vector[1] && this[2] === vector[2];	        };	        Vec3.prototype.add = function (addend) {	            this[0] += addend[0];	            this[1] += addend[1];	            this[2] += addend[2];	            return this;	        };	        Vec3.prototype.subtract = function (subtrahend) {	            this[0] -= subtrahend[0];	            this[1] -= subtrahend[1];	            this[2] -= subtrahend[2];	            return this;	        };	        Vec3.prototype.multiply = function (scalar) {	            this[0] *= scalar;	            this[1] *= scalar;	            this[2] *= scalar;	            return this;	        };	        Vec3.prototype.divide = function (divisor) {	            this[0] /= divisor;	            this[1] /= divisor;	            this[2] /= divisor;	            return this;	        };	        Vec3.prototype.multiplyByMatrix = function (matrix) {	            var x = matrix[0] * this[0] + matrix[1] * this[1] + matrix[2] * this[2] + matrix[3],	                y = matrix[4] * this[0] + matrix[5] * this[1] + matrix[6] * this[2] + matrix[7],	                z = matrix[8] * this[0] + matrix[9] * this[1] + matrix[10] * this[2] + matrix[11],	                w = matrix[12] * this[0] + matrix[13] * this[1] + matrix[14] * this[2] + matrix[15];	            this[0] = x / w;	            this[1] = y / w;	            this[2] = z / w;	            return this;	        };	        Vec3.prototype.mix = function (vector, weight) {	            var w0 = 1 - weight,	                w1 = weight;	            this[0] = this[0] * w0 + vector[0] * w1;	            this[1] = this[1] * w0 + vector[1] * w1;	            this[2] = this[2] * w0 + vector[2] * w1;	            return this;	        };	        Vec3.prototype.negate = function () {	            this[0] = -this[0];	            this[1] = -this[1];	            this[2] = -this[2];	            return this;	        };	        Vec3.prototype.dot = function (vector) {	            return this[0] * vector[0] +	                this[1] * vector[1] +	                this[2] * vector[2];	        };	        Vec3.prototype.cross = function (vector) {	            var x = this[1] * vector[2] - this[2] * vector[1],	                y = this[2] * vector[0] - this[0] * vector[2],	                z = this[0] * vector[1] - this[1] * vector[0];	            this[0] = x;	            this[1] = y;	            this[2] = z;	            return this;	        };	        Vec3.prototype.magnitudeSquared = function () {	            return this.dot(this);	        };	        Vec3.prototype.magnitude = function () {	            return Math.sqrt(this.magnitudeSquared());	        };	        Vec3.prototype.normalize = function () {	            var magnitude = this.magnitude(),	                magnitudeInverse = 1 / magnitude;	            this[0] *= magnitudeInverse;	            this[1] *= magnitudeInverse;	            this[2] *= magnitudeInverse;	            return this;	        };	        Vec3.prototype.distanceToSquared = function (vector) {	            var dx = this[0] - vector[0],	                dy = this[1] - vector[1],	                dz = this[2] - vector[2];	            return dx * dx + dy * dy + dz * dz;	        };	        Vec3.prototype.distanceTo = function (vector) {	            return Math.sqrt(this.distanceToSquared(vector));	        };	        Vec3.prototype.swap = function (that) {	            var tmp = this[0];	            this[0] = that[0];	            that[0] = tmp;	            tmp = this[1];	            this[1] = that[1];	            that[1] = tmp;	            tmp = this[2];	            this[2] = that[2];	            that[2] = tmp;	            return this;	        };	        Vec3.prototype.toString = function () {	            return "(" + this[0] + ", " + this[1] + ", " + this[2] + ")";	        };	        return Vec3;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(11),	        __webpack_require__(7),	        __webpack_require__(18),	        __webpack_require__(9),	        __webpack_require__(19)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,	              ArgumentError,	              Location,	              Logger,	              WWMath) {	        "use strict";	        var Position = function (latitude, longitude, altitude) {	            this.latitude = latitude;	            this.longitude = longitude;	            this.altitude = altitude;	        };	        Position.ZERO = new Position(0, 0, 0);	        Position.fromRadians = function (latitudeRadians, longitudeRadians, altitude) {	            return new Position(	                latitudeRadians * Angle.RADIANS_TO_DEGREES,	                longitudeRadians * Angle.RADIANS_TO_DEGREES,	                altitude);	        };	        Position.prototype.copy = function (position) {	            this.latitude = position.latitude;	            this.longitude = position.longitude;	            this.altitude = position.altitude;	            return this;	        };	        Position.prototype.equals = function (position) {	            return position	                && position.latitude === this.latitude	                && position.longitude === this.longitude	                && position.altitude === this.altitude;	        };	        Position.interpolateGreatCircle = function (amount, position1, position2, result) {	            var t = WWMath.clamp(amount, 0, 1);	            result.altitude = WWMath.interpolate(t, position1.altitude, position2.altitude);	            Location.interpolateGreatCircle(t, position1, position2, result);	            return result;	        };	        Position.interpolateRhumb = function (amount, position1, position2, result) {	            var t = WWMath.clamp(amount, 0, 1);	            result.altitude = WWMath.interpolate(t, position1.altitude, position2.altitude);	            Location.interpolateRhumb(t, position1, position2, result);	            return result;	        };	        Position.interpolateLinear = function (amount, position1, position2, result) {	            var t = WWMath.clamp(amount, 0, 1);	            result.altitude = WWMath.interpolate(t, position1.altitude, position2.altitude);	            Location.interpolateLinear(t, position1, position2, result);	            return result;	        };	        Position.prototype.toString = function () {	            return "(" + this.latitude.toString() + "\u00b0, " + this.longitude.toString() + "\u00b0, "	                + this.altitude.toString() + ")";	        };	        return Position;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(11),	        __webpack_require__(7),	        __webpack_require__(9),	        __webpack_require__(14),	        __webpack_require__(16),	        __webpack_require__(19)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,	              ArgumentError,	              Logger,	              Plane,	              Vec3,	              WWMath) {	        "use strict";	        var Location = function (latitude, longitude) {	            this.latitude = latitude;	            this.longitude = longitude;	        };	        Location.ZERO = new Location(0, 0);	        Location.fromRadians = function (latitudeRadians, longitudeRadians) {	            return new Location(latitudeRadians * Angle.RADIANS_TO_DEGREES, longitudeRadians * Angle.RADIANS_TO_DEGREES);	        };	        Location.prototype.copy = function (location) {	            this.latitude = location.latitude;	            this.longitude = location.longitude;	            return this;	        };	        Location.prototype.set = function (latitude, longitude) {	            this.latitude = latitude;	            this.longitude = longitude;	            return this;	        };	        Location.prototype.equals = function (location) {	            return location	                && location.latitude === this.latitude && location.longitude === this.longitude;	        };	        Location.interpolateAlongPath = function (pathType, amount, location1, location2, result) {	            if (pathType === WorldWind.GREAT_CIRCLE) {	                return this.interpolateGreatCircle(amount, location1, location2, result);	            } else if (pathType && pathType === WorldWind.RHUMB_LINE) {	                return this.interpolateRhumb(amount, location1, location2, result);	            } else {	                return this.interpolateLinear(amount, location1, location2, result);	            }	        };	        Location.interpolateGreatCircle = function (amount, location1, location2, result) {	            if (location1.equals(location2)) {	                result.latitude = location1.latitude;	                result.longitude = location1.longitude;	                return result;	            }	            var t = WWMath.clamp(amount, 0, 1),	                azimuthDegrees = this.greatCircleAzimuth(location1, location2),	                distanceRadians = this.greatCircleDistance(location1, location2);	            return this.greatCircleLocation(location1, azimuthDegrees, t * distanceRadians, result);	        };	        Location.greatCircleAzimuth = function (location1, location2) {	            var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,	                lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,	                lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,	                lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,	                x,	                y,	                azimuthRadians;	            if (lat1 == lat2 && lon1 == lon2) {	                return 0;	            }	            if (lon1 == lon2) {	                return lat1 > lat2 ? 180 : 0;	            }	            y = Math.cos(lat2) * Math.sin(lon2 - lon1);	            x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);	            azimuthRadians = Math.atan2(y, x);	            return isNaN(azimuthRadians) ? 0 : azimuthRadians * Angle.RADIANS_TO_DEGREES;	        };	        Location.greatCircleDistance = function (location1, location2) {	            var lat1Radians = location1.latitude * Angle.DEGREES_TO_RADIANS,	                lat2Radians = location2.latitude * Angle.DEGREES_TO_RADIANS,	                lon1Radians = location1.longitude * Angle.DEGREES_TO_RADIANS,	                lon2Radians = location2.longitude * Angle.DEGREES_TO_RADIANS,	                a,	                b,	                c,	                distanceRadians;	            if (lat1Radians == lat2Radians && lon1Radians == lon2Radians) {	                return 0;	            }	            a = Math.sin((lat2Radians - lat1Radians) / 2.0);	            b = Math.sin((lon2Radians - lon1Radians) / 2.0);	            c = a * a + Math.cos(lat1Radians) * Math.cos(lat2Radians) * b * b;	            distanceRadians = 2.0 * Math.asin(Math.sqrt(c));	            return isNaN(distanceRadians) ? 0 : distanceRadians;	        };	        Location.greatCircleLocation = function (location, greatCircleAzimuthDegrees, pathLengthRadians, result) {	            if (pathLengthRadians == 0) {	                result.latitude = location.latitude;	                result.longitude = location.longitude;	                return result;	            }	            var latRadians = location.latitude * Angle.DEGREES_TO_RADIANS,	                lonRadians = location.longitude * Angle.DEGREES_TO_RADIANS,	                azimuthRadians = greatCircleAzimuthDegrees * Angle.DEGREES_TO_RADIANS,	                endLatRadians,	                endLonRadians;	            endLatRadians = Math.asin(Math.sin(latRadians) * Math.cos(pathLengthRadians) +	                Math.cos(latRadians) * Math.sin(pathLengthRadians) * Math.cos(azimuthRadians));	            endLonRadians = lonRadians + Math.atan2(	                Math.sin(pathLengthRadians) * Math.sin(azimuthRadians),	                Math.cos(latRadians) * Math.cos(pathLengthRadians) -	                Math.sin(latRadians) * Math.sin(pathLengthRadians) * Math.cos(azimuthRadians));	            if (isNaN(endLatRadians) || isNaN(endLonRadians)) {	                result.latitude = location.latitude;	                result.longitude = location.longitude;	            } else {	                result.latitude = Angle.normalizedDegreesLatitude(endLatRadians * Angle.RADIANS_TO_DEGREES);	                result.longitude = Angle.normalizedDegreesLongitude(endLonRadians * Angle.RADIANS_TO_DEGREES);	            }	            return result;	        };	        Location.interpolateRhumb = function (amount, location1, location2, result) {	            if (location1.equals(location2)) {	                result.latitude = location1.latitude;	                result.longitude = location1.longitude;	                return result;	            }	            var t = WWMath.clamp(amount, 0, 1),	                azimuthDegrees = this.rhumbAzimuth(location1, location2),	                distanceRadians = this.rhumbDistance(location1, location2);	            return this.rhumbLocation(location1, azimuthDegrees, t * distanceRadians, result);	        };	        Location.rhumbAzimuth = function (location1, location2) {	            var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,	                lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,	                lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,	                lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,	                dLon,	                dPhi,	                azimuthRadians;	            if (lat1 == lat2 && lon1 == lon2) {	                return 0;	            }	            dLon = lon2 - lon1;	            dPhi = Math.log(Math.tan(lat2 / 2.0 + Math.PI / 4) / Math.tan(lat1 / 2.0 + Math.PI / 4));	            if (WWMath.fabs(dLon) > Math.PI) {	                dLon = dLon > 0 ? -(2 * Math.PI - dLon) : (2 * Math.PI + dLon);	            }	            azimuthRadians = Math.atan2(dLon, dPhi);	            return isNaN(azimuthRadians) ? 0 : azimuthRadians * Angle.RADIANS_TO_DEGREES;	        };	        Location.rhumbDistance = function (location1, location2) {	            var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,	                lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,	                lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,	                lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,	                dLat,	                dLon,	                dPhi,	                q,	                distanceRadians;	            if (lat1 == lat2 && lon1 == lon2) {	                return 0;	            }	            dLat = lat2 - lat1;	            dLon = lon2 - lon1;	            dPhi = Math.log(Math.tan(lat2 / 2.0 + Math.PI / 4) / Math.tan(lat1 / 2.0 + Math.PI / 4));	            q = dLat / dPhi;	            if (isNaN(dPhi) || isNaN(q)) {	                q = Math.cos(lat1);	            }	            if (WWMath.fabs(dLon) > Math.PI) {	                dLon = dLon > 0 ? -(2 * Math.PI - dLon) : (2 * Math.PI + dLon);	            }	            distanceRadians = Math.sqrt(dLat * dLat + q * q * dLon * dLon);	            return isNaN(distanceRadians) ? 0 : distanceRadians;	        };	        Location.rhumbLocation = function (location, azimuthDegrees, pathLengthRadians, result) {	            if (pathLengthRadians == 0) {	                result.latitude = location.latitude;	                result.longitude = location.longitude;	                return result;	            }	            var latRadians = location.latitude * Angle.DEGREES_TO_RADIANS,	                lonRadians = location.longitude * Angle.DEGREES_TO_RADIANS,	                azimuthRadians = azimuthDegrees * Angle.DEGREES_TO_RADIANS,	                endLatRadians = latRadians + pathLengthRadians * Math.cos(azimuthRadians),	                dPhi = Math.log(Math.tan(endLatRadians / 2 + Math.PI / 4) / Math.tan(latRadians / 2 + Math.PI / 4)),	                q = (endLatRadians - latRadians) / dPhi,	                dLon,	                endLonRadians;	            if (isNaN(dPhi) || isNaN(q) || !isFinite(q)) {	                q = Math.cos(latRadians);	            }	            dLon = pathLengthRadians * Math.sin(azimuthRadians) / q;	            if (WWMath.fabs(endLatRadians) > Math.PI / 2)	            {	                endLatRadians = endLatRadians > 0 ? Math.PI - endLatRadians : -Math.PI - endLatRadians;	            }	            endLonRadians = WWMath.fmod(lonRadians + dLon + Math.PI, 2 * Math.PI) - Math.PI;	            if (isNaN(endLatRadians) || isNaN(endLonRadians)) {	                result.latitude = location.latitude;	                result.longitude = location.longitude;	            } else {	                result.latitude = Angle.normalizedDegreesLatitude(endLatRadians * Angle.RADIANS_TO_DEGREES);	                result.longitude = Angle.normalizedDegreesLongitude(endLonRadians * Angle.RADIANS_TO_DEGREES);	            }	            return result;	        };	        Location.interpolateLinear = function (amount, location1, location2, result) {	            if (location1.equals(location2)) {	                result.latitude = location1.latitude;	                result.longitude = location1.longitude;	                return result;	            }	            var t = WWMath.clamp(amount, 0, 1),	                azimuthDegrees = this.linearAzimuth(location1, location2),	                distanceRadians = this.linearDistance(location1, location2);	            return this.linearLocation(location1, azimuthDegrees, t * distanceRadians, result);	        };	        Location.linearAzimuth = function (location1, location2) {	            var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,	                lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,	                lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,	                lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,	                dLon,	                dPhi,	                azimuthRadians;	            if (lat1 == lat2 && lon1 == lon2) {	                return 0;	            }	            dLon = lon2 - lon1;	            dPhi = lat2 - lat1;	            if (WWMath.fabs(dLon) > Math.PI) {	                dLon = dLon > 0 ? -(2 * Math.PI - dLon) : (2 * Math.PI + dLon);	            }	            azimuthRadians = Math.atan2(dLon, dPhi);	            return isNaN(azimuthRadians) ? 0 : azimuthRadians * Angle.RADIANS_TO_DEGREES;	        };	        Location.linearDistance = function (location1, location2) {	            var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,	                lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,	                lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,	                lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,	                dLat,	                dLon,	                distanceRadians;	            if (lat1 == lat2 && lon1 == lon2) {	                return 0;	            }	            dLat = lat2 - lat1;	            dLon = lon2 - lon1;	            if (WWMath.fabs(dLon) > Math.PI) {	                dLon = dLon > 0 ? -(2 * Math.PI - dLon) : (2 * Math.PI + dLon);	            }	            distanceRadians = Math.sqrt(dLat * dLat + dLon * dLon);	            return isNaN(distanceRadians) ? 0 : distanceRadians;	        };	        Location.linearLocation = function (location, azimuthDegrees, pathLengthRadians, result) {	            if (pathLengthRadians == 0) {	                result.latitude = location.latitude;	                result.longitude = location.longitude;	                return result;	            }	            var latRadians = location.latitude * Angle.DEGREES_TO_RADIANS,	                lonRadians = location.longitude * Angle.DEGREES_TO_RADIANS,	                azimuthRadians = azimuthDegrees * Angle.DEGREES_TO_RADIANS,	                endLatRadians = latRadians + pathLengthRadians * Math.cos(azimuthRadians),	                endLonRadians;	            if (WWMath.fabs(endLatRadians) > Math.PI / 2)	            {	                endLatRadians = endLatRadians > 0 ? Math.PI - endLatRadians : -Math.PI - endLatRadians;	            }	            endLonRadians =	                WWMath.fmod(lonRadians + pathLengthRadians * Math.sin(azimuthRadians) + Math.PI, 2 * Math.PI) - Math.PI;	            if (isNaN(endLatRadians) || isNaN(endLonRadians)) {	                result.latitude = location.latitude;	                result.longitude = location.longitude;	            } else {	                result.latitude = Angle.normalizedDegreesLatitude(endLatRadians * Angle.RADIANS_TO_DEGREES);	                result.longitude = Angle.normalizedDegreesLongitude(endLonRadians * Angle.RADIANS_TO_DEGREES);	            }	            return result;	        };	        Location.locationsCrossDateLine = function(locations) {	            var pos = null;	            for (var idx = 0, len = locations.length; idx < len; idx += 1) {	                var posNext = locations[idx];	                if (pos != null) {	                    if (WWMath.signum(pos.longitude) != WWMath.signum(posNext.longitude)) {	                        var delta = Math.abs(pos.longitude - posNext.longitude);	                        if (delta > 180 && delta < 360)	                            return true;	                    }	                }	                pos = posNext;	            }	            return false;	        };	        Location.greatCircleArcExtremeLocations = function(locations) {	            var minLatLocation = null;	            var maxLatLocation = null;	            var lastLocation = null;	            for (var idx = 0, len = locations.length; idx < len; idx += 1) {	                var location = locations[idx];	                if (lastLocation != null) {	                    var extremes = Location.greatCircleArcExtremeForTwoLocations(lastLocation, location);	                    if (extremes == null) {	                        continue;	                    }	                    if (minLatLocation == null || minLatLocation.latitude > extremes[0].latitude) {	                        minLatLocation = extremes[0];	                    }	                    if (maxLatLocation == null || maxLatLocation.latitude < extremes[1].latitude) {	                        maxLatLocation = extremes[1];	                    }	                }	                lastLocation = location;	            }	            return [minLatLocation, maxLatLocation];	        };	        Location.greatCircleArcExtremeForTwoLocations = function(begin, end) {	            var idx, len, location; 	            var minLatLocation = null;	            var maxLatLocation = null;	            var minLat = 90;	            var maxLat = -90;	            var locations = [begin, end];	            for (idx = 0, len = locations.length; idx < len; idx += 1) {	                location = locations[idx];	                if (minLat >= location.latitude) {	                    minLat = location.latitude;	                    minLatLocation = location;	                }	                if (maxLat <= location.latitude) {	                    maxLat = location.latitude;	                    maxLatLocation = location;	                }	            }	            var greatArcAzimuth = Location.greatCircleAzimuth(begin, end);	            var greatArcDistance = Location.greatCircleDistance(begin, end);	            var greatCircleExtremes = Location.greatCircleExtremeLocationsUsingAzimuth(begin, greatArcAzimuth);	            for (idx = 0, len = greatCircleExtremes.length; idx < len; idx += 1) {	                location = greatCircleExtremes[idx];	                var az = Location.greatCircleAzimuth(begin, location);	                var d = Location.greatCircleDistance(begin, location);	                if (WWMath.signum(az) == WWMath.signum(greatArcAzimuth)) {	                    if (d >= 0 && d <= greatArcDistance) {	                        if (minLat >= location.latitude) {	                            minLat = location.latitude;	                            minLatLocation = location;	                        }	                        if (maxLat <= location.latitude) {	                            maxLat = location.latitude;	                            maxLatLocation = location;	                        }	                    }	                }	            }	            return [minLatLocation, maxLatLocation];	        };	        Location.greatCircleExtremeLocationsUsingAzimuth = function(location, azimuth) {	            var lat0 = location.latitude;	            var az = azimuth * Angle.DEGREES_TO_RADIANS;	            var tanDistance = -Math.tan(lat0) / Math.cos(az);	            var distance = Math.atan(tanDistance);	            var extremeDistance1 = distance + (Math.PI / 2.0);	            var extremeDistance2 = distance - (Math.PI / 2.0);	            return [	                Location.greatCircleLocation(location, azimuth, extremeDistance1, new Location(0, 0)),	                Location.greatCircleLocation(location, azimuth, extremeDistance2, new Location(0,0))	            ];	        };	        Location.intersectionWithMeridian = function(p1, p2, meridian, globe) {	            var pt1 = globe.computePointFromLocation(p1.latitude, p1.longitude, new Vec3(0, 0, 0));	            var pt2 = globe.computePointFromLocation(p2.latitude, p2.longitude, new Vec3(0, 0, 0));	            var northPole = globe.computePointFromLocation(90, meridian, new Vec3(0, 0, 0));	            var pointOnEquator = globe.computePointFromLocation(0, meridian, new Vec3(0, 0, 0));	            var plane = Plane.fromPoints(northPole, pointOnEquator, Vec3.ZERO);	            var intersectionPoint = new Vec3(0, 0, 0);	            if (!plane.intersectsSegmentAt(pt1, pt2, intersectionPoint)) {	                return null;	            }	            var pos = new WorldWind.Position(0, 0, 0);	            globe.computePositionFromPoint(intersectionPoint[0], intersectionPoint[1], intersectionPoint[2], pos);	            return pos.latitude;	        };	        Location.poles = {	            'NONE': 0,	            'NORTH': 1,	            'SOUTH': 2	        };	        return Location;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(11),	        __webpack_require__(7),	        __webpack_require__(15),	        __webpack_require__(9),	        __webpack_require__(20),	        __webpack_require__(16)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,	              ArgumentError,	              Line,	              Logger,	              Rectangle,	              Vec3) {	        "use strict";	        var WWMath = {	            clamp: function (value, minimum, maximum) {	                return value < minimum ? minimum : value > maximum ? maximum : value;	            },	            interpolate: function (amount, value1, value2) {	                return (1 - amount) * value1 + amount * value2;	            },	            cbrt: function (x) {	                if (typeof Math.cbrt == 'function') {	                    return Math.cbrt(x);	                } else {	                    return Math.pow(x, 1 / 3);	                }	            },	            computeEllipsoidalGlobeIntersection: function (line, equatorialRadius, polarRadius, result) {	                var vx = line.direction[0],	                    vy = line.direction[1],	                    vz = line.direction[2],	                    sx = line.origin[0],	                    sy = line.origin[1],	                    sz = line.origin[2],	                    m = equatorialRadius / polarRadius, 	                    m2 = m * m,	                    r2 = equatorialRadius * equatorialRadius, 	                    a = vx * vx + m2 * vy * vy + vz * vz,	                    b = 2 * (sx * vx + m2 * sy * vy + sz * vz),	                    c = sx * sx + m2 * sy * sy + sz * sz - r2,	                    d = b * b - 4 * a * c, 	                    t;	                if (d < 0) {	                    return false;	                }	                else {	                    t = (-b - Math.sqrt(d)) / (2 * a);	                    result[0] = sx + vx * t;	                    result[1] = sy + vy * t;	                    result[2] = sz + vz * t;	                    return true;	                }	            },	            computeTriangleIntersection: function (line, vertex0, vertex1, vertex2, result) {	                var vx = line.direction[0],	                    vy = line.direction[1],	                    vz = line.direction[2],	                    sx = line.origin[0],	                    sy = line.origin[1],	                    sz = line.origin[2],	                    EPSILON = 0.00001;	                var edge1x = vertex1[0] - vertex0[0],	                    edge1y = vertex1[1] - vertex0[1],	                    edge1z = vertex1[2] - vertex0[2],	                    edge2x = vertex2[0] - vertex0[0],	                    edge2y = vertex2[1] - vertex0[1],	                    edge2z = vertex2[2] - vertex0[2];	                var px = (vy * edge2z) - (vz * edge2y),	                    py = (vz * edge2x) - (vx * edge2z),	                    pz = (vx * edge2y) - (vy * edge2x);	                var det = edge1x * px + edge1y * py + edge1z * pz; 	                if (det > -EPSILON && det < EPSILON) { 	                    return false;	                }	                var inv_det = 1.0 / det;	                var tx = sx - vertex0[0],	                    ty = sy - vertex0[1],	                    tz = sz - vertex0[2];	                var u = inv_det * (tx * px + ty * py + tz * pz);	                if (u < -EPSILON || u > 1 + EPSILON) {	                    return false;	                }	                var qx = (ty * edge1z) - (tz * edge1y),	                    qy = (tz * edge1x) - (tx * edge1z),	                    qz = (tx * edge1y) - (ty * edge1x);	                var v = inv_det * (vx * qx + vy * qy + vz * qz);	                if (v < -EPSILON || u + v > 1 + EPSILON) {	                    return false;	                }	                var t = inv_det * (edge2x * qx + edge2y * qy + edge2z * qz);	                if (t < 0) {	                    return false;	                } else {	                    result[0] = sx + vx * t;	                    result[1] = sy + vy * t;	                    result[2] = sz + vz * t;	                    return true;	                }	            },	            computeIndexedTrianglesIntersection: function (line, points, indices, results) {	                var v0 = new Vec3(0, 0, 0),	                    v1 = new Vec3(0, 0, 0),	                    v2 = new Vec3(0, 0, 0),	                    iPoint = new Vec3(0, 0, 0);	                for (var i = 0, len = indices.length; i < len; i += 3) {	                    var i0 = 3 * indices[i],	                        i1 = 3 * indices[i + 1],	                        i2 = 3 * indices[i + 2];	                    v0[0] = points[i0];	                    v0[1] = points[i0 + 1];	                    v0[2] = points[i0 + 2];	                    v1[0] = points[i1];	                    v1[1] = points[i1 + 1];	                    v1[2] = points[i1 + 2];	                    v2[0] = points[i2];	                    v2[1] = points[i2 + 1];	                    v2[2] = points[i2 + 2];	                    if (WWMath.computeTriangleIntersection(line, v0, v1, v2, iPoint)) {	                        results.push(iPoint);	                        iPoint = new Vec3(0, 0, 0);	                    }	                }	                return results.length > 0;	            },	            computeTriStripIntersections: function (line, points, indices, results) {	                var vx = line.direction[0],	                    vy = line.direction[1],	                    vz = line.direction[2],	                    sx = line.origin[0],	                    sy = line.origin[1],	                    sz = line.origin[2],	                    vert0x, vert0y, vert0z,	                    vert1x, vert1y, vert1z,	                    vert2x, vert2y, vert2z,	                    edge1x, edge1y, edge1z,	                    edge2x, edge2y, edge2z,	                    px, py, pz,	                    tx, ty, tz,	                    qx, qy, qz,	                    u, v, t,	                    det, inv_det,	                    index,	                    EPSILON = 0.00001;	                index = 3 * indices[0];	                vert1x = points[index++];	                vert1y = points[index++];	                vert1z = points[index];	                index = 3 * indices[1];	                vert2x = points[index++];	                vert2y = points[index++];	                vert2z = points[index];	                for (var i = 2, len = indices.length; i < len; i++) {	                    vert0x = vert1x;	                    vert0y = vert1y;	                    vert0z = vert1z;	                    vert1x = vert2x;	                    vert1y = vert2y;	                    vert1z = vert2z;	                    index = 3 * indices[i];	                    vert2x = points[index++];	                    vert2y = points[index++];	                    vert2z = points[index];	                    edge1x = vert1x - vert0x;	                    edge1y = vert1y - vert0y;	                    edge1z = vert1z - vert0z;	                    edge2x = vert2x - vert0x;	                    edge2y = vert2y - vert0y;	                    edge2z = vert2z - vert0z;	                    px = (vy * edge2z) - (vz * edge2y);	                    py = (vz * edge2x) - (vx * edge2z);	                    pz = (vx * edge2y) - (vy * edge2x);	                    det = edge1x * px + edge1y * py + edge1z * pz; 	                    if (det > -EPSILON && det < EPSILON) { 	                        continue;	                    }	                    inv_det = 1.0 / det;	                    tx = sx - vert0x;	                    ty = sy - vert0y;	                    tz = sz - vert0z;	                    u = inv_det * (tx * px + ty * py + tz * pz);	                    if (u < -EPSILON || u > 1 + EPSILON) {	                        continue;	                    }	                    qx = (ty * edge1z) - (tz * edge1y);	                    qy = (tz * edge1x) - (tx * edge1z);	                    qz = (tx * edge1y) - (ty * edge1x);	                    v = inv_det * (vx * qx + vy * qy + vz * qz);	                    if (v < -EPSILON || u + v > 1 + EPSILON) {	                        continue;	                    }	                    t = inv_det * (edge2x * qx + edge2y * qy + edge2z * qz);	                    if (t >= 0) {	                        results.push(new Vec3(sx + vx * t, sy + vy * t, sz + vz * t));	                    }	                }	            },	            fabs: function (a) {	                return a >= 0 ? a : -a;	            },	            fmod: function (number, modulus) {	                return modulus === 0 ? 0 : number - Math.floor(number / modulus) * modulus;	            },	            fract: function (number) {	                return number - Math.floor(number);	            },	            mod: function (number, modulus) {	                return ((number % modulus) + modulus) % modulus;	            },	            max: function (value1, value2) {	                return value1 > value2 ? value1 : value2;	            },	            localCoordinateAxesAtPoint: function (origin, globe, xAxisResult, yAxisResult, zAxisResult) {	                var x = origin[0],	                    y = origin[1],	                    z = origin[2];	                globe.surfaceNormalAtPoint(x, y, z, zAxisResult);	                globe.northTangentAtPoint(x, y, z, yAxisResult);	                xAxisResult.set(yAxisResult[0], yAxisResult[1], yAxisResult[2]);	                xAxisResult.cross(zAxisResult);	                xAxisResult.normalize();	                yAxisResult.set(zAxisResult[0], zAxisResult[1], zAxisResult[2]);	                yAxisResult.cross(xAxisResult);	                yAxisResult.normalize();	            },	            horizonDistanceForGlobeRadius: function (radius, altitude) {	                return (radius > 0 && altitude > 0) ? Math.sqrt(altitude * (2 * radius + altitude)) : 0;	            },	            perspectiveNearDistanceForFarDistance: function (farDistance, farResolution, depthBits) {	                var maxDepthValue = (1 << depthBits) - 1;	                return farDistance / (maxDepthValue / (1 - farResolution / farDistance) - maxDepthValue + 1);	            },	            perspectiveNearDistance: function (viewportWidth, viewportHeight, distanceToSurface) {	                var aspectRatio = viewportHeight / viewportWidth;	                return 2 * distanceToSurface / Math.sqrt(aspectRatio * aspectRatio + 5);	            },	            perspectiveFrustumRectangle: function (viewportWidth, viewportHeight, distance) {	                var width = distance,	                    height = distance * viewportHeight / viewportWidth;	                return new Rectangle(-width / 2, -height / 2, width, height);	            },	            perspectivePixelSize: function (viewportWidth, viewportHeight, distance) {	                var frustumHeight = WWMath.perspectiveFrustumRectangle(viewportWidth, viewportHeight, distance).height;	                return frustumHeight / viewportHeight;	            },	            boundingRectForUnitQuad: function (transformMatrix) {	                var m = transformMatrix,	                    x1 = m[3],	                    y1 = m[7],	                    x2 = m[0] + m[3],	                    y2 = m[4] + m[7],	                    x3 = m[1] + m[3],	                    y3 = m[5] + m[7],	                    x4 = m[0] + m[1] + m[3],	                    y4 = m[4] + m[5] + m[7],	                    minX = Math.min(Math.min(x1, x2), Math.min(x3, x4)),	                    maxX = Math.max(Math.max(x1, x2), Math.max(x3, x4)),	                    minY = Math.min(Math.min(y1, y2), Math.min(y3, y4)),	                    maxY = Math.max(Math.max(y1, y2), Math.max(y3, y4));	                return new Rectangle(minX, minY, maxX - minX, maxY - minY);	            },	            isPowerOfTwo: function (value) {	                return value != 0 && (value & (value - 1)) === 0;	            },	            signum: function (value) {	                return value > 0 ? 1 : value < 0 ? -1 : 0;	            },	            gudermannianInverse: function (latitude) {	                return Math.log(Math.tan(Math.PI / 4 + (latitude * Angle.DEGREES_TO_RADIANS) / 2)) / Math.PI;	            },	            epsg3857ToEpsg4326: function (easting, northing) {	                var r = 6.3781e6,	                    latRadians = (Math.PI / 2) - 2 * Math.atan(Math.exp(-northing / r)),	                    lonRadians = easting / r;	                return [	                    WWMath.clamp(latRadians * Angle.RADIANS_TO_DEGREES, -90, 90),	                    WWMath.clamp(lonRadians * Angle.RADIANS_TO_DEGREES, -180, 180)	                ];	            },	            powerOfTwoFloor: function (value) {	                var power = Math.floor(Math.log(value) / Math.log(2));	                return Math.pow(2, power);	            }	        };	        return WWMath;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(9)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Logger) {	        "use strict";	        var Rectangle = function (x, y, width, height) {	            this.x = x;	            this.y = y;	            this.width = width;	            this.height = height;	        };	        Rectangle.prototype.set = function(x, y, width, height) {	            this.x = x;	            this.y = y;	            this.width = width;	            this.height = height;	        };	        Rectangle.prototype.getMinX = function () {	            return this.x;	        };	        Rectangle.prototype.getMinY = function () {	            return this.y;	        };	        Rectangle.prototype.getMaxX = function () {	            return this.x + this.width;	        };	        Rectangle.prototype.getMaxY = function () {	            return this.y + this.height;	        };	        Rectangle.prototype.containsPoint = function (point) {	            return point[0] >= this.x && point[0] <= (this.x + this.width)	                && point[1] >= this.y && point[1] <= (this.y + this.height);	        };	        Rectangle.prototype.intersects = function (that) {	            if ((that.x + that.width) < this.x)	                return false;	            if (that.x > (this.x + this.width))	                return false;	            if ((that.y + that.height) < this.y)	                return false;	            if (that.y > (this.y + this.height))	                return false;	            return true;	        };	        Rectangle.prototype.intersectsRectangles = function (rectangles) {	            if (rectangles) {	                for (var i = 0; i < rectangles.length; i++){	                    if (this.intersects(rectangles[i])) {	                        return true;	                    }	                }	            }	            return false;	        };	        Rectangle.prototype.toString = function () {	            return this.x + ", " + this.y + ", " + this.width + ", " + this.height;	        };	        return Rectangle;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(9),	        __webpack_require__(19)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Logger,	              WWMath) {	        "use strict";	        var Texture = function (gl, image, wrapMode) {	            if (!wrapMode) {	                wrapMode = gl.CLAMP_TO_EDGE;	            }	            var textureId = gl.createTexture(),	                isPowerOfTwo = (WWMath.isPowerOfTwo(image.width) && WWMath.isPowerOfTwo(image.height));	            this.originalImageWidth = image.width;	            this.originalImageHeight = image.height;	            if (wrapMode === gl.REPEAT && !isPowerOfTwo) {	                image = this.resizeImage(image);	                isPowerOfTwo = true;	            }	            this.imageWidth = image.width;	            this.imageHeight = image.height;	            this.size = image.width * image.height * 4;	            gl.bindTexture(gl.TEXTURE_2D, textureId);	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER,	                isPowerOfTwo ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER,	                gl.LINEAR);	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapMode);	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapMode);	            var ext = (	            gl.getExtension("EXT_texture_filter_anisotropic") ||	            gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic"));	            if (ext) {	                gl.texParameteri(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, 4);	            }	            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);	            gl.texImage2D(gl.TEXTURE_2D, 0,	                gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);	            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);	            if (isPowerOfTwo) {	                gl.generateMipmap(gl.TEXTURE_2D);	            }	            this.textureId = textureId;	            this.creationTime = new Date();	        };	        Texture.prototype.dispose = function (gl) {	            gl.deleteTexture(this.textureId);	            delete this.textureId;	        };	        Texture.prototype.bind = function (dc) {	            dc.currentGlContext.bindTexture(dc.currentGlContext.TEXTURE_2D, this.textureId);	            dc.frameStatistics.incrementTextureLoadCount(1);	            return true;	        };	        Texture.prototype.resizeImage = function (image) {	            var canvas = document.createElement("canvas");	            canvas.width = WWMath.powerOfTwoFloor(image.width);	            canvas.height = WWMath.powerOfTwoFloor(image.height);	            var ctx = canvas.getContext("2d");	            ctx.drawImage(image, 0, 0, canvas.width, canvas.height);	            return canvas;	        };	        return Texture;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(9),	        __webpack_require__(13),	        __webpack_require__(23),	        __webpack_require__(17),	        __webpack_require__(25),	        __webpack_require__(16),	        __webpack_require__(19)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Logger,	              Matrix,	              NavigatorState,	              Position,	              UnsupportedOperationError,	              Vec3,	              WWMath) {	        "use strict";	        var Navigator = function (worldWindow) {	            this.worldWindow = worldWindow;	            this.heading = 0;	            this.tilt = 0;	            this.roll = 0;	            this.nearDistance = 1;	            this.farDistance = 10e6;	        };	        Navigator.prototype.currentState = function () {	            throw new UnsupportedOperationError(	                Logger.logMessage(Logger.LEVEL_SEVERE, "Navigator", "currentState", "abstractInvocation"));	        };	        Navigator.prototype.currentStateForModelview = function (modelviewMatrix) {	            var globe = this.worldWindow.globe,	                globeRadius = WWMath.max(globe.equatorialRadius, globe.polarRadius),	                eyePoint = modelviewMatrix.extractEyePoint(new Vec3(0, 0, 0)),	                eyePos = globe.computePositionFromPoint(eyePoint[0], eyePoint[1], eyePoint[2], new Position(0, 0, 0)),	                viewport = this.worldWindow.viewport,	                viewDepthBits = this.worldWindow.depthBits,	                distanceToSurface,	                maxNearDistance,	                projectionMatrix = Matrix.fromIdentity();	            this.farDistance = WWMath.horizonDistanceForGlobeRadius(globeRadius, eyePos.altitude);	            if (this.farDistance < 1e3)	                this.farDistance = 1e3;	            this.nearDistance = WWMath.perspectiveNearDistanceForFarDistance(this.farDistance, 10, viewDepthBits);	            distanceToSurface = eyePos.altitude - globe.elevationAtLocation(eyePos.latitude, eyePos.longitude);	            if (distanceToSurface > 0) {	                maxNearDistance = WWMath.perspectiveNearDistance(viewport.width, viewport.height, distanceToSurface);	                if (this.nearDistance > maxNearDistance)	                    this.nearDistance = maxNearDistance;	            }	            if (this.nearDistance < 1)	                this.nearDistance = 1;	            projectionMatrix.setToPerspectiveProjection(viewport.width, viewport.height, this.nearDistance, this.farDistance);	            return new NavigatorState(modelviewMatrix, projectionMatrix, viewport, this.heading, this.tilt);	        };	        return Navigator;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(12),	        __webpack_require__(15),	        __webpack_require__(9),	        __webpack_require__(13),	        __webpack_require__(20),	        __webpack_require__(24),	        __webpack_require__(16),	        __webpack_require__(19)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Frustum,	              Line,	              Logger,	              Matrix,	              Rectangle,	              Vec2,	              Vec3,	              WWMath) {	        "use strict";	        var NavigatorState = function (modelViewMatrix, projectionMatrix, viewport, heading, tilt) {	            this.modelview = modelViewMatrix;	            this.projection = projectionMatrix;	            this.modelviewProjection = Matrix.fromIdentity();	            this.modelviewProjection.setToMultiply(projectionMatrix, modelViewMatrix);	            this.viewport = viewport;	            this.heading = heading;	            this.tilt = tilt;	            this.eyePoint = this.modelview.extractEyePoint(new Vec3(0, 0, 0));	            this.frustumInModelCoordinates = null;	            var modelviewTranspose = Matrix.fromIdentity();	            modelviewTranspose.setToTransposeOfMatrix(this.modelview);	            this.frustumInModelCoordinates = Frustum.fromProjectionMatrix(this.projection);	            this.frustumInModelCoordinates.transformByMatrix(modelviewTranspose);	            this.frustumInModelCoordinates.normalize();	            this.modelviewInv = Matrix.fromIdentity();	            this.modelviewInv.invertOrthonormalMatrix(this.modelview);	            this.projectionInv = Matrix.fromIdentity();	            this.projectionInv.invertMatrix(this.projection);	            this.modelviewProjectionInv = Matrix.fromIdentity();	            this.modelviewProjectionInv.invertMatrix(this.modelviewProjection);	            this.modelviewNormalTransform = Matrix.fromIdentity().setToTransposeOfMatrix(this.modelviewInv.upper3By3());	            var nbl = new Vec3(-1, -1, -1),	                ntr = new Vec3(+1, +1, -1),	                fbl = new Vec3(-1, -1, +1),	                ftr = new Vec3(+1, +1, +1);	            nbl.multiplyByMatrix(this.projectionInv);	            ntr.multiplyByMatrix(this.projectionInv);	            fbl.multiplyByMatrix(this.projectionInv);	            ftr.multiplyByMatrix(this.projectionInv);	            var nrRectWidth = WWMath.fabs(ntr[0] - nbl[0]),	                frRectWidth = WWMath.fabs(ftr[0] - fbl[0]),	                nrDistance = -nbl[2],	                frDistance = -fbl[2];	            var frustumWidthScale = (frRectWidth - nrRectWidth) / (frDistance - nrDistance),	                frustumWidthOffset = nrRectWidth - frustumWidthScale * nrDistance;	            this.pixelSizeScale = frustumWidthScale / viewport.width;	            this.pixelSizeOffset = frustumWidthOffset / viewport.height;	        };	        NavigatorState.prototype.project = function (modelPoint, result) {	            var mx = modelPoint[0],	                my = modelPoint[1],	                mz = modelPoint[2],	                m = this.modelviewProjection,	                x = m[0] * mx + m[1] * my + m[2] * mz + m[3],	                y = m[4] * mx + m[5] * my + m[6] * mz + m[7],	                z = m[8] * mx + m[9] * my + m[10] * mz + m[11],	                w = m[12] * mx + m[13] * my + m[14] * mz + m[15],	                viewport = this.viewport;	            if (w == 0) {	                return false;	            }	            x /= w;	            y /= w;	            z /= w;	            if (z < -1 || z > 1) {	                return false;	            }	            x = x * 0.5 + 0.5;	            y = y * 0.5 + 0.5;	            z = z * 0.5 + 0.5;	            x = x * viewport.width + viewport.x;	            y = y * viewport.height + viewport.y;	            result[0] = x;	            result[1] = y;	            result[2] = z;	            return true;	        };	        NavigatorState.prototype.projectWithDepth = function (modelPoint, depthOffset, result) {	            var mx = modelPoint[0],	                my = modelPoint[1],	                mz = modelPoint[2],	                m = this.modelview,	                ex = m[0] * mx + m[1] * my + m[2] * mz + m[3],	                ey = m[4] * mx + m[5] * my + m[6] * mz + m[7],	                ez = m[8] * mx + m[9] * my + m[10] * mz + m[11],	                ew = m[12] * mx + m[13] * my + m[14] * mz + m[15];	            var p = this.projection,	                x = p[0] * ex + p[1] * ey + p[2] * ez + p[3] * ew,	                y = p[4] * ex + p[5] * ey + p[6] * ez + p[7] * ew,	                z = p[8] * ex + p[9] * ey + p[10] * ez + p[11] * ew,	                w = p[12] * ex + p[13] * ey + p[14] * ez + p[15] * ew,	                viewport = this.viewport;	            if (w === 0) {	                return false;	            }	            x /= w;	            y /= w;	            z /= w;	            if (z < -1 || z > 1) {	                return false;	            }	            z = p[8] * ex + p[9] * ey + p[10] * ez * (1 + depthOffset) + p[11] * ew;	            z /= w;	            z = WWMath.clamp(z, -1, 1);	            x = x * 0.5 + 0.5;	            y = y * 0.5 + 0.5;	            z = z * 0.5 + 0.5;	            x = x * viewport.width + viewport.x;	            y = y * viewport.height + viewport.y;	            result[0] = x;	            result[1] = y;	            result[2] = z;	            return true;	        };	        NavigatorState.prototype.unProject = function (screenPoint, result) {	            var sx = screenPoint[0],	                sy = screenPoint[1],	                sz = screenPoint[2],	                viewport = this.viewport;	            sx = (sx - viewport.x) / viewport.width;	            sy = (sy - viewport.y) / viewport.height;	            sx = sx * 2 - 1;	            sy = sy * 2 - 1;	            sz = sz * 2 - 1;	            if (sz < -1 || sz > 1) {	                return false;	            }	            var m = this.modelviewProjectionInv,	                x = m[0] * sx + m[1] * sy + m[2] * sz + m[3],	                y = m[4] * sx + m[5] * sy + m[6] * sz + m[7],	                z = m[8] * sx + m[9] * sy + m[10] * sz + m[11],	                w = m[12] * sx + m[13] * sy + m[14] * sz + m[15];	            if (w === 0) {	                return false;	            }	            result[0] = x / w;	            result[1] = y / w;	            result[2] = z / w;	            return true;	        };	        NavigatorState.prototype.convertPointToWindow = function (screenPoint, result) {	            result[0] = screenPoint[0];	            result[1] = this.viewport.height - screenPoint[1];	            return result;	        };	        NavigatorState.prototype.convertPointToViewport = function (point, result) {	            result[0] = point[0];	            result[1] = this.viewport.height - point[1];	            return result;	        };	        NavigatorState.prototype.rayFromScreenPoint = function (point) {	            var screenPoint = this.convertPointToViewport(point, new Vec3(0, 0, 0)),	                nearPoint = new Vec3(0, 0, 0),	                farPoint = new Vec3(0, 0, 0);	            if (!this.unProject(screenPoint, nearPoint)) {	                return null;	            }	            screenPoint[2] = 1;	            if (!this.unProject(screenPoint, farPoint)) {	                return null;	            }	            var origin = new Vec3(this.eyePoint[0], this.eyePoint[1], this.eyePoint[2]),	                direction = new Vec3(farPoint[0], farPoint[1], farPoint[2]);	            direction.subtract(nearPoint);	            direction.normalize();	            return new Line(origin, direction);	        };	        NavigatorState.prototype.pixelSizeAtDistance = function (distance) {	            return this.pixelSizeScale * distance + this.pixelSizeOffset;	        };	        return NavigatorState;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(9),	        __webpack_require__(7),	        __webpack_require__(16)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Logger,	              ArgumentError,	              Vec3) {	        "use strict";	        var Vec2 = function Vec2(x, y) {	            this[0] = x;	            this[1] = y;	        };	        Vec2.prototype = new Float64Array(2);	        Vec2.prototype.set = function (x, y) {	            this[0] = x;	            this[1] = y;	            return this;	        };	        Vec2.prototype.copy = function (vector) {	            this[0] = vector[0];	            this[1] = vector[1];	            return this;	        };	        Vec2.prototype.equals = function (vector) {	            return this[0] === vector[0] && this[1] === vector[1];	        };	        Vec2.average = function (vectors, result) {	            var count = vectors.length,	                vec;	            result[0] = 0;	            result[1] = 0;	            for (var i = 0, len = vectors.length; i < len; i++) {	                vec = vectors[i];	                result[0] += vec[0] / count;	                result[1] += vec[1] / count;	            }	            return result;	        };	        Vec2.prototype.add = function (addend) {	            this[0] += addend[0];	            this[1] += addend[1];	            return this;	        };	        Vec2.prototype.subtract = function (subtrahend) {	            this[0] -= subtrahend[0];	            this[1] -= subtrahend[1];	            return this;	        };	        Vec2.prototype.multiply = function (scalar) {	            this[0] *= scalar;	            this[1] *= scalar;	            return this;	        };	        Vec2.prototype.divide = function (divisor) {	            this[0] /= divisor;	            this[1] /= divisor;	            return this;	        };	        Vec2.prototype.mix = function (vector, weight) {	            var w0 = 1 - weight,	                w1 = weight;	            this[0] = this[0] * w0 + vector[0] * w1;	            this[1] = this[1] * w0 + vector[1] * w1;	            return this;	        };	        Vec2.prototype.negate = function () {	            this[0] = -this[0];	            this[1] = -this[1];	            return this;	        };	        Vec2.prototype.dot = function (vector) {	            return this[0] * vector[0] + this[1] * vector[1];	        };	        Vec2.prototype.magnitudeSquared = function () {	            return this.dot(this);	        };	        Vec2.prototype.magnitude = function () {	            return Math.sqrt(this.magnitudeSquared());	        };	        Vec2.prototype.normalize = function () {	            var magnitude = this.magnitude(),	                magnitudeInverse = 1 / magnitude;	            this[0] *= magnitudeInverse;	            this[1] *= magnitudeInverse;	            return this;	        };	        Vec2.prototype.distanceToSquared = function (vector) {	            var dx = this[0] - vector[0],	                dy = this[1] - vector[1];	            return dx * dx + dy * dy;	        };	        Vec2.prototype.distanceTo = function (vector) {	            return Math.sqrt(this.distanceToSquared(vector));	        };	        Vec2.prototype.toVec3 = function () {	            return new Vec3(this[0], this[1], 0);	        };	        Vec2.prototype.swap = function (that) {	            var tmp = this[0];	            this[0] = that[0];	            that[0] = tmp;	            tmp = this[1];	            this[1] = that[1];	            that[1] = tmp;	            return this;	        };	        Vec2.prototype.toString = function () {	            return "(" + this[0] + ", " + this[1] + ")";	        };	        return Vec2;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbstractError) {	        "use strict";	        var UnsupportedOperationError = function (message) {	            AbstractError.call(this, "UnsupportedOperationError", message);	            var stack;	            try {	                throw new Error();	            } catch (e) {	                stack = e.stack;	            }	            this.stack = stack;	        };	        UnsupportedOperationError.prototype = Object.create(AbstractError.prototype);	        return UnsupportedOperationError;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function (GestureRecognizer) {	        "use strict";	        var DragRecognizer = function (target, callback) {	            GestureRecognizer.call(this, target, callback);	            this.button = 0;	            this.interpretDistance = 5;	        };	        DragRecognizer.prototype = Object.create(GestureRecognizer.prototype);	        DragRecognizer.prototype.mouseMove = function (event) {	            if (this.state == WorldWind.POSSIBLE) {	                if (this.shouldInterpret()) {	                    if (this.shouldRecognize()) {	                        this.translationX = 0; 	                        this.translationY = 0;	                        this.state = WorldWind.BEGAN;	                    } else {	                        this.state = WorldWind.FAILED;	                    }	                }	            } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {	                this.state = WorldWind.CHANGED;	            }	        };	        DragRecognizer.prototype.mouseUp = function (event) {	            if (this.mouseButtonMask == 0) { 	                if (this.state == WorldWind.POSSIBLE) {	                    this.state = WorldWind.FAILED;	                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {	                    this.state = WorldWind.ENDED;	                }	            }	        };	        DragRecognizer.prototype.touchStart = function (touch) {	            if (this.state == WorldWind.POSSIBLE) {	                this.state = WorldWind.FAILED; 	            }	        };	        DragRecognizer.prototype.shouldInterpret = function () {	            var dx = this.translationX,	                dy = this.translationY,	                distance = Math.sqrt(dx * dx + dy * dy);	            return distance > this.interpretDistance; 	        };	        DragRecognizer.prototype.shouldRecognize = function () {	            var buttonBit = (1 << this.button);	            return buttonBit == this.mouseButtonMask; 	        };	        return DragRecognizer;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function (GestureRecognizer) {	        "use strict";	        var PinchRecognizer = function (target, callback) {	            GestureRecognizer.call(this, target, callback);	            this._scale = 1;	            this._offsetScale = 1;	            this.referenceDistance = 0;	            this.interpretThreshold = 20;	            this.weight = 0.4;	            this.pinchTouches = [];	        };	        PinchRecognizer.prototype = Object.create(GestureRecognizer.prototype);	        Object.defineProperties(PinchRecognizer.prototype, {	            scale: {	                get: function () {	                    return this._scale * this._offsetScale;	                }	            }	        });	        PinchRecognizer.prototype.reset = function () {	            GestureRecognizer.prototype.reset.call(this);	            this._scale = 1;	            this._offsetScale = 1;	            this.referenceDistance = 0;	            this.pinchTouches = [];	        };	        PinchRecognizer.prototype.mouseDown = function (event) {	            if (this.state == WorldWind.POSSIBLE) {	                this.state = WorldWind.FAILED; 	            }	        };	        PinchRecognizer.prototype.touchStart = function (touch) {	            if (this.pinchTouches.length < 2) {	                if (this.pinchTouches.push(touch) == 2) {	                    this.referenceDistance = this.currentPinchDistance();	                    this._offsetScale *= this._scale;	                    this._scale = 1;	                }	            }	        };	        PinchRecognizer.prototype.touchMove = function (touch) {	            if (this.pinchTouches.length == 2) {	                if (this.state == WorldWind.POSSIBLE) {	                    if (this.shouldRecognize()) {	                        this.state = WorldWind.BEGAN;	                    }	                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {	                    var distance = this.currentPinchDistance(),	                        newScale = Math.abs(distance / this.referenceDistance),	                        w = this.weight;	                    this._scale = this._scale * (1 - w) + newScale * w;	                    this.state = WorldWind.CHANGED;	                }	            }	        };	        PinchRecognizer.prototype.touchEnd = function (touch) {	            var index = this.pinchTouches.indexOf(touch);	            if (index != -1) {	                this.pinchTouches.splice(index, 1);	            }	            if (this.touchCount == 0) { 	                if (this.state == WorldWind.POSSIBLE) {	                    this.state = WorldWind.FAILED;	                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {	                    this.state = WorldWind.ENDED;	                }	            }	        };	        PinchRecognizer.prototype.touchCancel = function (touch) {	            var index = this.pinchTouches.indexOf(touch);	            if (index != -1) {	                this.pinchTouches.splice(index, 1);	            }	            if (this.touchCount == 0) {	                if (this.state == WorldWind.POSSIBLE) {	                    this.state = WorldWind.FAILED;	                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {	                    this.state = WorldWind.CANCELLED;	                }	            }	        };	        PinchRecognizer.prototype.prepareToRecognize = function () {	            this.referenceDistance = this.currentPinchDistance();	            this._scale = 1;	        };	        PinchRecognizer.prototype.shouldRecognize = function () {	            var distance = this.currentPinchDistance();	            return Math.abs(distance - this.referenceDistance) > this.interpretThreshold	        };	        PinchRecognizer.prototype.currentPinchDistance = function () {	            var touch0 = this.pinchTouches[0],	                touch1 = this.pinchTouches[1],	                dx = touch0.clientX - touch1.clientX,	                dy = touch0.clientY - touch1.clientY;	            return Math.sqrt(dx * dx + dy * dy);	        };	        return PinchRecognizer;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(11),	        __webpack_require__(6)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,	              GestureRecognizer) {	        "use strict";	        var RotationRecognizer = function (target, callback) {	            GestureRecognizer.call(this, target, callback);	            this._rotation = 0;	            this._offsetRotation = 0;	            this.referenceAngle = 0;	            this.interpretThreshold = 20;	            this.weight = 0.4;	            this.rotationTouches = [];	        };	        RotationRecognizer.prototype = Object.create(GestureRecognizer.prototype);	        Object.defineProperties(RotationRecognizer.prototype, {	            rotation: {	                get: function () {	                    return this._rotation + this._offsetRotation;	                }	            }	        });	        RotationRecognizer.prototype.reset = function () {	            GestureRecognizer.prototype.reset.call(this);	            this._rotation = 0;	            this._offsetRotation = 0;	            this.referenceAngle = 0;	            this.rotationTouches = [];	        };	        RotationRecognizer.prototype.mouseDown = function (event) {	            if (this.state == WorldWind.POSSIBLE) {	                this.state = WorldWind.FAILED; 	            }	        };	        RotationRecognizer.prototype.touchStart = function (touch) {	            if (this.rotationTouches.length < 2) {	                if (this.rotationTouches.push(touch) == 2) {	                    this.referenceAngle = this.currentTouchAngle();	                    this._offsetRotation += this._rotation;	                    this._rotation = 0;	                }	            }	        };	        RotationRecognizer.prototype.touchMove = function (touch) {	            if (this.rotationTouches.length == 2) {	                if (this.state == WorldWind.POSSIBLE) {	                    if (this.shouldRecognize()) {	                        this.state = WorldWind.BEGAN;	                    }	                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {	                    var angle = this.currentTouchAngle(),	                        newRotation = Angle.normalizedDegrees(angle - this.referenceAngle),	                        w = this.weight;	                    this._rotation = this._rotation * (1 - w) + newRotation * w;	                    this.state = WorldWind.CHANGED;	                }	            }	        };	        RotationRecognizer.prototype.touchEnd = function (touch) {	            var index = this.rotationTouches.indexOf(touch);	            if (index != -1) {	                this.rotationTouches.splice(index, 1);	            }	            if (this.touchCount == 0) { 	                if (this.state == WorldWind.POSSIBLE) {	                    this.state = WorldWind.FAILED;	                } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {	                    this.state = WorldWind.ENDED;	                }	            }	        };	        RotationRecognizer.prototype.touchCancel = function (touch) {	            var index = this.rotationTouches.indexOf(touch);	            if (index != -1) {	                this.rotationTouches.splice(index, 1);	                if (this.touchCount == 0) {	                    if (this.state == WorldWind.POSSIBLE) {	                        this.state = WorldWind.FAILED;	                    } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {	                        this.state = WorldWind.CANCELLED;	                    }	                }	            }	        };	        RotationRecognizer.prototype.prepareToRecognize = function () {	            this.referenceAngle = this.currentTouchAngle();	            this._rotation = 0;	        };	        RotationRecognizer.prototype.shouldRecognize = function () {	            var angle = this.currentTouchAngle(),	                rotation = Angle.normalizedDegrees(angle - this.referenceAngle);	            return Math.abs(rotation) > this.interpretThreshold;	        };	        RotationRecognizer.prototype.currentTouchAngle = function () {	            var touch0 = this.rotationTouches[0],	                touch1 = this.rotationTouches[1],	                dx = touch0.clientX - touch1.clientX,	                dy = touch0.clientY - touch1.clientY;	            return Math.atan2(dy, dx) * Angle.RADIANS_TO_DEGREES;	        };	        return RotationRecognizer;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = function (PanRecognizer) {	        "use strict";	        var TiltRecognizer = function (target, callback) {	            PanRecognizer.call(this, target, callback);	            this.maxTouchDistance = 250;	            this.maxTouchDivergence = 50;	        };	        TiltRecognizer.LEFT = (1 << 0);	        TiltRecognizer.RIGHT = (1 << 1);	        TiltRecognizer.UP = (1 << 2);	        TiltRecognizer.DOWN = (1 << 3);	        TiltRecognizer.prototype = Object.create(PanRecognizer.prototype);	        TiltRecognizer.prototype.shouldInterpret = function () {	            for (var i = 0, count = this.touchCount; i < count; i++) {	                var touch = this.touch(i),	                    dx = touch.translationX,	                    dy = touch.translationY,	                    distance = Math.sqrt(dx * dx + dy * dy);	                if (distance > this.interpretDistance) {	                    return true; 	                }	            }	            return false;	        };	        TiltRecognizer.prototype.shouldRecognize = function () {	            var touchCount = this.touchCount;	            if (touchCount < 2) {	                return false;	            }	            var touch0 = this.touch(0),	                touch1 = this.touch(1),	                dx = touch0.clientX - touch1.clientX,	                dy = touch0.clientY - touch1.clientY,	                distance = Math.sqrt(dx * dx + dy * dy);	            if (distance > this.maxTouchDistance) {	                return false; 	            }	            var tx = touch0.translationX - touch1.translationX,	                ty = touch0.translationY - touch1.translationY,	                divergence = Math.sqrt(tx * tx + ty * ty);	            if (divergence > this.maxTouchDivergence) {	                return false; 	            }	            var verticalMask = TiltRecognizer.UP | TiltRecognizer.DOWN,	                dirMask0 = this.touchDirection(touch0) & verticalMask,	                dirMask1 = this.touchDirection(touch1) & verticalMask;	            return (dirMask0 & dirMask1) != 0; 	        };	        TiltRecognizer.prototype.touchDirection = function (touch) {	            var dx = touch.translationX,	                dy = touch.translationY,	                dirMask = 0;	            if (Math.abs(dx) > Math.abs(dy)) {	                dirMask |= (dx < 0 ? TiltRecognizer.LEFT : 0);	                dirMask |= (dx > 0 ? TiltRecognizer.RIGHT : 0);	            } else {	                dirMask |= (dy < 0 ? TiltRecognizer.UP : 0);	                dirMask |= (dy > 0 ? TiltRecognizer.DOWN : 0);	            }	            return dirMask;	        };	        return TiltRecognizer;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(18),	        __webpack_require__(31),	        __webpack_require__(32),	        __webpack_require__(47)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Location,	              Sector,	              ElevationModel,	              WmsUrlBuilder) {	        "use strict";	        var EarthElevationModel = function () {	            ElevationModel.call(this,	                Sector.FULL_SPHERE, new Location(45, 45), 12, "application/bil16", "EarthElevations256", 256, 256);	            this.displayName = "Earth Elevation Model";	            this.minElevation = -11000; 	            this.maxElevation = 8850; 	            this.pixelIsPoint = false; 	            this.urlBuilder = new WmsUrlBuilder("https://worldwind26.arc.nasa.gov/elev",	                "GEBCO,aster_v2,USGS-NED", "", "1.3.0");	        };	        EarthElevationModel.prototype = Object.create(ElevationModel.prototype);	        return EarthElevationModel;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(11),	        __webpack_require__(7),	        __webpack_require__(18),	        __webpack_require__(9),	        __webpack_require__(16),	        __webpack_require__(19)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,	              ArgumentError,	              Location,	              Logger,	              Vec3,	              WWMath) {	        "use strict";	        var Sector = function (minLatitude, maxLatitude, minLongitude, maxLongitude) {	            this.minLatitude = minLatitude;	            this.maxLatitude = maxLatitude;	            this.minLongitude = minLongitude;	            this.maxLongitude = maxLongitude;	        };	        Sector.ZERO = new Sector(0, 0, 0, 0);	        Sector.FULL_SPHERE = new Sector(-90, 90, -180, 180);	        Sector.prototype.copy = function (sector) {	            this.minLatitude = sector.minLatitude;	            this.maxLatitude = sector.maxLatitude;	            this.minLongitude = sector.minLongitude;	            this.maxLongitude = sector.maxLongitude;	            return this;	        };	        Sector.prototype.isEmpty = function () {	            return this.minLatitude === this.maxLatitude && this.minLongitude === this.maxLongitude;	        };	        Sector.prototype.deltaLatitude = function () {	            return this.maxLatitude - this.minLatitude;	        };	        Sector.prototype.deltaLongitude = function () {	            return this.maxLongitude - this.minLongitude;	        };	        Sector.prototype.centroidLatitude = function () {	            return 0.5 * (this.minLatitude + this.maxLatitude);	        };	        Sector.prototype.centroidLongitude = function () {	            return 0.5 * (this.minLongitude + this.maxLongitude);	        };	        Sector.prototype.centroid = function (result) {	            result.latitude = this.centroidLatitude();	            result.longitude = this.centroidLongitude();	            return result;	        };	        Sector.prototype.minLatitudeRadians = function () {	            return this.minLatitude * Angle.DEGREES_TO_RADIANS;	        };	        Sector.prototype.maxLatitudeRadians = function () {	            return this.maxLatitude * Angle.DEGREES_TO_RADIANS;	        };	        Sector.prototype.minLongitudeRadians = function () {	            return this.minLongitude * Angle.DEGREES_TO_RADIANS;	        };	        Sector.prototype.maxLongitudeRadians = function () {	            return this.maxLongitude * Angle.DEGREES_TO_RADIANS;	        };	        Sector.prototype.setToBoundingSector = function (locations) {	            var minLatitude = 90,	                maxLatitude = -90,	                minLongitude = 180,	                maxLongitude = -180;	            for (var idx = 0, len = locations.length; idx < len; idx += 1) {	                var location = locations[idx];	                if (!location) {	                    continue;	                }	                minLatitude = Math.min(minLatitude, location.latitude);	                maxLatitude = Math.max(maxLatitude, location.latitude);	                minLongitude = Math.min(minLongitude, location.longitude);	                maxLongitude = Math.max(maxLongitude, location.longitude);	            }	            this.minLatitude = minLatitude;	            this.maxLatitude = maxLatitude;	            this.minLongitude = minLongitude;	            this.maxLongitude = maxLongitude;	            return this;	        };	        Sector.splitBoundingSectors = function(locations) {	            var minLat = 90;	            var minLon = 180;	            var maxLat = -90;	            var maxLon = -180;	            var lastLocation = null;	            for (var idx = 0, len = locations.length; idx < len; idx += 1) {	                var location = locations[idx];	                var lat = location.latitude;	                if (lat < minLat) {	                    minLat = lat;	                }	                if (lat > maxLat) {	                    maxLat = lat;	                }	                var lon = location.longitude;	                if (lon >= 0 && lon < minLon) {	                    minLon = lon;	                }	                if (lon <= 0 && lon > maxLon) {	                    maxLon = lon;	                }	                if (lastLocation != null) {	                    var lastLon = lastLocation.longitude;	                    if (WWMath.signum(lon) != WWMath.signum(lastLon)) {	                        if (Math.abs(lon - lastLon) < 180) {	                            maxLon = 0;	                            minLon = 0;	                        }	                    }	                }	                lastLocation = location;	            }	            if (minLat === maxLat && minLon === maxLon) {	                return null;	            }	            return [	                new Sector(minLat, maxLat, minLon, 180), 	                new Sector(minLat, maxLat, -180, maxLon) 	            ];	        };	        Sector.prototype.intersects = function (sector) {	            return sector	                && this.minLongitude <= sector.maxLongitude	                && this.maxLongitude >= sector.minLongitude	                && this.minLatitude <= sector.maxLatitude	                && this.maxLatitude >= sector.minLatitude;	        };	        Sector.prototype.overlaps = function (sector) {	            return sector	                && this.minLongitude < sector.maxLongitude	                && this.maxLongitude > sector.minLongitude	                && this.minLatitude < sector.maxLatitude	                && this.maxLatitude > sector.minLatitude;	        };	        Sector.prototype.contains = function (sector) {	            return sector	                && this.minLatitude <= sector.minLatitude	                && this.maxLatitude >= sector.maxLatitude	                && this.minLongitude <= sector.minLongitude	                && this.maxLongitude >= sector.maxLongitude;	        };	        Sector.prototype.containsLocation = function (latitude, longitude) {	            return this.minLatitude <= latitude	                && this.maxLatitude >= latitude	                && this.minLongitude <= longitude	                && this.maxLongitude >= longitude;	        };	        Sector.prototype.intersection = function (sector) {	            if (this.minLatitude < sector.minLatitude)	                this.minLatitude = sector.minLatitude;	            if (this.maxLatitude > sector.maxLatitude)	                this.maxLatitude = sector.maxLatitude;	            if (this.minLongitude < sector.minLongitude)	                this.minLongitude = sector.minLongitude;	            if (this.maxLongitude > sector.maxLongitude)	                this.maxLongitude = sector.maxLongitude;	            if (this.maxLatitude < this.minLatitude)	                this.maxLatitude = this.minLatitude;	            if (this.maxLongitude < this.minLongitude)	                this.maxLongitude = this.minLongitude;	            return this;	        };	        Sector.prototype.union = function (sector) {	            if (this.minLatitude > sector.minLatitude)	                this.minLatitude = sector.minLatitude;	            if (this.maxLatitude < sector.maxLatitude)	                this.maxLatitude = sector.maxLatitude;	            if (this.minLongitude > sector.minLongitude)	                this.minLongitude = sector.minLongitude;	            if (this.maxLongitude < sector.maxLongitude)	                this.maxLongitude = sector.maxLongitude;	            return this;	        };	        return Sector;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(33),	        __webpack_require__(11),	        __webpack_require__(7),	        __webpack_require__(34),	        __webpack_require__(35),	        __webpack_require__(44),	        __webpack_require__(9),	        __webpack_require__(46),	        __webpack_require__(31),	        __webpack_require__(36),	        __webpack_require__(19)], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbsentResourceList,	              Angle,	              ArgumentError,	              ElevationImage,	              ElevationTile,	              LevelSet,	              Logger,	              MemoryCache,	              Sector,	              Tile,	              WWMath) {	        "use strict";	        var ElevationModel = function (coverageSector, levelZeroDelta, numLevels, retrievalImageFormat, cachePath,	                                       tileWidth, tileHeight) {	            this.coverageSector = coverageSector;	            this.retrievalImageFormat = retrievalImageFormat;	            this.cachePath = cachePath;	            this.displayName = "Elevations";	            this.timestamp = Date.now();	            this.minElevation = 0;	            this.maxElevation = 0;	            this.pixelIsPoint = true;	            this.levels = new LevelSet(this.coverageSector, levelZeroDelta, numLevels, tileWidth, tileHeight);	            this.currentTiles = []; 	            this.currentSector = new Sector(0, 0, 0, 0); 	            this.tileCache = new MemoryCache(1000000, 800000); 	            this.imageCache = new MemoryCache(10000000, 8000000); 	            this.currentRetrievals = []; 	            this.absentResourceList = new AbsentResourceList(3, 5e3);	            this.id = ++ElevationModel.idPool;	            this.stateKey = "elevationModel " + this.id.toString() + " ";	        };	        ElevationModel.idPool = 0; 	        ElevationModel.prototype.minAndMaxElevationsForSector = function (sector) {	            var level = this.levels.levelForTexelSize(sector.deltaLatitude() * Angle.DEGREES_TO_RADIANS / 64);	            this.assembleTiles(level, sector, false);	            if (this.currentTiles.length == 0) {	                return null; 	            }	            var min = Number.MAX_VALUE,	                max = -min,	                image,	                imageMin,	                imageMax,	                result = [];	            for (var i = 0, len = this.currentTiles.length; i < len; i++) {	                image = this.currentTiles[i].image();	                if (image) {	                    imageMin = image.minElevation;	                    if (min > imageMin) {	                        min = imageMin;	                    }	                    imageMax = image.maxElevation;	                    if (max < imageMax) {	                        max = imageMax;	                    }	                } else {	                    result[0] = this.minElevation;	                    result[1] = this.maxElevation;	                    return result; 	                }	            }	            result[0] = min;	            result[1] = max;	            return result;	        };	        ElevationModel.prototype.elevationAtLocation = function (latitude, longitude) {	            if (!this.coverageSector.containsLocation(latitude, longitude)) {	                return 0; 	            }	            return this.pointElevationForLocation(latitude, longitude);	        };	        ElevationModel.prototype.elevationsForGrid = function (sector, numLat, numLon, targetResolution, result) {	            var level = this.levels.levelForTexelSize(targetResolution);	            if (this.pixelIsPoint) {	                return this.pointElevationsForGrid(sector, numLat, numLon, level, result);	            } else {	                return this.areaElevationsForGrid(sector, numLat, numLon, level, result);	            }	        };	        ElevationModel.prototype.pointElevationForLocation = function (latitude, longitude) {	            var level = this.levels.lastLevel(),	                deltaLat = level.tileDelta.latitude,	                deltaLon = level.tileDelta.longitude,	                r = Tile.computeRow(deltaLat, latitude),	                c = Tile.computeColumn(deltaLon, longitude),	                tile,	                image = null;	            for (var i = level.levelNumber; i >= 0; i--) {	                tile = this.tileCache.entryForKey(i + "." + r + "." + c);	                if (tile) {	                    image = tile.image();	                    if (image) {	                        return image.elevationAtLocation(latitude, longitude);	                    }	                }	                r = Math.floor(r / 2);	                c = Math.floor(c / 2);	            }	            return 0; 	        };	        ElevationModel.prototype.pointElevationsForGrid = function (sector, numLat, numLon, level, result) {	            var maxResolution = 0,	                resolution;	            this.assembleTiles(level, sector, true);	            if (this.currentTiles.length === 0) {	                return 0; 	            }	            this.currentTiles.sort(function (tileA, tileB) {	                return tileA.level.levelNumber - tileB.level.levelNumber;	            });	            for (var i = 0, len = this.currentTiles.length; i < len; i++) {	                var tile = this.currentTiles[i],	                    image = tile.image();	                if (image) {	                    image.elevationsForGrid(sector, numLat, numLon, result);	                    resolution = tile.level.texelSize;	                    if (maxResolution < resolution) {	                        maxResolution = resolution;	                    }	                } else {	                    maxResolution = Number.MAX_VALUE;	                }	            }	            return maxResolution;	        };	        ElevationModel.prototype.areaElevationsForGrid = function (sector, numLat, numLon, level, result) {	            var minLat = sector.minLatitude,	                maxLat = sector.maxLatitude,	                minLon = sector.minLongitude,	                maxLon = sector.maxLongitude,	                deltaLat = sector.deltaLatitude() / (numLat > 1 ? numLat - 1 : 1),	                deltaLon = sector.deltaLongitude() / (numLon > 1 ? numLon - 1 : 1),	                lat, lon, s, t,	                latIndex, lonIndex, resultIndex = 0;	            for (latIndex = 0, lat = minLat; latIndex < numLat; latIndex += 1, lat += deltaLat) {	                if (latIndex === numLat - 1) {	                    lat = maxLat; 	                }	                for (lonIndex = 0, lon = minLon; lonIndex < numLon; lonIndex += 1, lon += deltaLon) {	                    if (lonIndex === numLon - 1) {	                        lon = maxLon; 	                    }	                    if (this.coverageSector.containsLocation(lat, lon)) { 	                        s = (lon + 180) / 360;	                        t = (lat + 90) / 180;	                        this.areaElevationForCoord(s, t, level.levelNumber, result, resultIndex);	                    }	                    resultIndex++;	                }	            }	            return level.texelSize; 	        };	        ElevationModel.prototype.areaElevationForCoord = function (s, t, levelNumber, result, resultIndex) {	            var level, levelWidth, levelHeight,	                tMin, tMax,	                vMin, vMax,	                u, v,	                x0, x1, y0, y1,	                xf, yf,	                retrieveTiles,	                pixels = new Float64Array(4);	            for (var i = levelNumber; i >= 0; i--) {	                level = this.levels.level(i);	                levelWidth = Math.round(level.tileWidth * 360 / level.tileDelta.longitude);	                levelHeight = Math.round(level.tileHeight * 180 / level.tileDelta.latitude);	                tMin = 1 / (2 * levelHeight);	                tMax = 1 - tMin;	                vMin = 0;	                vMax = levelHeight - 1;	                u = levelWidth * WWMath.fract(s); 	                v = levelHeight * WWMath.clamp(t, tMin, tMax); 	                x0 = WWMath.mod(Math.floor(u - 0.5), levelWidth);	                x1 = WWMath.mod((x0 + 1), levelWidth);	                y0 = WWMath.clamp(Math.floor(v - 0.5), vMin, vMax);	                y1 = WWMath.clamp(y0 + 1, vMin, vMax);	                xf = WWMath.fract(u - 0.5);	                yf = WWMath.fract(v - 0.5);	                retrieveTiles = (i == levelNumber) || (i == 0);	                if (this.lookupPixels(x0, x1, y0, y1, level, retrieveTiles, pixels)) {	                    result[resultIndex] = (1 - xf) * (1 - yf) * pixels[0] +	                        xf * (1 - yf) * pixels[1] +	                        (1 - xf) * yf * pixels[2] +	                        xf * yf * pixels[3];	                    return;	                }	            }	        };	        ElevationModel.prototype.lookupPixels = function (x0, x1, y0, y1, level, retrieveTiles, result) {	            var levelNumber = level.levelNumber,	                tileWidth = level.tileWidth,	                tileHeight = level.tileHeight,	                row0 = Math.floor(y0 / tileHeight),	                row1 = Math.floor(y1 / tileHeight),	                col0 = Math.floor(x0 / tileWidth),	                col1 = Math.floor(x1 / tileWidth),	                r0c0, r0c1, r1c0, r1c1;	            if (row0 == row1 && row0 == this.cachedRow && col0 == col1 && col0 == this.cachedCol) {	                r0c0 = r0c1 = r1c0 = r1c1 = this.cachedImage; 	            } else if (row0 == row1 && col0 == col1) {	                r0c0 = this.lookupImage(levelNumber, row0, col0, retrieveTiles); 	                r0c1 = r1c0 = r1c1 = r0c0; 	                this.cachedRow = row0;	                this.cachedCol = col0;	                this.cachedImage = r0c0; 	            } else {	                r0c0 = this.lookupImage(levelNumber, row0, col0, retrieveTiles);	                r0c1 = this.lookupImage(levelNumber, row0, col1, retrieveTiles);	                r1c0 = this.lookupImage(levelNumber, row1, col0, retrieveTiles);	                r1c1 = this.lookupImage(levelNumber, row1, col1, retrieveTiles);	            }	            if (r0c0 && r0c1 && r1c0 && r1c1) {	                result[0] = r0c0.pixel(x0 % tileWidth, y0 % tileHeight);	                result[1] = r0c1.pixel(x1 % tileWidth, y0 % tileHeight);	                result[2] = r1c0.pixel(x0 % tileWidth, y1 % tileHeight);	                result[3] = r1c1.pixel(x1 % tileWidth, y1 % tileHeight);	                return true;	            }	            return false;	        };	        ElevationModel.prototype.lookupImage = function (levelNumber, row, column, retrieveTiles) {	            var tile = this.tileForLevel(levelNumber, row, column),	                image = tile.image();	            if (image == null && retrieveTiles) {	                this.retrieveTileImage(tile);	            }	            return image;	        };	        ElevationModel.prototype.createTile = function (sector, level, row, column) {	            var imagePath = this.cachePath + "/" + level.levelNumber + "/" + row + "/" + row + "_" + column + ".bil";	            return new ElevationTile(sector, level, row, column, imagePath, this.imageCache);	        };	        ElevationModel.prototype.assembleTiles = function (level, sector, retrieveTiles) {	            this.currentTiles = [];	            this.currentSector.copy(sector);	            this.currentSector.intersection(this.coverageSector);	            if (this.currentSector.isEmpty())	                return; 	            var deltaLat = level.tileDelta.latitude,	                deltaLon = level.tileDelta.longitude,	                firstRow = Tile.computeRow(deltaLat, this.currentSector.minLatitude),	                lastRow = Tile.computeLastRow(deltaLat, this.currentSector.maxLatitude),	                firstCol = Tile.computeColumn(deltaLon, this.currentSector.minLongitude),	                lastCol = Tile.computeLastColumn(deltaLon, this.currentSector.maxLongitude);	            for (var row = firstRow; row <= lastRow; row++) {	                for (var col = firstCol; col <= lastCol; col++) {	                    this.addTileOrAncestor(level, row, col, retrieveTiles);	                }	            }	        };	        ElevationModel.prototype.addTileOrAncestor = function (level, row, column, retrieveTiles) {	            var tile = this.tileForLevel(level.levelNumber, row, column);	            if (this.isTileImageInMemory(tile)) {	                this.addToCurrentTiles(tile);	            } else {	                if (retrieveTiles) {	                    this.retrieveTileImage(tile);	                }	                if (level.isFirstLevel()) {	                    this.currentTiles.push(tile); 	                } else {	                    this.addAncestor(level, row, column, retrieveTiles);	                }	            }	        };	        ElevationModel.prototype.addAncestor = function (level, row, column, retrieveTiles) {	            var tile = null,	                r = Math.floor(row / 2),	                c = Math.floor(column / 2);	            for (var i = level.levelNumber - 1; i >= 0; i--) {	                tile = this.tileForLevel(i, r, c);	                if (this.isTileImageInMemory(tile)) {	                    this.addToCurrentTiles(tile);	                    return;	                }	                r = Math.floor(r / 2);	                c = Math.floor(c / 2);	            }	            this.addToCurrentTiles(tile);	            if (retrieveTiles) {	                this.retrieveTileImage(tile);	            }	        };	        ElevationModel.prototype.addToCurrentTiles = function (tile) {	            this.currentTiles.push(tile);	        };	        ElevationModel.prototype.tileForLevel = function (levelNumber, row, column) {	            var tileKey = levelNumber + "." + row + "." + column,	                tile = this.tileCache.entryForKey(tileKey);	            if (tile) {	                return tile;	            }	            var level = this.levels.level(levelNumber),	                sector = Tile.computeSector(level, row, column);	            tile = this.createTile(sector, level, row, column);	            this.tileCache.putEntry(tileKey, tile, tile.size());	            return tile;	        };	        ElevationModel.prototype.isTileImageInMemory = function (tile) {	            return this.imageCache.containsKey(tile.imagePath);	        };	        ElevationModel.prototype.resourceUrlForTile = function (tile) {	            return this.urlBuilder.urlForTile(tile, this.retrievalImageFormat);	        };	        ElevationModel.prototype.retrieveTileImage = function (tile) {	            if (this.currentRetrievals.indexOf(tile.imagePath) < 0) {	                var url = this.resourceUrlForTile(tile, this.retrievalImageFormat),	                    xhr = new XMLHttpRequest(),	                    elevationModel = this;	                if (!url)	                    return;	                xhr.open("GET", url, true);	                xhr.responseType = 'arraybuffer';	                xhr.onreadystatechange = function () {	                    if (xhr.readyState === 4) {	                        elevationModel.removeFromCurrentRetrievals(tile.imagePath);	                        var contentType = xhr.getResponseHeader("content-type");	                        if (xhr.status === 200) {	                            if (contentType === elevationModel.retrievalImageFormat	                                || contentType === "text/plain"	                                || contentType === "application/octet-stream") {	                                Logger.log(Logger.LEVEL_INFO, "Elevations retrieval succeeded: " + url);	                                elevationModel.loadElevationImage(tile, xhr);	                                elevationModel.absentResourceList.unmarkResourceAbsent(tile.imagePath);	                                var e = document.createEvent('Event');	                                e.initEvent(WorldWind.REDRAW_EVENT_TYPE, true, true);	                                window.dispatchEvent(e);	                            } else if (contentType === "text/xml") {	                                elevationModel.absentResourceList.markResourceAbsent(tile.imagePath);	                                Logger.log(Logger.LEVEL_WARNING,	                                    "Elevations retrieval failed (" + xhr.statusText + "): " + url + ".\n "	                                    + String.fromCharCode.apply(null, new Uint8Array(xhr.response)));	                            } else {	                                elevationModel.absentResourceList.markResourceAbsent(tile.imagePath);	                                Logger.log(Logger.LEVEL_WARNING,	                                    "Elevations retrieval failed: " + url + ". " + "Unexpected content type "	                                    + contentType);	                            }	                        } else {	                            elevationModel.absentResourceList.markResourceAbsent(tile.imagePath);	                            Logger.log(Logger.LEVEL_WARNING,	                                "Elevations retrieval failed (" + xhr.statusText + "): " + url);	                        }	                    }	                };	                xhr.onerror = function () {	                    elevationModel.removeFromCurrentRetrievals(tile.imagePath);	                    elevationModel.absentResourceList.markResourceAbsent(tile.imagePath);	                    Logger.log(Logger.LEVEL_WARNING, "Elevations retrieval failed: " + url);	                };	                xhr.ontimeout = function () {	                    elevationModel.removeFromCurrentRetrievals(tile.imagePath);	                    elevationModel.absentResourceList.markResourceAbsent(tile.imagePath);	                    Logger.log(Logger.LEVEL_WARNING, "Elevations retrieval timed out: " + url);	                };	                xhr.send(null);	                this.currentRetrievals.push(tile.imagePath);	            }	        };	        ElevationModel.prototype.removeFromCurrentRetrievals = function (imagePath) {	            var index = this.currentRetrievals.indexOf(imagePath);	            if (index > -1) {	                this.currentRetrievals.splice(index, 1);	            }	        };	        ElevationModel.prototype.loadElevationImage = function (tile, xhr) {	            var elevationImage = new ElevationImage(tile.imagePath, tile.sector, tile.tileWidth, tile.tileHeight);	            if (this.retrievalImageFormat == "application/bil16") {	                elevationImage.imageData = new Int16Array(xhr.response);	                elevationImage.size = elevationImage.imageData.length * 2;	            } else if (this.retrievalImageFormat == "application/bil32") {	                elevationImage.imageData = new Float32Array(xhr.response);	                elevationImage.size = elevationImage.imageData.length * 4;	            }	            if (elevationImage.imageData) {	                elevationImage.findMinAndMaxElevation();	                this.imageCache.putEntry(tile.imagePath, elevationImage, elevationImage.size);	                this.timestamp = Date.now();	            }	        };	        return ElevationModel;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {	        "use strict";	        var AbsentResourceList = function (maxTrys, minCheckInterval) {	            this.maxTrys = maxTrys;	            this.minCheckInterval = minCheckInterval;	            this.tryAgainInterval = 60e3; 	            this.possiblyAbsent = {};	        };	        AbsentResourceList.prototype.isResourceAbsent = function (resourceId) {	            var entry = this.possiblyAbsent[resourceId];	            if (!entry) {	                return false;	            }	            if (entry.permanent) {	                return true;	            }	            var timeSinceLastMark = Date.now() - entry.timeOfLastMark;	            if (timeSinceLastMark > this.tryAgainInterval) {	                delete this.possiblyAbsent[resourceId];	                return false;	            }	            return timeSinceLastMark < this.minCheckInterval || entry.numTrys > this.maxTrys;	        };	        AbsentResourceList.prototype.markResourceAbsent = function (resourceId) {	            var entry = this.possiblyAbsent[resourceId];	            if (!entry) {	                entry = {	                    timeOfLastMark: Date.now(),	                    numTrys: 0	                };	                this.possiblyAbsent[resourceId] = entry;	            }	            entry.numTrys = entry.numTrys + 1;	            entry.timeOfLastMark = Date.now();	        };	        AbsentResourceList.prototype.markResourceAbsentPermanently = function (resourceId) {	            var entry = this.possiblyAbsent[resourceId];	            if (!entry) {	                entry = {	                    timeOfLastMark: Date.now(),	                    numTrys: 0	                };	                this.possiblyAbsent[resourceId] = entry;	            }	            entry.numTrys = entry.numTrys + 1;	            entry.timeOfLastMark = Date.now();	            entry.permanent = true;	        };	        AbsentResourceList.prototype.unmarkResourceAbsent = function (resourceId) {	            var entry = this.possiblyAbsent[resourceId];	            if (entry) {	                delete this.possiblyAbsent[resourceId];	            }	        };	        return AbsentResourceList;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(9),	        __webpack_require__(19)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Logger,	              WWMath) {	        "use strict";	        var ElevationImage = function (imagePath, sector, imageWidth, imageHeight) {	            if (!imagePath || (imagePath.length < 1)) {	                throw new ArgumentError(	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationImage", "constructor",	                        "The specified image path is null, undefined or zero length."));	            }	            this.sector = sector;	            this.imagePath = imagePath;	            this.imageWidth = imageWidth;	            this.imageHeight = imageHeight;	            this.size = this.imageWidth * this.imageHeight;	        };	        ElevationImage.prototype.pixel = function (x, y) {	            if (x < 0 || x >= this.imageWidth) {	                return 0;	            }	            if (y < 0 || y >= this.imageHeight) {	                return 0;	            }	            y = this.imageHeight - y - 1; 	            return this.imageData[x + y * this.imageWidth];	        };	        ElevationImage.prototype.elevationAtLocation = function (latitude, longitude) {	            var maxLat = this.sector.maxLatitude,	                minLon = this.sector.minLongitude,	                deltaLat = this.sector.deltaLatitude(),	                deltaLon = this.sector.deltaLongitude(),	                x = (this.imageWidth - 1) * (longitude - minLon) / deltaLon,	                y = (this.imageHeight - 1) * (maxLat - latitude) / deltaLat,	                x0 = Math.floor(WWMath.clamp(x, 0, this.imageWidth - 1)),	                x1 = Math.floor(WWMath.clamp(x0 + 1, 0, this.imageWidth - 1)),	                y0 = Math.floor(WWMath.clamp(y, 0, this.imageHeight - 1)),	                y1 = Math.floor(WWMath.clamp(y0 + 1, 0, this.imageHeight - 1)),	                pixels = this.imageData,	                x0y0 = pixels[x0 + y0 * this.imageWidth],	                x1y0 = pixels[x1 + y0 * this.imageWidth],	                x0y1 = pixels[x0 + y1 * this.imageWidth],	                x1y1 = pixels[x1 + y1 * this.imageWidth],	                xf = x - x0,	                yf = y - y0;	            return (1 - xf) * (1 - yf) * x0y0 +	                xf * (1 - yf) * x1y0 +	                (1 - xf) * yf * x0y1 +	                xf * yf * x1y1;	        };	        ElevationImage.prototype.elevationsForGrid = function (sector, numLat, numLon, result) {	            var minLatSelf = this.sector.minLatitude,	                maxLatSelf = this.sector.maxLatitude,	                minLonSelf = this.sector.minLongitude,	                maxLonSelf = this.sector.maxLongitude,	                deltaLatSelf = maxLatSelf - minLatSelf,	                deltaLonSelf = maxLonSelf - minLonSelf,	                minLat = sector.minLatitude,	                maxLat = sector.maxLatitude,	                minLon = sector.minLongitude,	                maxLon = sector.maxLongitude,	                deltaLat = (maxLat - minLat) / (numLat > 1 ? numLat - 1 : 1),	                deltaLon = (maxLon - minLon) / (numLon > 1 ? numLon - 1 : 1),	                lat, lon,	                i, j, index = 0,	                pixels = this.imageData;	            for (j = 0, lat = minLat; j < numLat; j += 1, lat += deltaLat) {	                if (j === numLat - 1) {	                    lat = maxLat; 	                }	                if (lat >= minLatSelf && lat <= maxLatSelf) {	                    var y = (this.imageHeight - 1) * (maxLatSelf - lat) / deltaLatSelf,	                        y0 = Math.floor(WWMath.clamp(y, 0, this.imageHeight - 1)),	                        y1 = Math.floor(WWMath.clamp(y0 + 1, 0, this.imageHeight - 1)),	                        yf = y - y0;	                    for (i = 0, lon = minLon; i < numLon; i += 1, lon += deltaLon) {	                        if (i === numLon - 1) {	                            lon = maxLon; 	                        }	                        if (lon >= minLonSelf && lon <= maxLonSelf) {	                            var x = (this.imageWidth - 1) * (lon - minLonSelf) / deltaLonSelf,	                                x0 = Math.floor(WWMath.clamp(x, 0, this.imageWidth - 1)),	                                x1 = Math.floor(WWMath.clamp(x0 + 1, 0, this.imageWidth - 1)),	                                xf = x - x0;	                            var x0y0 = pixels[x0 + y0 * this.imageWidth],	                                x1y0 = pixels[x1 + y0 * this.imageWidth],	                                x0y1 = pixels[x0 + y1 * this.imageWidth],	                                x1y1 = pixels[x1 + y1 * this.imageWidth];	                            result[index] = (1 - xf) * (1 - yf) * x0y0 +	                            xf * (1 - yf) * x1y0 +	                            (1 - xf) * yf * x0y1 +	                            xf * yf * x1y1;	                        }	                        index++;	                    }	                } else {	                    index += numLon; 	                }	            }	        };	        ElevationImage.prototype.minAndMaxElevationsForSector = function (sector) {	            var result = [];	            if (!sector) { 	                result[0] = this.minElevation;	                result[1] = this.maxElevation;	            } else if (sector.contains(this.sector)) { 	                if (result[0] > this.minElevation) {	                    result[0] = this.minElevation;	                }	                if (result[1] < this.maxElevation) {	                    result[1] = this.maxElevation;	                }	            } else { 	                var maxLatSelf = this.sector.maxLatitude,	                    minLonSelf = this.sector.minLongitude,	                    deltaLatSelf = this.sector.deltaLatitude(),	                    deltaLonSelf = this.sector.deltaLongitude(),	                    minLatOther = sector.minLatitude,	                    maxLatOther = sector.maxLatitude,	                    minLonOther = sector.minLongitude,	                    maxLonOther = sector.maxLongitude;	                var minY = Math.floor((this.imageHeight - 1) * (maxLatSelf - maxLatOther) / deltaLatSelf),	                    maxY = Math.ceil((this.imageHeight - 1) * (maxLatSelf - minLatOther) / deltaLatSelf),	                    minX = Math.floor((this.imageWidth - 1) * (minLonOther - minLonSelf) / deltaLonSelf),	                    maxX = Math.ceil((this.imageWidth - 1) * (maxLonOther - minLonSelf) / deltaLonSelf);	                minY = WWMath.clamp(minY, 0, this.imageHeight - 1);	                maxY = WWMath.clamp(maxY, 0, this.imageHeight - 1);	                minX = WWMath.clamp(minX, 0, this.imageWidth - 1);	                maxX = WWMath.clamp(maxX, 0, this.imageWidth - 1);	                var pixels = this.imageData,	                    min = Number.MAX_VALUE,	                    max = -min;	                for (var y = minY; y <= maxY; y++) {	                    for (var x = minX; x <= maxX; x++) {	                        var p = pixels[Math.floor(x + y * this.imageWidth)];	                        if (min > p) {	                            min = p;	                        }	                        if (max < p) {	                            max = p;	                        }	                    }	                }	                if (result[0] > min) {	                    result[0] = min;	                }	                if (result[1] < max) {	                    result[1] = max;	                }	            }	            return result;	        };	        ElevationImage.prototype.findMinAndMaxElevation = function () {	            if (this.imageData && (this.imageData.length > 0)) {	                this.minElevation = Number.MAX_VALUE;	                this.maxElevation = -this.minElevation;	                var pixels = this.imageData,	                    pixelCount = this.imageWidth * this.imageHeight;	                for (var i = 0; i < pixelCount; i++) {	                    var p = pixels[i];	                    if (this.minElevation > p) {	                        this.minElevation = p;	                    }	                    if (this.maxElevation < p) {	                        this.maxElevation = p;	                    }	                }	            } else {	                this.minElevation = 0;	                this.maxElevation = 0;	            }	        };	        return ElevationImage;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(9),	        __webpack_require__(36)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Logger,	              Tile) {	        "use strict";	        var ElevationTile = function (sector, level, row, column, imagePath, cache) {	            if (!imagePath || (imagePath.length < 1)) {	                throw new ArgumentError(	                    Logger.logMessage(Logger.LEVEL_SEVERE, "ElevationTile", "constructor",	                        "The specified image path is null, undefined or zero length."));	            }	            Tile.call(this, sector, level, row, column); 	            this.imagePath = imagePath;	            this.memoryCache = cache;	        };	        ElevationTile.prototype = Object.create(Tile.prototype);	        ElevationTile.prototype.size = function () {	            return Tile.prototype.size.call(this) + this.imagePath.length + 8;	        };	        ElevationTile.prototype.image = function () {	            return this.memoryCache.entryForKey(this.imagePath);	        };	        return ElevationTile;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(37),	        __webpack_require__(9),	        __webpack_require__(31),	        __webpack_require__(16),	        __webpack_require__(43)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              BoundingBox,	              Logger,	              Sector,	              Vec3,	              WWUtil) {	        "use strict";	        var Tile = function (sector, level, row, column) {	            this.sector = sector;	            this.level = level;	            this.row = row;	            this.column = column;	            this.tileWidth = level.tileWidth;	            this.tileHeight = level.tileHeight;	            this.texelSize = level.texelSize;	            this.tileKey = level.levelNumber.toString() + "." + row.toString() + "." + column.toString();	            this.extent = null;	            this.referencePoint = null;	            this.opacity = 1;	            this.samplePoints = null;	            this.sampleElevations = null;	            this.updateTimestamp = null;	            this.updateVerticalExaggeration = null;	            this.updateGlobeStateKey = null;	        };	        Tile.prototype.isEqual = function (that) {	            if (!that)	                return false;	            if (!that.tileKey)	                return false;	            return this.tileKey == that.tileKey;	        };	        Tile.prototype.size = function () {	            return 4 	                + (4 + 32) 	                + 4 	                + 8 	                + 8 	                + (4 + 32) 	                + (4 + 676) 	                + 8 	                + (4 + 32) 	                + 8; 	        };	        Tile.prototype.distanceTo = function (vector) {	            var px = vector[0], py = vector[1], pz = vector[2],	                dx, dy, dz,	                points = this.samplePoints,	                distance = Number.POSITIVE_INFINITY;	            for (var i = 0, len = points.length; i < len; i += 3) {	                dx = px - points[i];	                dy = py - points[i + 1];	                dz = pz - points[i + 2];	                distance = Math.min(distance, dx * dx + dy * dy + dz * dz); 	            }	            return Math.sqrt(distance);	        };	        Tile.prototype.subdivide = function (level, tileFactory) {	            var latMin = this.sector.minLatitude,	                latMax = this.sector.maxLatitude,	                latMid = this.sector.centroidLatitude(),	                lonMin = this.sector.minLongitude,	                lonMax = this.sector.maxLongitude,	                lonMid = this.sector.centroidLongitude(),	                subRow,	                subCol,	                childSector,	                children = [];	            subRow = 2 * this.row;	            subCol = 2 * this.column;	            childSector = new Sector(latMin, latMid, lonMin, lonMid);	            children.push(tileFactory.createTile(childSector, level, subRow, subCol));	            subRow = 2 * this.row;	            subCol = 2 * this.column + 1;	            childSector = new Sector(latMin, latMid, lonMid, lonMax);	            children.push(tileFactory.createTile(childSector, level, subRow, subCol));	            subRow = 2 * this.row + 1;	            subCol = 2 * this.column;	            childSector = new Sector(latMid, latMax, lonMin, lonMid);	            children.push(tileFactory.createTile(childSector, level, subRow, subCol));	            subRow = 2 * this.row + 1;	            subCol = 2 * this.column + 1;	            childSector = new Sector(latMid, latMax, lonMid, lonMax);	            children.push(tileFactory.createTile(childSector, level, subRow, subCol));	            return children;	        };	        Tile.prototype.subdivideToCache = function (level, tileFactory, cache) {	            var childList = cache ? cache.entryForKey(this.tileKey) : null;	            if (!childList) {	                childList = this.subdivide(level, tileFactory);	                if (childList && cache) {	                    cache.putEntry(this.tileKey, childList, 4 * childList[0].size());	                }	            }	            return childList;	        };	        Tile.prototype.mustSubdivide = function (dc, detailFactor) {	            var cellSize = dc.globe.equatorialRadius * this.texelSize,	                distance = this.distanceTo(dc.navigatorState.eyePoint),	                pixelSize = dc.navigatorState.pixelSizeAtDistance(distance);	            return cellSize > Math.max(detailFactor * pixelSize, 0.5);	        };	        Tile.prototype.update = function (dc) {	            var elevationTimestamp = dc.globe.elevationTimestamp(),	                verticalExaggeration = dc.verticalExaggeration,	                globeStateKey = dc.globeStateKey;	            if (this.updateTimestamp != elevationTimestamp	                || this.updateVerticalExaggeration != verticalExaggeration	                || this.updateGlobeStateKey != globeStateKey) {	                this.doUpdate(dc);	                dc.frameStatistics.incrementTileUpdateCount(1);	                this.updateTimestamp = elevationTimestamp;	                this.updateVerticalExaggeration = verticalExaggeration;	                this.updateGlobeStateKey = globeStateKey;	            }	        };	        Tile.prototype.doUpdate = function (dc) {	            var globe = dc.globe,	                verticalExaggeration = dc.verticalExaggeration,	                extremes = globe.minAndMaxElevationsForSector(this.sector),	                minHeight = extremes ? (extremes[0] * verticalExaggeration) : 0,	                maxHeight = extremes ? (extremes[1] * verticalExaggeration) : 0;	            if (minHeight == maxHeight) {	                minHeight = maxHeight + 10; 	            }	            if (!this.extent) {	                this.extent = new BoundingBox();	            }	            this.extent.setToSector(this.sector, globe, minHeight, maxHeight);	            if (!this.samplePoints) {	                this.sampleElevations = new Float64Array(9);	                this.samplePoints = new Float64Array(3 * this.sampleElevations.length);	            }	            WWUtil.fillArray(this.sampleElevations, 0.5 * (minHeight + maxHeight));	            globe.computePointsForGrid(this.sector, 3, 3, this.sampleElevations, Vec3.ZERO, this.samplePoints);	            if (!this.referencePoint) {	                this.referencePoint = new Vec3(0, 0, 0);	            }	            globe.computePointFromPosition(this.sector.centroidLatitude(), this.sector.centroidLongitude(), 0,	                this.referencePoint);	        };	        Tile.computeRow = function (delta, latitude) {	            var row = Math.floor((latitude + 90) / delta);	            if (latitude == 90) {	                row -= 1;	            }	            return row;	        };	        Tile.computeColumn = function (delta, longitude) {	            var col = Math.floor((longitude + 180) / delta);	            if (longitude == 180) {	                col -= 1;	            }	            return col;	        };	        Tile.computeLastRow = function (delta, maxLatitude) {	            var row = Math.ceil((maxLatitude + 90) / delta - 1);	            if (maxLatitude + 90 < delta) {	                row = 0;	            }	            return row;	        };	        Tile.computeLastColumn = function (delta, maxLongitude) {	            var col = Math.ceil((maxLongitude + 180) / delta - 1);	            if (maxLongitude + 180 < delta) {	                col = 0;	            }	            return col;	        };	        Tile.computeSector = function (level, row, column) {	            var deltaLat = level.tileDelta.latitude,	                deltaLon = level.tileDelta.longitude,	                minLat = -90 + row * deltaLat,	                minLon = -180 + column * deltaLon,	                maxLat = minLat + deltaLat,	                maxLon = minLon + deltaLon;	            return new Sector(minLat, maxLat, minLon, maxLon);	        };	        Tile.createTilesForLevel = function (level, tileFactory, result) {	            var deltaLat = level.tileDelta.latitude,	                deltaLon = level.tileDelta.longitude,	                sector = level.sector,	                firstRow = Tile.computeRow(deltaLat, sector.minLatitude),	                lastRow = Tile.computeRow(deltaLat, sector.maxLatitude),	                firstCol = Tile.computeColumn(deltaLon, sector.minLongitude),	                lastCol = Tile.computeColumn(deltaLon, sector.maxLongitude),	                firstRowLat = -90 + firstRow * deltaLat,	                firstRowLon = -180 + firstCol * deltaLon,	                minLat = firstRowLat,	                minLon,	                maxLat,	                maxLon;	            for (var row = firstRow; row <= lastRow; row += 1) {	                maxLat = minLat + deltaLat;	                minLon = firstRowLon;	                for (var col = firstCol; col <= lastCol; col += 1) {	                    maxLon = minLon + deltaLon;	                    var tileSector = new Sector(minLat, maxLat, minLon, maxLon),	                        tile = tileFactory.createTile(tileSector, level, row, col);	                    result.push(tile);	                    minLon = maxLon;	                }	                minLat = maxLat;	            }	        };	        return Tile;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(39),	        __webpack_require__(12),	        __webpack_require__(9),	        __webpack_require__(13),	        __webpack_require__(38),	        __webpack_require__(14),	        __webpack_require__(31),	        __webpack_require__(16),	        __webpack_require__(19),	        __webpack_require__(43)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              BasicProgram,	              Frustum,	              Logger,	              Matrix,	              NotYetImplementedError,	              Plane,	              Sector,	              Vec3,	              WWMath,	              WWUtil) {	        "use strict";	        var BoundingBox = function () {	            this.center = new Vec3(0, 0, 0);	            this.bottomCenter = new Vec3(-0.5, 0, 0);	            this.topCenter = new Vec3(0.5, 0, 0);	            this.r = new Vec3(1, 0, 0);	            this.s = new Vec3(0, 1, 0);	            this.t = new Vec3(0, 0, 1);	            this.radius = Math.sqrt(3);	            this.tmp1 = new Vec3(0, 0, 0);	            this.tmp2 = new Vec3(0, 0, 0);	            this.tmp3 = new Vec3(0, 0, 0);	            this.scratchElevations = new Float64Array(9);	            this.scratchPoints = new Float64Array(3 * this.scratchElevations.length);	        };	        BoundingBox.scratchMatrix = Matrix.fromIdentity();	        BoundingBox.prototype.setToPoints = function (points) {	            var rMin = +Number.MAX_VALUE,	                rMax = -Number.MAX_VALUE,	                sMin = +Number.MAX_VALUE,	                sMax = -Number.MAX_VALUE,	                tMin = +Number.MAX_VALUE,	                tMax = -Number.MAX_VALUE,	                r = this.r, s = this.s, t = this.t,	                p = new Vec3(0, 0, 0),	                pdr, pds, pdt, rLen, sLen, tLen, rSum, sSum, tSum,	                rx_2, ry_2, rz_2, cx, cy, cz;	            Matrix.principalAxesFromPoints(points, r, s, t);	            for (var i = 0, len = points.length / 3; i < len; i++) {	                p[0] = points[i * 3];	                p[1] = points[i * 3 + 1];	                p[2] = points[i * 3 + 2];	                pdr = p.dot(r);	                if (rMin > pdr)	                    rMin = pdr;	                if (rMax < pdr)	                    rMax = pdr;	                pds = p.dot(s);	                if (sMin > pds)	                    sMin = pds;	                if (sMax < pds)	                    sMax = pds;	                pdt = p.dot(t);	                if (tMin > pdt)	                    tMin = pdt;	                if (tMax < pdt)	                    tMax = pdt;	            }	            if (rMax === rMin)	                rMax = rMin + 1;	            if (sMax === sMin)	                sMax = sMin + 1;	            if (tMax === tMin)	                tMax = tMin + 1;	            rLen = rMax - rMin;	            sLen = sMax - sMin;	            tLen = tMax - tMin;	            rSum = rMax + rMin;	            sSum = sMax + sMin;	            tSum = tMax + tMin;	            rx_2 = 0.5 * r[0] * rLen;	            ry_2 = 0.5 * r[1] * rLen;	            rz_2 = 0.5 * r[2] * rLen;	            cx = 0.5 * (r[0] * rSum + s[0] * sSum + t[0] * tSum);	            cy = 0.5 * (r[1] * rSum + s[1] * sSum + t[1] * tSum);	            cz = 0.5 * (r[2] * rSum + s[2] * sSum + t[2] * tSum);	            this.center[0] = cx;	            this.center[1] = cy;	            this.center[2] = cz;	            this.topCenter[0] = cx + rx_2;	            this.topCenter[1] = cy + ry_2;	            this.topCenter[2] = cz + rz_2;	            this.bottomCenter[0] = cx - rx_2;	            this.bottomCenter[1] = cy - ry_2;	            this.bottomCenter[2] = cz - rz_2;	            r.multiply(rLen);	            s.multiply(sLen);	            t.multiply(tLen);	            this.radius = 0.5 * Math.sqrt(rLen * rLen + sLen * sLen + tLen * tLen);	            return this;	        };	        BoundingBox.prototype.setToSector = function (sector, globe, minElevation, maxElevation) {	            var elevations = this.scratchElevations,	                points = this.scratchPoints;	            WWUtil.fillArray(elevations, maxElevation);	            elevations[0] = elevations[2] = elevations[6] = elevations[8] = minElevation;	            globe.computePointsForGrid(sector, 3, 3, elevations, Vec3.ZERO, points);	            var index = 12; 	            this.tmp1.set(points[index], points[index + 1], points[index + 2]);	            WWMath.localCoordinateAxesAtPoint(this.tmp1, globe, this.r, this.s, this.t);	            var rExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY],	                sExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY],	                tExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];	            for (var i = 0, len = points.length; i < len; i += 3) {	                this.tmp1.set(points[i], points[i + 1], points[i + 2]);	                this.adjustExtremes(this.r, rExtremes, this.s, sExtremes, this.t, tExtremes, this.tmp1);	            }	            if (rExtremes[1] - rExtremes[0] < sExtremes[1] - sExtremes[0]) {	                this.swapAxes(this.r, rExtremes, this.s, sExtremes);	            }	            if (sExtremes[1] - sExtremes[0] < tExtremes[1] - tExtremes[0]) {	                this.swapAxes(this.s, sExtremes, this.t, tExtremes);	            }	            if (rExtremes[1] - rExtremes[0] < sExtremes[1] - sExtremes[0]) {	                this.swapAxes(this.r, rExtremes, this.s, sExtremes);	            }	            var rLen = rExtremes[1] - rExtremes[0],	                sLen = sExtremes[1] - sExtremes[0],	                tLen = tExtremes[1] - tExtremes[0],	                rSum = rExtremes[1] + rExtremes[0],	                sSum = sExtremes[1] + sExtremes[0],	                tSum = tExtremes[1] + tExtremes[0],	                cx = 0.5 * (this.r[0] * rSum + this.s[0] * sSum + this.t[0] * tSum),	                cy = 0.5 * (this.r[1] * rSum + this.s[1] * sSum + this.t[1] * tSum),	                cz = 0.5 * (this.r[2] * rSum + this.s[2] * sSum + this.t[2] * tSum),	                rx_2 = 0.5 * this.r[0] * rLen,	                ry_2 = 0.5 * this.r[1] * rLen,	                rz_2 = 0.5 * this.r[2] * rLen;	            this.center.set(cx, cy, cz);	            this.topCenter.set(cx + rx_2, cy + ry_2, cz + rz_2);	            this.bottomCenter.set(cx - rx_2, cy - ry_2, cz - rz_2);	            this.r.multiply(rLen);	            this.s.multiply(sLen);	            this.t.multiply(tLen);	            this.radius = 0.5 * Math.sqrt(rLen * rLen + sLen * sLen + tLen * tLen);	            return this;	        };	        BoundingBox.prototype.translate = function (translation) {	            this.bottomCenter.add(translation);	            this.topCenter.add(translation);	            this.center.add(translation);	            return this;	        };	        BoundingBox.prototype.distanceTo = function (point) {	            var d = this.center.distanceTo(point) - this.radius;	            return d >= 0 ? d : -d;	        };	        BoundingBox.prototype.effectiveRadius = function (plane) {	            var n = plane.normal;	            return 0.5 * (WWMath.fabs(this.r.dot(n)) + WWMath.fabs(this.s.dot(n)) + WWMath.fabs(this.t.dot(n)));	        };	        BoundingBox.prototype.intersectsFrustum = function (frustum) {	            this.tmp1.copy(this.bottomCenter);	            this.tmp2.copy(this.topCenter);	            if (this.intersectionPoint(frustum.near) < 0) {	                return false;	            }	            if (this.intersectionPoint(frustum.far) < 0) {	                return false;	            }	            if (this.intersectionPoint(frustum.left) < 0) {	                return false;	            }	            if (this.intersectionPoint(frustum.right) < 0) {	                return false;	            }	            if (this.intersectionPoint(frustum.top) < 0) {	                return false;	            }	            if (this.intersectionPoint(frustum.bottom) < 0) {	                return false;	            }	            return true;	        };	        BoundingBox.prototype.intersectionPoint = function (plane) {	            var n = plane.normal,	                effectiveRadius = 0.5 * (Math.abs(this.s.dot(n)) + Math.abs(this.t.dot(n)));	            return this.intersectsAt(plane, effectiveRadius, this.tmp1, this.tmp2);	        };	        BoundingBox.prototype.intersectsAt = function (plane, effRadius, endPoint1, endPoint2) {	            var dq1 = plane.dot(endPoint1);	            var bq1 = dq1 <= -effRadius;	            var dq2 = plane.dot(endPoint2);	            var bq2 = dq2 <= -effRadius;	            if (bq1 && bq2) { 	                return -1;	            }	            if (bq1 == bq2) { 	                return 0;	            }	            this.tmp3.copy(endPoint1);	            this.tmp3.subtract(endPoint2);	            var t = (effRadius + dq1) / plane.normal.dot(this.tmp3);	            this.tmp3.copy(endPoint2);	            this.tmp3.subtract(endPoint1);	            this.tmp3.multiply(t);	            this.tmp3.add(endPoint1);	            if (bq1) {	                endPoint1.copy(this.tmp3);	            }	            else {	                endPoint2.copy(this.tmp3);	            }	            return t;	        };	        BoundingBox.prototype.adjustExtremes = function (r, rExtremes, s, sExtremes, t, tExtremes, p) {	            var pdr = p.dot(r);	            if (rExtremes[0] > pdr) {	                rExtremes[0] = pdr;	            }	            if (rExtremes[1] < pdr) {	                rExtremes[1] = pdr;	            }	            var pds = p.dot(s);	            if (sExtremes[0] > pds) {	                sExtremes[0] = pds;	            }	            if (sExtremes[1] < pds) {	                sExtremes[1] = pds;	            }	            var pdt = p.dot(t);	            if (tExtremes[0] > pdt) {	                tExtremes[0] = pdt;	            }	            if (tExtremes[1] < pdt) {	                tExtremes[1] = pdt;	            }	        };	        BoundingBox.prototype.swapAxes = function (a, aExtremes, b, bExtremes) {	            a.swap(b);	            var tmp = aExtremes[0];	            aExtremes[0] = bExtremes[0];	            bExtremes[0] = tmp;	            tmp = aExtremes[1];	            aExtremes[1] = bExtremes[1];	            bExtremes[1] = tmp;	        };	        BoundingBox.prototype.render = function (dc) {	            var gl = dc.currentGlContext,	                matrix = BoundingBox.scratchMatrix,	                program = dc.findAndBindProgram(BasicProgram);	            try {	                matrix.copy(dc.navigatorState.modelviewProjection);	                matrix.multiply(	                    this.r[0], this.s[0], this.t[0], this.center[0],	                    this.r[1], this.s[1], this.t[1], this.center[1],	                    this.r[2], this.s[2], this.t[2], this.center[2],	                    0, 0, 0, 1);	                matrix.multiplyByTranslation(-0.5, -0.5, -0.5);	                program.loadModelviewProjection(gl, matrix);	                gl.disable(gl.CULL_FACE);	                gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitCubeBuffer());	                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, dc.unitCubeElements());	                gl.enableVertexAttribArray(program.vertexPointLocation);	                gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);	                program.loadColorComponents(gl, 0, 1, 0, 0.6);	                gl.drawElements(gl.LINES, 24, gl.UNSIGNED_SHORT, 72);	                program.loadColorComponents(gl, 1, 1, 1, 0.3);	                gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);	            } finally {	                gl.enable(gl.CULL_FACE);	                gl.bindBuffer(gl.ARRAY_BUFFER, null);	                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);	            }	        };	        return BoundingBox;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbstractError) {	        "use strict";	        var NotYetImplementedError = function (message) {	            AbstractError.call(this, "NotYetImplementedError", message);	            var stack;	            try {	                throw new Error();	            } catch (e) {	                stack = e.stack;	            }	            this.stack = stack;	        };	        NotYetImplementedError.prototype = Object.create(AbstractError.prototype);	        return NotYetImplementedError;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(40),	        __webpack_require__(41),	        __webpack_require__(9)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Color,	              GpuProgram,	              Logger) {	        "use strict";	        var BasicProgram = function (gl) {	            var vertexShaderSource =	                    'attribute vec4 vertexPoint;\n' +	                    'uniform mat4 mvpMatrix;\n' +	                    'void main() {gl_Position = mvpMatrix * vertexPoint;}',	                fragmentShaderSource =	                    'precision mediump float;\n' +	                    'uniform vec4 color;\n' +	                    'void main() {gl_FragColor = color;}';	            GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource);	            this.vertexPointLocation = this.attributeLocation(gl, "vertexPoint");	            this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");	            this.colorLocation = this.uniformLocation(gl, "color");	        };	        BasicProgram.key = "WorldWindGpuBasicProgram";	        BasicProgram.prototype = Object.create(GpuProgram.prototype);	        BasicProgram.prototype.loadModelviewProjection = function (gl, matrix) {	            this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);	        };	        BasicProgram.prototype.loadColor = function (gl, color) {	            this.loadUniformColor(gl, color, this.colorLocation);	        };	        BasicProgram.prototype.loadColorComponents = function (gl, red, green, blue, alpha) {	            this.loadUniformColorComponents(gl, red, green, blue, alpha, this.colorLocation);	        };	        return BasicProgram;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(9)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Logger) {	        "use strict";	        var Color = function (red, green, blue, alpha) {	            this.red = red;	            this.green = green;	            this.blue = blue;	            this.alpha = alpha;	        };	        Color.WHITE = new Color(1, 1, 1, 1);	        Color.BLACK = new Color(0, 0, 0, 1);	        Color.RED = new Color(1, 0, 0, 1);	        Color.GREEN = new Color(0, 1, 0, 1);	        Color.BLUE = new Color(0, 0, 1, 1);	        Color.CYAN = new Color(0, 1, 1, 1);	        Color.YELLOW = new Color(1, 1, 0, 1);	        Color.MAGENTA = new Color(1, 0, 1, 1);	        Color.LIGHT_GRAY = new Color(0.75, 0.75, 0.75, 1);	        Color.MEDIUM_GRAY = new Color(0.5, 0.5, 0.5, 1);	        Color.DARK_GRAY = new Color(0.25, 0.25, 0.25, 1);	        Color.TRANSPARENT = new Color(0, 0, 0, 0);	        Color.prototype.set = function (red, green, blue, alpha) {	            this.red = red;	            this.green = green;	            this.blue = blue;	            this.alpha = alpha;	            return this;	        };	        Color.prototype.copy = function (color) {	            this.red = color.red;	            this.green = color.green;	            this.blue = color.blue;	            this.alpha = color.alpha;	            return this;	        };	        Color.prototype.clone = function () {	            return new Color(this.red, this.green, this.blue, this.alpha);	        };	        Color.prototype.premultipliedComponents = function (array) {	            var a = this.alpha;	            array[0] = this.red * a;	            array[1] = this.green * a;	            array[2] = this.blue * a;	            array[3] = a;	            return array;	        };	        Color.colorFromByteArray = function (bytes) {	            return new Color(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);	        };	        Color.colorFromBytes = function (redByte, greenByte, blueByte, alphaByte) {	            return new Color(redByte / 255, greenByte / 255, blueByte / 255, alphaByte / 255);	        };	        Color.colorFromHex = function(color) {	            var red = parseInt(color.substring(0, 2), 16);	            var green = parseInt(color.substring(2,4), 16);	            var blue = parseInt(color.substring(4,6), 16);	            var alpha = parseInt(color.substring(6,8), 16);	            return Color.colorFromBytes(red, green, blue, alpha);	        };	        Color.colorFromKmlHex = function(color) {	            color = color.split("").reverse().join("");	            return Color.colorFromHex(color);	        };	        Color.prototype.nextColor = function () {	            var rb = Math.round(this.red * 255),	                gb = Math.round(this.green * 255),	                bb = Math.round(this.blue * 255);	            if (rb < 255) {	                this.red = (rb + 1) / 255;	            } else if (gb < 255) {	                this.red = 0;	                this.green = (gb + 1) / 255;	            } else if (bb < 255) {	                this.red = 0;	                this.green = 0;	                this.blue = (bb + 1) / 255;	            } else {	                this.red = 1 / 255;	                this.green = 0;	                this.blue = 0;	            }	            return this;	        };	        Color.prototype.equals = function (color) {	            var rbA = Math.round(this.red * 255),	                gbA = Math.round(this.green * 255),	                bbA = Math.round(this.blue * 255),	                abA = Math.round(this.alpha * 255),	                rbB = Math.round(color.red * 255),	                gbB = Math.round(color.green * 255),	                bbB = Math.round(color.blue * 255),	                abB = Math.round(color.alpha * 255);	            return rbA === rbB && gbA === gbB && bbA === bbB && abA === abB;	        };	        Color.prototype.equalsBytes = function (bytes) {	            var rb = Math.round(this.red * 255),	                gb = Math.round(this.green * 255),	                bb = Math.round(this.blue * 255),	                ab = Math.round(this.alpha * 255);	            return rb === bytes[0] && gb === bytes[1] && bb === bytes[2] && ab === bytes[3];	        };	        Color.prototype.toByteString = function () {	            var rb = Math.round(this.red * 255),	                gb = Math.round(this.green * 255),	                bb = Math.round(this.blue * 255),	                ab = Math.round(this.alpha * 255);	            return "(" + rb + "," + gb + "," + bb + "," + ab + ")";	        };	        Color.prototype.toHexString = function(isUsingAlpha) {	            var redHex = Math.ceil(this.red * 255).toString(16),	                greenHex = Math.ceil(this.green * 255).toString(16),	                blueHex = Math.ceil(this.blue * 255).toString(16),	                alphaHex = Math.ceil(this.alpha * 255).toString(16);	            var result = "#";	            result += (redHex.length < 2) ? ('0' + redHex) : redHex;	            result += (greenHex.length < 2) ? ('0' + greenHex) : greenHex;	            result += (blueHex.length < 2) ? ('0' + blueHex) : blueHex;	            if (isUsingAlpha) {	                result += (alphaHex.length < 2) ? ('0' + alphaHex) : alphaHex;	            }	            return result;	        };	        Color.prototype.toRGBAString = function () {	            var red = Math.floor(this.red * 255),	                green = Math.floor(this.green * 255),	                blue = Math.floor(this.blue * 255);	            return 'rgba(' + red + ' ,' + green + ' ,' + blue + ' ,' + this.alpha + ')';	        };	        return Color;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(40),	        __webpack_require__(42),	        __webpack_require__(9)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Color,	              GpuShader,	              Logger) {	        "use strict";	        var GpuProgram = function (gl, vertexShaderSource, fragmentShaderSource, attributeBindings) {	            var program, vShader, fShader;	            try {	                vShader = new GpuShader(gl, gl.VERTEX_SHADER, vertexShaderSource);	                fShader = new GpuShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);	            } catch (e) {	                if (vShader)	                    vShader.dispose(gl);	                if (fShader)	                    fShader.dispose(gl);	                throw e;	            }	            program = gl.createProgram();	            gl.attachShader(program, vShader.shaderId);	            gl.attachShader(program, fShader.shaderId);	            if (attributeBindings) {	                for (var i = 0, len = attributeBindings.length; i < len; i++) {	                    gl.bindAttribLocation(program, i, attributeBindings[i]);	                }	            }	            if (!this.link(gl, program)) {	                var infoLog = gl.getProgramInfoLog(program);	                gl.detachShader(program, vShader.shaderId);	                gl.detachShader(program, fShader.shaderId);	                gl.deleteProgram(program);	                vShader.dispose(gl);	                fShader.dispose(gl);	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuProgram", "constructor",	                    "Unable to link shader program: " + infoLog));	            }	            this.programId = program;	            this.attributeLocations = {};	            this.uniformLocations = {};	            this.vertexShader = vShader;	            this.fragmentShader = fShader;	            this.size = vertexShaderSource.length + fragmentShaderSource.length;	            this.scratchArray = new Float32Array(16);	        };	        GpuProgram.prototype.dispose = function (gl) {	            if (this.programId) {	                if (this.vertexShader) {	                    gl.detachShader(this.programId, this.vertexShader.shaderId);	                }	                if (this.fragmentShader) {	                    gl.detachShader(this.programId, this.fragmentShader.shaderId);	                }	                gl.deleteProgram(this.programId);	                delete this.programId;	            }	            if (this.vertexShader) {	                this.vertexShader.dispose(gl);	                delete this.vertexShader;	            }	            if (this.fragmentShader) {	                this.fragmentShader.dispose(gl);	                delete this.fragmentShader;	            }	            this.attributeLocations = {};	            this.uniformLocations = {};	        };	        GpuProgram.prototype.attributeLocation = function (gl, attributeName) {	            var location = this.attributeLocations[attributeName];	            if (!location) {	                location = gl.getAttribLocation(this.programId, attributeName);	                this.attributeLocations[attributeName] = location;	            }	            return location;	        };	        GpuProgram.prototype.uniformLocation = function (gl, uniformName) {	            var location = this.uniformLocations[uniformName];	            if (!location) {	                location = gl.getUniformLocation(this.programId, uniformName);	                this.uniformLocations[uniformName] = location;	            }	            return location;	        };	        GpuProgram.prototype.link = function (gl, program) {	            gl.linkProgram(program);	            return gl.getProgramParameter(program, gl.LINK_STATUS);	        };	        GpuProgram.prototype.loadUniformMatrix = function (gl, matrix, location) {	            var columnMajorArray = matrix.columnMajorComponents(this.scratchArray);	            gl.uniformMatrix4fv(location, false, columnMajorArray);	        };	        GpuProgram.prototype.loadUniformColor = function (gl, color, location) {	            var premul = color.premultipliedComponents(this.scratchArray);	            gl.uniform4f(location, premul[0], premul[1], premul[2], premul[3]);	        };	        GpuProgram.prototype.loadUniformColorComponents = function (gl, red, green, blue, alpha, location) {	            gl.uniform4f(location, red * alpha, green * alpha, blue * alpha, alpha);	        };	        return GpuProgram;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(9)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Logger) {	        "use strict";	        var GpuShader = function (gl, shaderType, shaderSource) {	            if (!(shaderType === gl.VERTEX_SHADER	                || shaderType === gl.FRAGMENT_SHADER)) {	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuShader", "constructor",	                    "The specified shader type is unrecognized."));	            }	            var shader = gl.createShader(shaderType);	            if (!this.compile(gl, shader, shaderType, shaderSource)) {	                var infoLog = gl.getShaderInfoLog(shader);	                gl.deleteShader(shader);	                throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, "GpuShader", "constructor",	                    "Unable to compile shader: " + infoLog));	            }	            this.shaderId = shader;	        };	        GpuShader.prototype.compile = function (gl, shaderId, shaderType, shaderSource) {	            gl.shaderSource(shaderId, shaderSource);	            gl.compileShader(shaderId);	            return gl.getShaderParameter(shaderId, gl.COMPILE_STATUS);	        };	        GpuShader.prototype.dispose = function (gl) {	            if (this.shaderId) {	                gl.deleteShader(this.shaderId);	                delete this.shaderId;	            }	        };	        return GpuShader;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(15),	        __webpack_require__(9),	        __webpack_require__(20),	        __webpack_require__(16)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Line,	              Logger,	              Rectangle,	              Vec3) {	        "use strict";	        var WWUtil = {	            latLonRegex: /^(\-?\d+(\.\d+)?),\s*(\-?\d+(\.\d+)?)$/,	            suffixForMimeType: function (mimeType) {	                if (mimeType === "image/png")	                    return "png";	                if (mimeType === "image/jpeg")	                    return "jpg";	                if (mimeType === "application/bil16")	                    return "bil";	                if (mimeType === "application/bil32")	                    return "bil";	                return null;	            },	            currentUrlSansFilePart: function () {	                var protocol = window.location.protocol,	                    host = window.location.host,	                    path = window.location.pathname,	                    pathParts = path.split("/"),	                    newPath = "";	                for (var i = 0, len = pathParts.length; i < len - 1; i++) {	                    if (pathParts[i].length > 0) {	                        newPath = newPath + "/" + pathParts[i];	                    }	                }	                return protocol + "//" + host + newPath;	            },	            worldwindlibLocation: function () {	                var scripts = document.getElementsByTagName("script"),	                    libraryName = "/worldwind.";	                for (var i = 0; i < scripts.length; i++) {	                    var index = scripts[i].src.indexOf(libraryName);	                    if (index >= 0) {	                        return scripts[i].src.substring(0, index) + "/";	                    }	                }	                return null;	            },	            urlPath: function (url) {	                if (!url)	                    return "";	                var urlParts = url.split("/"),	                    newPath = "";	                for (var i = 0, len = urlParts.length; i < len; i++) {	                    var part = urlParts[i];	                    if (!part || part.length === 0	                        || part.indexOf(":") != -1	                        || part === "."	                        || part === ".."	                        || part === "null"	                        || part === "undefined") {	                        continue;	                    }	                    if (newPath.length !== 0) {	                        newPath = newPath + "/";	                    }	                    newPath = newPath + part;	                }	                return newPath;	            },	            fillArray: function (array, value) {	                if (!array) {	                    return;	                }	                for (var i = 0, len = array.length; i < len; i++) {	                    array[i] = value;	                }	            },	            multiplyArray: function (array, value) {	                if (!array) {	                    return;	                }	                for (var i = 0, len = array.length; i < len; i++) {	                    array[i] *= value;	                }	            },	            jsonpCounter: 0,	            jsonp: function (url, parameterName, callback) {	                var functionName = "gov_nasa_worldwind_jsonp_" + WWUtil.jsonpCounter++;	                window[functionName] = function (jsonData) {	                    delete window[functionName];	                    callback(jsonData);	                };	                var jsonpUrl = url + (url.indexOf('?') === -1 ? '?' : '&');	                jsonpUrl += parameterName + "=" + functionName;	                var script = document.createElement('script');	                script.async = true;	                script.src = jsonpUrl;	                var head = document.getElementsByTagName('head')[0];	                var cleanup = function () {	                    script.onload = undefined;	                    script.onerror = undefined;	                    head.removeChild(script);	                };	                script.onload = cleanup;	                script.onerror = cleanup;	                head.appendChild(script);	            },	            arrayEquals: function (array1, array2) {	                return (array1.length == array2.length) && array1.every(function (element, index) {	                        return element === array2[index] || element.equals && element.equals(array2[index]);	                    });	            },	            transformToBoolean: function (item) {	                if (item == 0 || item == "0" || item == "false") {	                    return false;	                } else {	                    return Boolean(item);	                }	            },	            clone: function (original) {	                var clone = {};	                var i, keys = Object.keys(original);	                for (i = 0; i < keys.length; i++) {	                    clone[keys[i]] = original[keys[i]];	                }	                return clone;	            },	            guid: function () {	                function s4() {	                    return Math.floor((1 + Math.random()) * 0x10000)	                        .toString(16)	                        .substring(1);	                }	                return s4() + s4() + '-' + s4() + '-' + s4() + '-' +	                    s4() + '-' + s4() + s4() + s4();	            },	            date: function(item) {	                return new Date(item);	            }	        };	        return WWUtil;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(45),	        __webpack_require__(18),	        __webpack_require__(9)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Level,	              Location,	              Logger) {	        "use strict";	        var LevelSet = function (sector, levelZeroDelta, numLevels, tileWidth, tileHeight) {	            this.sector = sector;	            this.levelZeroDelta = levelZeroDelta;	            this.numLevels = numLevels;	            this.tileWidth = tileWidth;	            this.tileHeight = tileHeight;	            this.levels = [];	            for (var i = 0; i < numLevels; i += 1) {	                var n = Math.pow(2, i),	                    latDelta = levelZeroDelta.latitude / n,	                    lonDelta = levelZeroDelta.longitude / n,	                    tileDelta = new Location(latDelta, lonDelta),	                    level = new Level(i, tileDelta, this);	                this.levels[i] = level;	            }	        };	        LevelSet.prototype.level = function(levelNumber) {	            if (levelNumber < 0 || levelNumber >= this.levels.length) {	                return null;	            } else {	                return this.levels[levelNumber];	            }	        };	        LevelSet.prototype.levelForTexelSize = function(texelSize) {	            var lastLevel = this.lastLevel();	            if (lastLevel.texelSize >= texelSize) {	                return lastLevel; 	            }	            for (var index = 0, length = this.levels.length; index < length; index += 1) {	                var level = this.levels[index];	                if (level.texelSize <= texelSize) {	                    return level;	                }	            }	            return lastLevel;	        };	        LevelSet.prototype.firstLevel = function() {	            return this.levels[0];	        };	        LevelSet.prototype.lastLevel = function() {	            return this.levels[this.levels.length - 1];	        };	        return LevelSet;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(11),	        __webpack_require__(7),	        __webpack_require__(18),	        __webpack_require__(9)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,	              ArgumentError,	              Location,	              Logger) {	        "use strict";	        var Level = function (levelNumber, tileDelta, parent) {	            this.levelNumber = levelNumber;	            this.tileDelta = tileDelta;	            this.parent = parent;	            this.texelSize = (tileDelta.latitude * Angle.DEGREES_TO_RADIANS) / parent.tileHeight;	            this.tileWidth = parent.tileWidth;	            this.tileHeight = parent.tileHeight;	            this.sector = parent.sector;	        };	        Level.prototype.isFirstLevel = function () {	            return this.parent.firstLevel() == this;	        };	        Level.prototype.isLastLevel = function () {	            return this.parent.lastLevel() == this;	        };	        Level.prototype.previousLevel = function () {	            return this.parent.level(this.levelNumber - 1);	        };	        Level.prototype.nextLevel = function () {	            return this.parent.level(this.levelNumber + 1);	        };	        Level.prototype.compare = function (that) {	            if (this.levelNumber < that.levelNumber)	                return -1;	            if (this.levelNumber > that.levelNumber)	                return 1;	            return 0;	        };	        return Level;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(9)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Logger) {	        "use strict";	        var MemoryCache = function (capacity, lowWater) {	            this._capacity = capacity;	            this._lowWater = lowWater;	            this.usedCapacity = 0;	            this.freeCapacity = capacity;	            this.entries = {};	            this.listeners = [];	        };	        Object.defineProperties(MemoryCache.prototype, {	            capacity: {	                get: function() {	                    return this._capacity;	                },	                set: function (value) {	                    var oldCapacity = this._capacity;	                    this._capacity = value;	                    if (this._capacity <= this.lowWater) {	                        this._lowWater = 0.85 * this._capacity;	                    }	                    if (this._capacity < oldCapacity) {	                        this.makeSpace(0);	                    }	                }	            },	            lowWater: {	                get: function () {	                    return this._lowWater;	                },	                set: function (value) {	                    this._lowWater = value;	                }	            }	        });	        MemoryCache.prototype.entryForKey = function (key) {	            if (!key)	                return null;	            var cacheEntry = this.entries[key];	            if (!cacheEntry)	                return null;	            cacheEntry.lastUsed = Date.now();	            return cacheEntry.entry;	        };	        MemoryCache.prototype.putEntry = function (key, entry, size) {	            var existing = this.entries[key],	                cacheEntry;	            if (existing) {	                this.removeEntry(key);	            }	            if (this.usedCapacity + size > this._capacity) {	                this.makeSpace(size);	            }	            this.usedCapacity += size;	            this.freeCapacity = this._capacity - this.usedCapacity;	            cacheEntry = {	                key: key,	                entry: entry,	                size: size,	                lastUsed: Date.now()	            };	            this.entries[key] = cacheEntry;	        };	        MemoryCache.prototype.clear = function (callListeners) {	            if (callListeners) {	                for (var key in this.entries) {	                    if (this.entries.hasOwnProperty(key)) {	                        this.removeCacheEntry(key);	                    }	                }	            }	            this.entries = {};	            this.freeCapacity = this._capacity;	            this.usedCapacity = 0;	        };	        MemoryCache.prototype.removeEntry = function (key) {	            if (!key)	                return;	            var cacheEntry = this.entries[key];	            if (cacheEntry) {	                this.removeCacheEntry(cacheEntry);	            }	        };	        MemoryCache.prototype.removeCacheEntry = function (cacheEntry) {	            delete this.entries[cacheEntry.key];	            this.usedCapacity -= cacheEntry.size;	            this.freeCapacity = this._capacity - this.usedCapacity;	            for (var i = 0, len = this.listeners.length; i < len; i++) {	                try {	                    this.listeners[i].entryRemoved(cacheEntry.key, cacheEntry.entry);	                } catch (e) {	                    this.listeners[i].removalError(e, cacheEntry.key, cacheEntry.entry);	                }	            }	        };	        MemoryCache.prototype.containsKey = function (key) {	            return key && this.entries[key];	        };	        MemoryCache.prototype.addCacheListener = function (listener) {	            this.listeners.push(listener);	        };	        MemoryCache.prototype.removeCacheListener = function (listener) {	            var index = this.listeners.indexOf(listener);	            if (index > -1) {	                this.listeners.splice(index, 1);	            }	        };	        MemoryCache.prototype.makeSpace = function (spaceRequired) {	            var sortedEntries = [];	            var sizeAtStart = this.usedCapacity;	            for (var key in this.entries) {	                if (this.entries.hasOwnProperty(key)) {	                    sortedEntries.push(this.entries[key]);	                }	            }	            sortedEntries.sort(function (a, b) {	                return a.lastUsed - b.lastUsed;	            });	            for (var i = 0, len = sortedEntries.length; i < len; i++) {	                if (this.usedCapacity > this._lowWater || this.freeCapacity < spaceRequired) {	                    this.removeCacheEntry(sortedEntries[i]);	                } else {	                    break;	                }	            }	        };	        return MemoryCache;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(9)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Logger) {	        "use strict";	        var WmsUrlBuilder = function (serviceAddress, layerNames, styleNames, wmsVersion, timeString) {	            if (!serviceAddress || (serviceAddress.length === 0)) {	                throw new ArgumentError(	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmsUrlBuilder", "constructor",	                        "The WMS service address is missing."));	            }	            if (!layerNames || (layerNames.length === 0)) {	                throw new ArgumentError(	                    Logger.logMessage(Logger.LEVEL_SEVERE, "WmsUrlBuilder", "constructor",	                        "The WMS layer names are not specified."));	            }	            this.serviceAddress = serviceAddress;	            this.layerNames = layerNames;	            this.styleNames = styleNames ? styleNames : "";	            this.transparent = true;	            this.wmsVersion = (wmsVersion && wmsVersion.length > 0) ? wmsVersion : "1.3.0";	            this.isWms130OrGreater = this.wmsVersion >= "1.3.0";	            this.crs = "EPSG:4326";	            this.timeString = timeString;	        };	        WmsUrlBuilder.prototype.urlForTile = function (tile, imageFormat) {	            var sector = tile.sector;	            var sb = WmsUrlBuilder.fixGetMapString(this.serviceAddress);	            if (sb.search(/service=wms/i) < 0) {	                sb = sb + "service=WMS";	            }	            sb = sb + "&request=GetMap";	            sb = sb + "&version=" + this.wmsVersion;	            sb = sb + "&transparent=" + (this.transparent ? "TRUE" : "FALSE");	            sb = sb + "&layers=" + this.layerNames;	            sb = sb + "&styles=" + this.styleNames;	            sb = sb + "&format=" + imageFormat;	            sb = sb + "&width=" + tile.tileWidth;	            sb = sb + "&height=" + tile.tileHeight;	            if (this.timeString) {	                sb = sb + "&time=" + this.timeString;	            }	            if (this.isWms130OrGreater) {	                sb = sb + "&crs=" + this.crs;	                sb = sb + "&bbox=";	                if (this.crs === "CRS:84") {	                    sb = sb + sector.minLongitude + "," + sector.minLatitude + ",";	                    sb = sb + sector.maxLongitude+ "," + sector.maxLatitude;	                } else {	                    sb = sb + sector.minLatitude + "," + sector.minLongitude + ",";	                    sb = sb + sector.maxLatitude+ "," + sector.maxLongitude;	                }	            } else {	                sb = sb + "&srs=" + this.crs;	                sb = sb + "&bbox=";	                sb = sb + sector.minLongitude + "," + sector.minLatitude + ",";	                sb = sb + sector.maxLongitude+ "," + sector.maxLatitude;	            }	            sb = sb.replace(" ", "%20");	            return sb;	        };	        WmsUrlBuilder.fixGetMapString = function (serviceAddress) {	            var index = serviceAddress.indexOf("?");	            if (index < 0) { 	                serviceAddress = serviceAddress + "?"; 	            } else if (index !== serviceAddress.length - 1) { 	                index = serviceAddress.search(/&$/);	                if (index < 0) {	                    serviceAddress = serviceAddress + "&"; 	                }	            }	            return serviceAddress;	        };	        return WmsUrlBuilder;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {	        "use strict";	        var FrameStatistics = function () {	            this.frameCount = 0;	            this.frameTimeCumulative = 0;	            this.frameTimeBase = 0;	            this.frameTimeExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];	            this.frameTime = 0;	            this.tessellationTime = 0;	            this.layerRenderingTime = 0;	            this.orderedRenderingTime = 0;	            this.terrainTileCount = 0;	            this.imageTileCount = 0;	            this.renderedTileCount = 0;	            this.tileUpdateCount = 0;	            this.textureLoadCount = 0;	            this.vboLoadCount = 0;	            this.frameTimeAverage = 0;	            this.frameRateAverage = 0;	            this.frameTimeMin = 0;	            this.frameTimeMax = 0;	        };	        FrameStatistics.prototype.beginFrame = function () {	            this.frameTime = Date.now();	            this.tessellationTime = 0;	            this.layerRenderingTime = 0;	            this.orderedRenderingTime = 0;	            this.terrainTileCount = 0;	            this.imageTileCount = 0;	            this.renderedTileCount = 0;	            this.tileUpdateCount = 0;	            this.textureLoadCount = 0;	            this.vboLoadCount = 0;	            ++this.frameCount;	        };	        FrameStatistics.prototype.endFrame = function () {	            var now = Date.now();	            this.frameTime = now - this.frameTime;	            this.frameTimeCumulative += this.frameTime;	            this.frameTimeExtremes[0] = Math.min(this.frameTimeExtremes[0], this.frameTime);	            this.frameTimeExtremes[1] = Math.max(this.frameTimeExtremes[1], this.frameTime);	            if (now - this.frameTimeBase > 2000) {	                this.frameTimeAverage = this.frameTimeCumulative / this.frameCount;	                this.frameRateAverage = 1000 * this.frameCount / (now - this.frameTimeBase);	                this.frameTimeMin = this.frameTimeExtremes[0];	                this.frameTimeMax = this.frameTimeExtremes[1];	                this.frameCount = 0;	                this.frameTimeCumulative = 0;	                this.frameTimeBase = now;	                this.frameTimeExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];	            }	        };	        FrameStatistics.prototype.incrementRenderedTileCount = function (tileCount) {	            this.renderedTileCount += tileCount;	        };	        FrameStatistics.prototype.setTerrainTileCount = function (tileCount) {	            this.terrainTileCount = tileCount;	        };	        FrameStatistics.prototype.incrementImageTileCount = function (tileCount) {	            this.imageTileCount = tileCount;	        };	        FrameStatistics.prototype.incrementTileUpdateCount = function (count) {	            this.tileUpdateCount += count;	        };	        FrameStatistics.prototype.incrementTextureLoadCount = function (count) {	            this.textureLoadCount += count;	        };	        FrameStatistics.prototype.incrementVboLoadCount = function (count) {	            this.vboLoadCount += count;	        };	        return FrameStatistics;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(11),	        __webpack_require__(7),	        __webpack_require__(37),	        __webpack_require__(32),	        __webpack_require__(15),	        __webpack_require__(18),	        __webpack_require__(9),	        __webpack_require__(17),	        __webpack_require__(50),	        __webpack_require__(31),	        __webpack_require__(52),	        __webpack_require__(16),	        __webpack_require__(19)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,	              ArgumentError,	              BoundingBox,	              ElevationModel,	              Line,	              Location,	              Logger,	              Position,	              ProjectionWgs84,	              Sector,	              Tessellator,	              Vec3,	              WWMath) {	        "use strict";	        var Globe = function (elevationModel, projection) {	            this.elevationModel = elevationModel;	            this.equatorialRadius = 6378137.0;	            this.polarRadius = 6356752.3;	            this.eccentricitySquared = 0.00669437999013;	            this.tessellator = new Tessellator();	            this._projection = projection || new ProjectionWgs84();	            this._offset = 0;	            this.offsetVector = new Vec3(0, 0, 0);	            this.id = ++Globe.idPool;	            this._stateKey = "globe " + this.id.toString() + " ";	        };	        Globe.idPool = 0; 	        Object.defineProperties(Globe.prototype, {	            stateKey: {	                get: function () {	                    return this._stateKey + this.elevationModel.stateKey + "offset " + this.offset.toString() + " "	                        + this.projection.stateKey;	                }	            },	            continuous: {	                get: function () {	                    return this.projection.continuous;	                }	            },	            projection: {	                get: function () {	                    return this._projection;	                },	                set: function (projection) {	                    if (this.projection != projection) {	                        this.tessellator = new Tessellator();	                    }	                    this._projection = projection;	                }	            },	            projectionLimits: {	                get: function () {	                    return this._projection.projectionLimits;	                }	            },	            offset: {	                get: function () {	                    return this._offset;	                },	                set: function (offset) {	                    this._offset = offset;	                    this.offsetVector[0] = offset * 2 * Math.PI * this.equatorialRadius;	                }	            }	        });	        Globe.prototype.is2D = function () {	            return this.projection.is2D;	        };	        Globe.prototype.computePointFromPosition = function (latitude, longitude, altitude, result) {	            return this.projection.geographicToCartesian(this, latitude, longitude, altitude, this.offsetVector, result);	        };	        Globe.prototype.computePointFromLocation = function (latitude, longitude, result) {	            return this.computePointFromPosition(latitude, longitude, 0, result);	        };	        Globe.prototype.computePointsForGrid = function (sector, numLat, numLon, elevations, referencePoint, result) {	            var numPoints = numLat * numLon;	            return this.projection.geographicToCartesianGrid(this, sector, numLat, numLon, elevations, referencePoint,	                this.offsetVector, result);	        };	        Globe.prototype.computePositionFromPoint = function (x, y, z, result) {	            this.projection.cartesianToGeographic(this, x, y, z, this.offsetVector, result);	            if (this.continuous) {	                if (result.longitude < -180) {	                    result.longitude += 360;	                } else if (result.longitude > 180) {	                    result.longitude -= 360;	                }	            }	            return result;	        };	        Globe.prototype.radiusAt = function (latitude, longitude) {	            var sinLat = Math.sin(latitude * Angle.DEGREES_TO_RADIANS),	                rpm = this.equatorialRadius / Math.sqrt(1.0 - this.eccentricitySquared * sinLat * sinLat);	            return rpm * Math.sqrt(1.0 + (this.eccentricitySquared * this.eccentricitySquared - 2.0 * this.eccentricitySquared) * sinLat * sinLat);	        };	        Globe.prototype.surfaceNormalAtLocation = function (latitude, longitude, result) {	            if (this.is2D()) {	                result[0] = 0;	                result[1] = 0;	                result[2] = 1;	                return result;	            }	            var cosLat = Math.cos(latitude * Angle.DEGREES_TO_RADIANS),	                cosLon = Math.cos(longitude * Angle.DEGREES_TO_RADIANS),	                sinLat = Math.sin(latitude * Angle.DEGREES_TO_RADIANS),	                sinLon = Math.sin(longitude * Angle.DEGREES_TO_RADIANS),	                eqSquared = this.equatorialRadius * this.equatorialRadius,	                polSquared = this.polarRadius * this.polarRadius;	            result[0] = cosLat * sinLon / eqSquared;	            result[1] = (1 - this.eccentricitySquared) * sinLat / polSquared;	            result[2] = cosLat * cosLon / eqSquared;	            return result.normalize();	        };	        Globe.prototype.surfaceNormalAtPoint = function (x, y, z, result) {	            if (this.projection.surfaceNormalAtPoint) {	                return this.projection.surfaceNormalAtPoint(this, x, y, z, result);	            }	            if (this.is2D()) {	                result[0] = 0;	                result[1] = 0;	                result[2] = 1;	                return result;	            }	            var eSquared = this.equatorialRadius * this.equatorialRadius,	                polSquared = this.polarRadius * this.polarRadius;	            result[0] = x / eSquared;	            result[1] = y / polSquared;	            result[2] = z / eSquared;	            return result.normalize();	        };	        Globe.prototype.northTangentAtLocation = function (latitude, longitude, result) {	            return this.projection.northTangentAtLocation(this, latitude, longitude, result);	        };	        Globe.prototype.northTangentAtPoint = function (x, y, z, result) {	            return this.projection.northTangentAtPoint(this, x, y, z, this.offsetVector, result);	        };	        Globe.prototype.intersectsFrustum = function (frustum) {	            if (this.is2D()) {	                var bbox = new BoundingBox();	                bbox.setToSector(Sector.FULL_SPHERE, this, this.elevationModel.minElevation,	                    this.elevationModel.maxElevation);	                return bbox.intersectsFrustum(frustum);	            }	            if (frustum.far.distance <= this.equatorialRadius)	                return false;	            if (frustum.left.distance <= this.equatorialRadius)	                return false;	            if (frustum.right.distance <= this.equatorialRadius)	                return false;	            if (frustum.top.distance <= this.equatorialRadius)	                return false;	            if (frustum.bottom.distance <= this.equatorialRadius)	                return false;	            if (frustum.near.distance <= this.equatorialRadius)	                return false;	            return true;	        };	        Globe.prototype.intersectsLine = function (line, result) {	            if (this.is2D()) {	                var vx = line.direction[0],	                    vy = line.direction[1],	                    vz = line.direction[2],	                    sx = line.origin[0],	                    sy = line.origin[1],	                    sz = line.origin[2],	                    t;	                if (vz == 0 && sz != 0) { 	                    return false;	                }	                t = -sz / vz; 	                if (t < 0) { 	                    return false;	                }	                result[0] = sx + vx * t;	                result[1] = sy + vy * t;	                result[2] = sz + vz * t;	                return true;	            }	            return WWMath.computeEllipsoidalGlobeIntersection(line, this.equatorialRadius, this.polarRadius, result);	        };	        Globe.prototype.elevationTimestamp = function () {	            return this.elevationModel.timestamp;	        };	        Globe.prototype.minElevation = function () {	            return this.elevationModel.minElevation	        };	        Globe.prototype.maxElevation = function () {	            return this.elevationModel.maxElevation	        };	        Globe.prototype.minAndMaxElevationsForSector = function (sector) {	            return this.elevationModel.minAndMaxElevationsForSector(sector);	        };	        Globe.prototype.elevationAtLocation = function (latitude, longitude) {	            return this.elevationModel.elevationAtLocation(latitude, longitude);	        };	        Globe.prototype.elevationsForGrid = function (sector, numLat, numLon, targetResolution, result) {	            return this.elevationModel.elevationsForGrid(sector, numLat, numLon, targetResolution, result);	        };	        return Globe;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))	;
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(11),	        __webpack_require__(7),	        __webpack_require__(51),	        __webpack_require__(9),	        __webpack_require__(17),	        __webpack_require__(16),	        __webpack_require__(19)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,	              ArgumentError,	              GeographicProjection,	              Logger,	              Position,	              Vec3,	              WWMath) {	        "use strict";	        var ProjectionWgs84 = function () {	            GeographicProjection.call(this, "WGS84", false, null);	            this.is2D = false;	            this.scratchPosition = new Position(0, 0, 0);	        };	        ProjectionWgs84.prototype = Object.create(GeographicProjection.prototype);	        Object.defineProperties(ProjectionWgs84.prototype, {	            stateKey: {	                get: function () {	                    return "projection wgs84 ";	                }	            }	        });	        ProjectionWgs84.prototype.geographicToCartesian = function (globe, latitude, longitude, altitude, offset,	                                                                    result) {	            var cosLat = Math.cos(latitude * Angle.DEGREES_TO_RADIANS),	                sinLat = Math.sin(latitude * Angle.DEGREES_TO_RADIANS),	                cosLon = Math.cos(longitude * Angle.DEGREES_TO_RADIANS),	                sinLon = Math.sin(longitude * Angle.DEGREES_TO_RADIANS),	                rpm = globe.equatorialRadius / Math.sqrt(1.0 - globe.eccentricitySquared * sinLat * sinLat);	            result[0] = (rpm + altitude) * cosLat * sinLon;	            result[1] = (rpm * (1.0 - globe.eccentricitySquared) + altitude) * sinLat;	            result[2] = (rpm + altitude) * cosLat * cosLon;	            return result;	        };	        ProjectionWgs84.prototype.geographicToCartesianGrid = function (globe, sector, numLat, numLon, elevations,	                                                                        referencePoint, offset, result) {	            var minLat = sector.minLatitude * Angle.DEGREES_TO_RADIANS,	                maxLat = sector.maxLatitude * Angle.DEGREES_TO_RADIANS,	                minLon = sector.minLongitude * Angle.DEGREES_TO_RADIANS,	                maxLon = sector.maxLongitude * Angle.DEGREES_TO_RADIANS,	                deltaLat = (maxLat - minLat) / (numLat > 1 ? numLat - 1 : 1),	                deltaLon = (maxLon - minLon) / (numLon > 1 ? numLon - 1 : 1),	                refCenter = referencePoint ? referencePoint : new Vec3(0, 0, 0),	                latIndex, lonIndex,	                elevIndex = 0, resultIndex = 0,	                lat, lon, rpm, elev,	                cosLat, sinLat,	                cosLon = new Float64Array(numLon), sinLon = new Float64Array(numLon);	            for (lonIndex = 0, lon = minLon; lonIndex < numLon; lonIndex++, lon += deltaLon) {	                if (lonIndex === numLon - 1) {	                    lon = maxLon; 	                }	                cosLon[lonIndex] = Math.cos(lon);	                sinLon[lonIndex] = Math.sin(lon);	            }	            for (latIndex = 0, lat = minLat; latIndex < numLat; latIndex++, lat += deltaLat) {	                if (latIndex === numLat - 1) {	                    lat = maxLat; 	                }	                cosLat = Math.cos(lat);	                sinLat = Math.sin(lat);	                rpm = globe.equatorialRadius / Math.sqrt(1.0 - globe.eccentricitySquared * sinLat * sinLat);	                for (lonIndex = 0; lonIndex < numLon; lonIndex++) {	                    elev = elevations[elevIndex++];	                    result[resultIndex++] = (rpm + elev) * cosLat * sinLon[lonIndex] - refCenter[0];	                    result[resultIndex++] = (rpm * (1.0 - globe.eccentricitySquared) + elev) * sinLat - refCenter[1];	                    result[resultIndex++] = (rpm + elev) * cosLat * cosLon[lonIndex] - refCenter[2];	                }	            }	            return result;	        };	        ProjectionWgs84.prototype.cartesianToGeographic = function (globe, x, y, z, offset, result) {	            var X = z,	                Y = x,	                Z = y,	                XXpYY = X * X + Y * Y,	                sqrtXXpYY = Math.sqrt(XXpYY),	                a = globe.equatorialRadius,	                ra2 = 1 / (a * a),	                e2 = globe.eccentricitySquared,	                e4 = e2 * e2,	                p = XXpYY * ra2,	                q = Z * Z * (1 - e2) * ra2,	                r = (p + q - e4) / 6,	                h,	                phi,	                u,	                evoluteBorderTest = 8 * r * r * r + e4 * p * q,	                rad1,	                rad2,	                rad3,	                atan,	                v,	                w,	                k,	                D,	                sqrtDDpZZ,	                e,	                lambda,	                s2;	            if (evoluteBorderTest > 0 || q != 0) {	                if (evoluteBorderTest > 0) {	                    rad1 = Math.sqrt(evoluteBorderTest);	                    rad2 = Math.sqrt(e4 * p * q);	                    if (evoluteBorderTest > 10 * e2) {	                        rad3 = WWMath.cbrt((rad1 + rad2) * (rad1 + rad2));	                        u = r + 0.5 * rad3 + 2 * r * r / rad3;	                    }	                    else {	                        u = r + 0.5 * WWMath.cbrt((rad1 + rad2) * (rad1 + rad2))	                            + 0.5 * WWMath.cbrt((rad1 - rad2) * (rad1 - rad2));	                    }	                }	                else {	                    rad1 = Math.sqrt(-evoluteBorderTest);	                    rad2 = Math.sqrt(-8 * r * r * r);	                    rad3 = Math.sqrt(e4 * p * q);	                    atan = 2 * Math.atan2(rad3, rad1 + rad2) / 3;	                    u = -4 * r * Math.sin(atan) * Math.cos(Math.PI / 6 + atan);	                }	                v = Math.sqrt(u * u + e4 * q);	                w = e2 * (u + v - q) / (2 * v);	                k = (u + v) / (Math.sqrt(w * w + u + v) + w);	                D = k * sqrtXXpYY / (k + e2);	                sqrtDDpZZ = Math.sqrt(D * D + Z * Z);	                h = (k + e2 - 1) * sqrtDDpZZ / k;	                phi = 2 * Math.atan2(Z, sqrtDDpZZ + D);	            }	            else {	                rad1 = Math.sqrt(1 - e2);	                rad2 = Math.sqrt(e2 - p);	                e = Math.sqrt(e2);	                h = -a * rad1 * rad2 / e;	                phi = rad2 / (e * rad2 + rad1 * Math.sqrt(p));	            }	            s2 = Math.sqrt(2);	            if ((s2 - 1) * Y < sqrtXXpYY + X) {	                lambda = 2 * Math.atan2(Y, sqrtXXpYY + X);	            }	            else if (sqrtXXpYY + Y < (s2 + 1) * X) {	                lambda = -Math.PI * 0.5 + 2 * Math.atan2(X, sqrtXXpYY - Y);	            }	            else {	                lambda = Math.PI * 0.5 - 2 * Math.atan2(X, sqrtXXpYY + Y);	            }	            result.latitude = Angle.RADIANS_TO_DEGREES * phi;	            result.longitude = Angle.RADIANS_TO_DEGREES * lambda;	            result.altitude = h;	            return result;	        };	        ProjectionWgs84.prototype.northTangentAtLocation = function (globe, latitude, longitude, result) {	            var cosLat = Math.cos(latitude * Angle.DEGREES_TO_RADIANS),	                cosLon = Math.cos(longitude * Angle.DEGREES_TO_RADIANS),	                sinLat = Math.sin(latitude * Angle.DEGREES_TO_RADIANS),	                sinLon = Math.sin(longitude * Angle.DEGREES_TO_RADIANS);	            result[0] = -sinLat * sinLon;	            result[1] = cosLat;	            result[2] = -sinLat * cosLon;	            return result;	        };	        ProjectionWgs84.prototype.northTangentAtPoint = function (globe, x, y, z, offset, result) {	            this.cartesianToGeographic(globe, x, y, z, Vec3.ZERO, this.scratchPosition);	            return this.northTangentAtLocation(globe, this.scratchPosition.latitude, this.scratchPosition.longitude, result);	        };	        ProjectionWgs84.prototype.surfaceNormalAtPoint = function (globe, x, y, z, result) {	            var eSquared = globe.equatorialRadius * globe.equatorialRadius,	                polSquared = globe.polarRadius * globe.polarRadius;	            result[0] = x / eSquared;	            result[1] = y / polSquared;	            result[2] = z / eSquared;	            return result.normalize();	        };	        return ProjectionWgs84;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(9),	        __webpack_require__(31),	        __webpack_require__(25)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Logger,	              Sector,	              UnsupportedOperationError) {	        "use strict";	        var GeographicProjection = function (displayName, continuous, projectionLimits) {	            this.displayName = displayName || "Geographic Projection";	            this.continuous = continuous;	            this.projectionLimits = projectionLimits;	            this.is2D = true;	        };	        GeographicProjection.prototype.geographicToCartesian = function (globe, latitude, longitude, elevation,	                                                                         offset, result) {	            throw new UnsupportedOperationError(	                Logger.logMessage(Logger.LEVEL_SEVERE, "GeographicProjection", "geographicToCartesian", "abstractInvocation"));	        };	        GeographicProjection.prototype.geographicToCartesianGrid = function (globe, sector, numLat, numLon, elevations,	                                                                             referencePoint, offset, result) {	            throw new UnsupportedOperationError(	                Logger.logMessage(Logger.LEVEL_SEVERE, "GeographicProjection", "geographicToCartesianGrid", "abstractInvocation"));	        };	        GeographicProjection.prototype.cartesianToGeographic = function (globe, x, y, z, offset, result) {	            throw new UnsupportedOperationError(	                Logger.logMessage(Logger.LEVEL_SEVERE, "GeographicProjection", "cartesianToGeographic", "abstractInvocation"));	        };	        GeographicProjection.prototype.northTangentAtLocation = function (globe, latitude, longitude, result) {	            result[0] = 0;	            result[1] = 1;	            result[2] = 0;	            return result;	        };	        GeographicProjection.prototype.northTangentAtPoint = function (globe, x, y, z, offset, result) {	            result[0] = 0;	            result[1] = 1;	            result[2] = 0;	            return result;	        };	        GeographicProjection.prototype.surfaceNormalAtPoint = function (globe, x, y, z, result) {	            result[0] = 0;	            result[1] = 0;	            result[2] = 1;	            return result;	        };	        return GeographicProjection;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(39),	        __webpack_require__(49),	        __webpack_require__(41),	        __webpack_require__(45),	        __webpack_require__(44),	        __webpack_require__(18),	        __webpack_require__(9),	        __webpack_require__(13),	        __webpack_require__(46),	        __webpack_require__(23),	        __webpack_require__(38),	        __webpack_require__(53),	        __webpack_require__(17),	        __webpack_require__(20),	        __webpack_require__(31),	        __webpack_require__(54),	        __webpack_require__(55),	        __webpack_require__(56),	        __webpack_require__(36),	        __webpack_require__(19),	        __webpack_require__(43)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              BasicProgram,	              Globe,	              GpuProgram,	              Level,	              LevelSet,	              Location,	              Logger,	              Matrix,	              MemoryCache,	              NavigatorState,	              NotYetImplementedError,	              PickedObject,	              Position,	              Rectangle,	              Sector,	              Terrain,	              TerrainTile,	              TerrainTileList,	              Tile,	              WWMath,	              WWUtil) {	        "use strict";	        var Tessellator = function () {	            this.numRowsTilesInTopLevel = 4; 	            this.numColumnsTilesInTopLevel = 8; 	            this.maximumSubdivisionDepth = 15; 	            this.tileWidth = 32; 	            this.tileHeight = 32; 	            this.detailControl = 40;	            this.levels = new LevelSet(	                Sector.FULL_SPHERE,	                new Location(	                    180 / this.numRowsTilesInTopLevel,	                    360 / this.numColumnsTilesInTopLevel),	                this.maximumSubdivisionDepth,	                this.tileWidth,	                this.tileHeight);	            this.topLevelTiles = {};	            this.currentTiles = new TerrainTileList(this);	            this.tileCache = new MemoryCache(5000000, 4000000); 	            this.elevationTimestamp = undefined;	            this.lastModelViewProjection = undefined;	            this.vertexPointLocation = -1;	            this.vertexTexCoordLocation = -1;	            this.texCoords = null;	            this.texCoordVboCacheKey = 'global_tex_coords';	            this.indices = null;	            this.indicesVboCacheKey = 'global_indices';	            this.baseIndices = null;	            this.baseIndicesOffset = null;	            this.numBaseIndices = null;	            this.indicesNorth = null;	            this.indicesNorthOffset = null;	            this.numIndicesNorth = null;	            this.indicesSouth = null;	            this.indicesSouthOffset = null;	            this.numIndicesSouth = null;	            this.indicesWest = null;	            this.indicesWestOffset = null;	            this.numIndicesWest = null;	            this.indicesEast = null;	            this.indicesEastOffset = null;	            this.numIndicesEast = null;	            this.indicesLoresNorth = null;	            this.indicesLoresNorthOffset = null;	            this.numIndicesLoresNorth = null;	            this.indicesLoresSouth = null;	            this.indicesLoresSouthOffset = null;	            this.numIndicesLoresSouth = null;	            this.indicesLoresWest = null;	            this.indicesLoresWestOffset = null;	            this.numIndicesLoresWest = null;	            this.indicesLoresEast = null;	            this.indicesLoresEastOffset = null;	            this.numIndicesLoresEast = null;	            this.outlineIndicesOffset = null;	            this.numOutlineIndices = null;	            this.wireframeIndicesOffset = null;	            this.numWireframeIndices = null;	            this.scratchMatrix = Matrix.fromIdentity();	            this.scratchElevations = null;	            this.scratchPrevElevations = null;	            this.corners = {};	            this.tiles = [];	        };	        Tessellator.prototype.tessellate = function (dc) {	            var lastElevationsChange = dc.globe.elevationTimestamp();	            if (this.lastGlobeStateKey === dc.globeStateKey	                && this.lastVerticalExaggeration === dc.verticalExaggeration	                && this.elevationTimestamp === lastElevationsChange	                && this.lastModelViewProjection	                && dc.navigatorState.modelviewProjection.equals(this.lastModelViewProjection)) {	                return this.lastTerrain;	            }	            var navigatorState = dc.navigatorState;	            this.lastModelViewProjection = navigatorState.modelviewProjection;	            this.lastGlobeStateKey = dc.globeStateKey;	            this.elevationTimestamp = lastElevationsChange;	            this.lastVerticalExaggeration = dc.verticalExaggeration;	            this.currentTiles.removeAllTiles();	            if (!this.topLevelTiles[dc.globeStateKey] || this.topLevelTiles[dc.globeStateKey].length == 0) {	                this.createTopLevelTiles(dc);	            }	            this.corners = {};	            this.tiles = [];	            for (var index = 0, len = this.topLevelTiles[dc.globeStateKey].length; index < len; index += 1) {	                var tile = this.topLevelTiles[dc.globeStateKey][index];	                tile.update(dc);	                if (this.isTileVisible(dc, tile)) {	                    this.addTileOrDescendants(dc, tile);	                }	            }	            this.refineNeighbors(dc);	            this.finishTessellating(dc);	            this.lastTerrain = this.currentTiles.length === 0 ? null	                : new Terrain(dc.globe, this, this.currentTiles, dc.verticalExaggeration);	            return this.lastTerrain;	        };	        Tessellator.prototype.createTile = function (tileSector, level, row, column) {	            return new TerrainTile(tileSector, level, row, column);	        };	        Tessellator.prototype.beginRendering = function (dc) {	            var program = dc.currentProgram; 	            if (!program) {	                Logger.logMessage(Logger.LEVEL_INFO, "Tessellator", "beginRendering", "Current Program is empty");	                return;	            }	            this.buildSharedGeometry();	            this.cacheSharedGeometryVBOs(dc);	            var gl = dc.currentGlContext,	                gpuResourceCache = dc.gpuResourceCache;	            this.vertexPointLocation = program.attributeLocation(gl, "vertexPoint");	            this.vertexTexCoordLocation = program.attributeLocation(gl, "vertexTexCoord");	            gl.enableVertexAttribArray(this.vertexPointLocation);	            if (this.vertexTexCoordLocation >= 0) { 	                var texCoordVbo = gpuResourceCache.resourceForKey(this.texCoordVboCacheKey);	                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordVbo);	                gl.vertexAttribPointer(this.vertexTexCoordLocation, 2, gl.FLOAT, false, 0, 0);	                gl.enableVertexAttribArray(this.vertexTexCoordLocation);	            }	            var indicesVbo = gpuResourceCache.resourceForKey(this.indicesVboCacheKey);	            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesVbo);	        };	        Tessellator.prototype.endRendering = function (dc) {	            var gl = dc.currentGlContext;	            gl.bindBuffer(gl.ARRAY_BUFFER, null);	            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);	            if (this.vertexPointLocation >= 0) {	                gl.disableVertexAttribArray(this.vertexPointLocation);	            }	            if (this.vertexTexCoordLocation >= 0) { 	                gl.disableVertexAttribArray(this.vertexTexCoordLocation);	            }	        };	        Tessellator.prototype.beginRenderingTile = function (dc, terrainTile) {	            var gl = dc.currentGlContext,	                gpuResourceCache = dc.gpuResourceCache;	            this.scratchMatrix.setToMultiply(dc.navigatorState.modelviewProjection, terrainTile.transformationMatrix);	            dc.currentProgram.loadModelviewProjection(gl, this.scratchMatrix);	            var vboCacheKey = dc.globeStateKey + terrainTile.tileKey,	                vbo = gpuResourceCache.resourceForKey(vboCacheKey);	            if (!vbo) {	                vbo = gl.createBuffer();	                gl.bindBuffer(gl.ARRAY_BUFFER, vbo);	                gl.bufferData(gl.ARRAY_BUFFER, terrainTile.points, gl.STATIC_DRAW);	                dc.frameStatistics.incrementVboLoadCount(1);	                gpuResourceCache.putResource(vboCacheKey, vbo, terrainTile.points.length * 4);	                terrainTile.pointsVboStateKey = terrainTile.pointsStateKey;	            }	            else if (terrainTile.pointsVboStateKey != terrainTile.pointsStateKey) {	                gl.bindBuffer(gl.ARRAY_BUFFER, vbo);	                gl.bufferSubData(gl.ARRAY_BUFFER, 0, terrainTile.points);	                terrainTile.pointsVboStateKey = terrainTile.pointsStateKey;	            }	            else {	                dc.currentGlContext.bindBuffer(gl.ARRAY_BUFFER, vbo);	            }	            gl.vertexAttribPointer(this.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);	        };	        Tessellator.prototype.endRenderingTile = function (dc, terrainTile) {	        };	        Tessellator.prototype.renderTile = function (dc, terrainTile) {	            var gl = dc.currentGlContext,	                prim = gl.TRIANGLE_STRIP; 	            gl.drawElements(	                prim,	                this.numBaseIndices,	                gl.UNSIGNED_SHORT,	                this.baseIndicesOffset * 2);	            var level = terrainTile.level,	                neighborLevel;	            neighborLevel = terrainTile.neighborLevel(WorldWind.NORTH);	            if (neighborLevel && neighborLevel.compare(level) < 0) {	                gl.drawElements(	                    prim,	                    this.numIndicesLoresNorth,	                    gl.UNSIGNED_SHORT,	                    this.indicesLoresNorthOffset * 2);	            }	            else {	                gl.drawElements(	                    prim,	                    this.numIndicesNorth,	                    gl.UNSIGNED_SHORT,	                    this.indicesNorthOffset * 2);	            }	            neighborLevel = terrainTile.neighborLevel(WorldWind.SOUTH);	            if (neighborLevel && neighborLevel.compare(level) < 0) {	                gl.drawElements(	                    prim,	                    this.numIndicesLoresSouth,	                    gl.UNSIGNED_SHORT,	                    this.indicesLoresSouthOffset * 2);	            }	            else {	                gl.drawElements(	                    prim,	                    this.numIndicesSouth,	                    gl.UNSIGNED_SHORT,	                    this.indicesSouthOffset * 2);	            }	            neighborLevel = terrainTile.neighborLevel(WorldWind.WEST);	            if (neighborLevel && neighborLevel.compare(level) < 0) {	                gl.drawElements(	                    prim,	                    this.numIndicesLoresWest,	                    gl.UNSIGNED_SHORT,	                    this.indicesLoresWestOffset * 2);	            }	            else {	                gl.drawElements(	                    prim,	                    this.numIndicesWest,	                    gl.UNSIGNED_SHORT,	                    this.indicesWestOffset * 2);	            }	            neighborLevel = terrainTile.neighborLevel(WorldWind.EAST);	            if (neighborLevel && neighborLevel.compare(level) < 0) {	                gl.drawElements(	                    prim,	                    this.numIndicesLoresEast,	                    gl.UNSIGNED_SHORT,	                    this.indicesLoresEastOffset * 2);	            }	            else {	                gl.drawElements(	                    prim,	                    this.numIndicesEast,	                    gl.UNSIGNED_SHORT,	                    this.indicesEastOffset * 2);	            }	        };	        Tessellator.prototype.renderWireframeTile = function (dc, terrainTile) {	            var gl = dc.currentGlContext;	            if (this.vertexTexCoordLocation >= 0) {	                gl.disableVertexAttribArray(this.vertexTexCoordLocation);	            }	            gl.drawElements(	                gl.LINES,	                this.numWireframeIndices,	                gl.UNSIGNED_SHORT,	                this.wireframeIndicesOffset * 2);	        };	        Tessellator.prototype.renderTileOutline = function (dc, terrainTile) {	            var gl = dc.currentGlContext;	            if (this.vertexTexCoordLocation >= 0) {	                gl.disableVertexAttribArray(this.vertexTexCoordLocation);	            }	            gl.drawElements(	                gl.LINE_LOOP,	                this.numOutlineIndices,	                gl.UNSIGNED_SHORT,	                this.outlineIndicesOffset * 2);	        };	        Tessellator.prototype.pick = function (dc, tileList, pickDelegate) {	            var color = null,	                userObject = pickDelegate || this,	                position = new Position(0, 0, 0),	                pickableTiles = [];	            for (var i = 0, len = tileList.length; i < len; i++) {	                var tile = tileList[i];	                if (tile.extent.intersectsFrustum(dc.pickFrustum)) {	                    pickableTiles.push(tile);	                }	            }	            if (!dc.pickTerrainOnly) {	                color = dc.uniquePickColor();	                this.drawPickTiles(dc, pickableTiles, color);	            }	            if (!dc.regionPicking) {	                var ray = dc.navigatorState.rayFromScreenPoint(dc.pickPoint),	                    point = this.computeNearestIntersection(ray, pickableTiles);	                if (point) {	                    dc.globe.computePositionFromPoint(point[0], point[1], point[2], position);	                    position.altitude = dc.globe.elevationAtLocation(position.latitude, position.longitude);	                    dc.addPickedObject(new PickedObject(color, userObject, position, null, true));	                }	            }	        };	        Tessellator.prototype.drawPickTiles = function (dc, tileList, color) {	            var gl = dc.currentGlContext;	            try {	                dc.findAndBindProgram(BasicProgram);	                dc.currentProgram.loadColor(gl, color);	                this.beginRendering(dc);	                for (var i = 0, len = tileList.length; i < len; i++) {	                    var tile = tileList[i];	                    this.beginRenderingTile(dc, tile);	                    this.renderTile(dc, tile);	                    this.endRenderingTile(dc, tile);	                }	            } finally {	                this.endRendering(dc);	            }	        };	        Tessellator.prototype.computeNearestIntersection = function (line, tileList) {	            var results = [];	            for (var i = 0, len = tileList.length; i < len; i++) {	                this.computeIntersections(line, tileList[i], results);	            }	            if (results.length == 0) {	                return null; 	            } else {	                var minDistance = Number.POSITIVE_INFINITY,	                    minIndex;	                for (i = 0, len = results.length; i < len; i++) {	                    var distance = line.origin.distanceToSquared(results[i]);	                    if (minDistance > distance) {	                        minDistance = distance;	                        minIndex = i;	                    }	                }	                return results[minIndex];	            }	        };	        Tessellator.prototype.computeIntersections = function (line, tile, results) {	            var level = tile.level,	                neighborLevel,	                points = tile.points,	                elements,	                firstResult = results.length;	            line.origin.subtract(tile.referencePoint);	            this.buildSharedGeometry(tile);	            elements = this.baseIndices;	            WWMath.computeTriStripIntersections(line, points, elements, results);	            neighborLevel = tile.neighborLevel(WorldWind.SOUTH);	            elements = neighborLevel && neighborLevel.compare(level) < 0 ? this.indicesLoresSouth : this.indicesSouth;	            WWMath.computeTriStripIntersections(line, points, elements, results);	            neighborLevel = tile.neighborLevel(WorldWind.WEST);	            elements = neighborLevel && neighborLevel.compare(level) < 0 ? this.indicesLoresWest : this.indicesWest;	            WWMath.computeTriStripIntersections(line, points, elements, results);	            neighborLevel = tile.neighborLevel(WorldWind.EAST);	            elements = neighborLevel && neighborLevel.compare(level) < 0 ? this.indicesLoresEast : this.indicesEast;	            WWMath.computeTriStripIntersections(line, points, elements, results);	            neighborLevel = tile.neighborLevel(WorldWind.NORTH);	            elements = neighborLevel && neighborLevel.compare(level) < 0 ? this.indicesLoresNorth : this.indicesNorth;	            WWMath.computeTriStripIntersections(line, points, elements, results);	            line.origin.add(tile.referencePoint);	            for (var i = firstResult, len = results.length; i < len; i++) {	                results[i].add(tile.referencePoint);	            }	        };	        Tessellator.prototype.createTopLevelTiles = function (dc) {	            this.topLevelTiles[dc.globeStateKey] = [];	            Tile.createTilesForLevel(this.levels.firstLevel(), this, this.topLevelTiles[dc.globeStateKey]);	        };	        Tessellator.prototype.addTileOrDescendants = function (dc, tile) {	            if (this.tileMeetsRenderCriteria(dc, tile)) {	                this.addTile(dc, tile);	                return;	            }	            this.addTileDescendants(dc, tile);	        };	        Tessellator.prototype.addTileDescendants = function (dc, tile) {	            var nextLevel = tile.level.nextLevel();	            var subTiles = tile.subdivideToCache(nextLevel, this, this.tileCache);	            for (var index = 0; index < subTiles.length; index += 1) {	                var child = subTiles[index];	                child.update(dc);	                if (this.levels.sector.intersects(child.sector) && this.isTileVisible(dc, child)) {	                    this.addTileOrDescendants(dc, child);	                }	            }	        };	        Tessellator.prototype.addTile = function (dc, tile) {	            var idx = this.tiles.length;	            this.tiles.push(tile);	            var sector = tile.sector;	            var neTileCorner = [sector.maxLatitude, sector.maxLongitude].toString(),	                seTileCorner = [sector.minLatitude, sector.maxLongitude].toString(),	                nwTileCorner = [sector.maxLatitude, sector.minLongitude].toString(),	                swTileCorner = [sector.minLatitude, sector.minLongitude].toString(),	                corner;	            corner = this.corners[swTileCorner];	            if (!corner) {	                this.corners[swTileCorner] = {'sw': idx}; 	            }	            else {	                corner.sw = idx;	            }	            corner = this.corners[nwTileCorner];	            if (!corner) {	                this.corners[nwTileCorner] = {'nw': idx};	            }	            else {	                corner.nw = idx;	            }	            corner = this.corners[seTileCorner];	            if (!corner) {	                this.corners[seTileCorner] = {'se': idx};	            }	            else {	                corner.se = idx;	            }	            corner = this.corners[neTileCorner];	            if (!corner) {	                this.corners[neTileCorner] = {'ne': idx};	            }	            else {	                corner.ne = idx;	            }	        };	        Tessellator.prototype.refineNeighbors = function (dc) {	            var tileRefinementSet = {};	            for (var idx = 0, len = this.tiles.length; idx < len; idx += 1) {	                var tile = this.tiles[idx],	                    levelNumber = tile.level.levelNumber,	                    sector = tile.sector,	                    corner,	                    neighbor,	                    idx,	                    len;	                var neTileCorner = [sector.maxLatitude, sector.maxLongitude].toString(),	                    seTileCorner = [sector.minLatitude, sector.maxLongitude].toString(),	                    nwTileCorner = [sector.maxLatitude, sector.minLongitude].toString(),	                    swTileCorner = [sector.minLatitude, sector.minLongitude].toString();	                corner = this.corners[neTileCorner];	                if (corner.hasOwnProperty('se')) {	                    neighbor = corner.se;	                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {	                        if (!tileRefinementSet[neighbor]) {	                            tileRefinementSet[neighbor] = true;	                        }	                    }	                }	                if (corner.hasOwnProperty('nw')) {	                    neighbor = corner.nw;	                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {	                        if (!tileRefinementSet[neighbor]) {	                            tileRefinementSet[neighbor] = true;	                        }	                    }	                }	                corner = this.corners[seTileCorner];	                if (corner.hasOwnProperty('ne')) {	                    neighbor = corner.ne;	                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {	                        if (!tileRefinementSet[neighbor]) {	                            tileRefinementSet[neighbor] = true;	                        }	                    }	                }	                if (corner.hasOwnProperty('sw')) {	                    neighbor = corner.sw;	                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {	                        if (!tileRefinementSet[neighbor]) {	                            tileRefinementSet[neighbor] = true;	                        }	                    }	                }	                corner = this.corners[nwTileCorner];	                if (corner.hasOwnProperty('ne')) {	                    neighbor = corner.ne;	                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {	                        if (!tileRefinementSet[neighbor]) {	                            tileRefinementSet[neighbor] = true;	                        }	                    }	                }	                if (corner.hasOwnProperty('sw')) {	                    neighbor = corner.sw;	                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {	                        if (!tileRefinementSet[neighbor]) {	                            tileRefinementSet[neighbor] = true;	                        }	                    }	                }	                corner = this.corners[swTileCorner];	                if (corner.hasOwnProperty('se')) {	                    neighbor = corner.se;	                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {	                        if (!tileRefinementSet[neighbor]) {	                            tileRefinementSet[neighbor] = true;	                        }	                    }	                }	                if (corner.hasOwnProperty('nw')) {	                    neighbor = corner.nw;	                    if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {	                        if (!tileRefinementSet[neighbor]) {	                            tileRefinementSet[neighbor] = true;	                        }	                    }	                }	            }	            var tilesNeedingRefinement = [],	                tilesNotNeedingRefinement = [];	            for (idx = 0, len = this.tiles.length; idx < len; idx += 1) {	                tile = this.tiles[idx];	                if (tileRefinementSet[idx]) {	                    tilesNeedingRefinement.push(tile);	                }	                else {	                    tilesNotNeedingRefinement.push(tile);	                }	            }	            if (tilesNeedingRefinement.length > 0) {	                this.tiles = [];	                this.corners = {};	                for (idx = 0, len = tilesNotNeedingRefinement.length; idx < len; idx += 1) {	                    tile = tilesNotNeedingRefinement[idx];	                    this.addTile(dc, tile);	                }	                for (idx = 0, len = tilesNeedingRefinement.length; idx < len; idx += 1) {	                    var tile = tilesNeedingRefinement[idx];	                    this.addTileDescendants(dc, tile);	                }	                this.refineNeighbors(dc);	            }	        };	        Tessellator.prototype.finishTessellating = function (dc) {	            for (var idx = 0, len = this.tiles.length; idx < len; idx += 1) {	                var tile = this.tiles[idx];	                this.setNeighbors(tile);	                this.regenerateTileGeometryIfNeeded(dc, tile);	                this.currentTiles.addTile(tile);	            }	        };	        Tessellator.prototype.setNeighbors = function (tile) {	            var sector = tile.sector;	            var neTileCorner = [sector.maxLatitude, sector.maxLongitude].toString(),	                seTileCorner = [sector.minLatitude, sector.maxLongitude].toString(),	                nwTileCorner = [sector.maxLatitude, sector.minLongitude].toString(),	                swTileCorner = [sector.minLatitude, sector.minLongitude].toString();	            var neCorner = this.corners[neTileCorner],	                seCorner = this.corners[seTileCorner],	                nwCorner = this.corners[nwTileCorner],	                swCorner = this.corners[swTileCorner];	            var northIdx = -1, 	                southIdx = -1, 	                eastIdx = -1, 	                westIdx = -1; 	            if (neCorner.hasOwnProperty('se')) {	                northIdx = neCorner.se;	            }	            else if (nwCorner.hasOwnProperty('sw')) {	                northIdx = nwCorner.sw;	            }	            if (seCorner.hasOwnProperty('ne')) {	                southIdx = seCorner.ne;	            }	            else if (swCorner.hasOwnProperty('nw')) {	                southIdx = swCorner.nw;	            }	            if (neCorner.hasOwnProperty('nw')) {	                eastIdx = neCorner.nw;	            }	            else if (seCorner.hasOwnProperty('sw')) {	                eastIdx = seCorner.sw;	            }	            if (nwCorner.hasOwnProperty('ne')) {	                westIdx = nwCorner.ne;	            }	            else if (swCorner.hasOwnProperty('se')) {	                westIdx = swCorner.se;	            }	            tile.setNeighborLevel(WorldWind.NORTH, (northIdx >= 0) ? this.tiles[northIdx].level : null);	            tile.setNeighborLevel(WorldWind.SOUTH, (southIdx >= 0) ? this.tiles[southIdx].level : null);	            tile.setNeighborLevel(WorldWind.EAST, (eastIdx >= 0) ? this.tiles[eastIdx].level : null);	            tile.setNeighborLevel(WorldWind.WEST, (westIdx >= 0) ? this.tiles[westIdx].level : null);	        };	        Tessellator.prototype.isTileVisible = function (dc, tile) {	            if (dc.globe.projectionLimits && !tile.sector.overlaps(dc.globe.projectionLimits)) {	                return false;	            }	            return tile.extent.intersectsFrustum(dc.navigatorState.frustumInModelCoordinates);	        };	        Tessellator.prototype.tileMeetsRenderCriteria = function (dc, tile) {	            var s = this.detailControl;	            if (tile.sector.minLatitude >= 75 || tile.sector.maxLatitude <= -75) {	                s *= 2;	            }	            return tile.level.isLastLevel() || !tile.mustSubdivide(dc, s);	        };	        Tessellator.prototype.regenerateTileGeometryIfNeeded = function (dc, tile) {	            var stateKey = dc.globeStateKey + tile.stateKey + dc.verticalExaggeration;	            if (!tile.points || tile.pointsStateKey != stateKey) {	                this.regenerateTileGeometry(dc, tile);	                tile.pointsStateKey = stateKey;	            }	        };	        Tessellator.prototype.regenerateTileGeometry = function (dc, tile) {	            var numLat = tile.tileHeight + 1, 	                numLon = tile.tileWidth + 1,	                refPoint = tile.referencePoint,	                elevations = this.scratchElevations;	            if (!elevations) {	                elevations = new Float64Array(numLat * numLon);	                this.scratchElevations = elevations;	            }	            if (!tile.points) {	                tile.points = new Float32Array(numLat * numLon * 3);	            }	            WWUtil.fillArray(elevations, 0);	            dc.globe.elevationsForGrid(tile.sector, numLat, numLon, tile.texelSize, elevations);	            if (this.mustAlignNeighborElevations(dc, tile)) {	                this.alignNeighborElevations(dc, tile, elevations);	            }	            WWUtil.multiplyArray(elevations, dc.verticalExaggeration);	            dc.globe.computePointsForGrid(tile.sector, numLat, numLon, elevations, refPoint, tile.points);	            tile.transformationMatrix.setTranslation(refPoint[0], refPoint[1], refPoint[2]);	        };	        Tessellator.prototype.mustAlignNeighborElevations = function (dc, tile) {	            var level = tile.level,	                northLevel = tile.neighborLevel(WorldWind.NORTH),	                southLevel = tile.neighborLevel(WorldWind.SOUTH),	                eastLevel = tile.neighborLevel(WorldWind.EAST),	                westLevel = tile.neighborLevel(WorldWind.WEST);	            return (northLevel && northLevel.compare(level) < 0) ||	                (southLevel && southLevel.compare(level) < 0) ||	                (eastLevel && eastLevel.compare(level) < 0) ||	                (westLevel && westLevel.compare(level) < 0);	        };	        Tessellator.prototype.alignNeighborElevations = function (dc, tile, elevations) {	            var numLat = tile.tileHeight + 1, 	                numLon = tile.tileWidth + 1,	                level = tile.level,	                prevNumLat = Math.floor(numLat / 2) + 1, 	                prevNumLon = Math.floor(numLon / 2) + 1,	                prevLevel = level.previousLevel(),	                prevElevations = this.scratchPrevElevations,	                neighborLevel,	                i, index, prevIndex;	            if (!prevElevations) {	                prevElevations = new Float64Array(prevNumLat * prevNumLon);	                this.scratchPrevElevations = prevElevations;	            }	            WWUtil.fillArray(prevElevations, 0);	            dc.globe.elevationsForGrid(tile.sector, prevNumLat, prevNumLon, prevLevel.texelSize, prevElevations);	            neighborLevel = tile.neighborLevel(WorldWind.NORTH);	            if (neighborLevel && neighborLevel.compare(level) < 0) {	                index = (numLat - 1) * numLon;	                prevIndex = (prevNumLat - 1) * prevNumLon;	                for (i = 0; i < prevNumLon; i++, index += 2, prevIndex += 1) {	                    elevations[index] = prevElevations[prevIndex];	                    if (i < prevNumLon - 1) {	                        elevations[index + 1] = 0.5 * (prevElevations[prevIndex] + prevElevations[prevIndex + 1]);	                    }	                }	            }	            neighborLevel = tile.neighborLevel(WorldWind.SOUTH);	            if (neighborLevel && neighborLevel.compare(level) < 0) {	                index = 0;	                prevIndex = 0;	                for (i = 0; i < prevNumLon; i++, index += 2, prevIndex += 1) {	                    elevations[index] = prevElevations[prevIndex];	                    if (i < prevNumLon - 1) {	                        elevations[index + 1] = 0.5 * (prevElevations[prevIndex] + prevElevations[prevIndex + 1]);	                    }	                }	            }	            neighborLevel = tile.neighborLevel(WorldWind.EAST);	            if (neighborLevel && neighborLevel.compare(level) < 0) {	                index = numLon - 1;	                prevIndex = prevNumLon - 1;	                for (i = 0; i < prevNumLat; i++, index += 2 * numLon, prevIndex += prevNumLon) {	                    elevations[index] = prevElevations[prevIndex];	                    if (i < prevNumLat - 1) {	                        elevations[index + numLon] = 0.5 * (prevElevations[prevIndex] + prevElevations[prevIndex + prevNumLon]);	                    }	                }	            }	            neighborLevel = tile.neighborLevel(WorldWind.WEST);	            if (neighborLevel && neighborLevel.compare(level) < 0) {	                index = 0;	                prevIndex = 0;	                for (i = 0; i < prevNumLat; i++, index += 2 * numLon, prevIndex += prevNumLon) {	                    elevations[index] = prevElevations[prevIndex];	                    if (i < prevNumLat - 1) {	                        elevations[index + numLon] = 0.5 * (prevElevations[prevIndex] + prevElevations[prevIndex + prevNumLon]);	                    }	                }	            }	        };	        Tessellator.prototype.buildSharedGeometry = function () {	            var tileWidth = this.levels.tileWidth,	                tileHeight = this.levels.tileHeight;	            if (!this.texCoords) {	                this.buildTexCoords(tileWidth, tileHeight);	            }	            if (!this.indices) {	                this.buildIndices(tileWidth, tileHeight);	            }	        };	        Tessellator.prototype.buildTexCoords = function (tileWidth, tileHeight) {	            var numCols = tileWidth + 1,	                numRows = tileHeight + 1,	                colDelta = 1 / tileWidth,	                rowDelta = 1 / tileHeight,	                buffer = new Float32Array(numCols * numRows * 2),	                index = 0;	            for (var row = 0, t = 0; row < numRows; row++, t += rowDelta) {	                if (row == numRows - 1) {	                    t = 1; 	                }	                for (var col = 0, s = 0; col < numCols; col++, s += colDelta) {	                    if (col == numCols - 1) {	                        s = 1; 	                    }	                    buffer[index++] = s;	                    buffer[index++] = t;	                }	            }	            this.texCoords = buffer;	        };	        Tessellator.prototype.buildIndices = function (tileWidth, tileHeight) {	            var vertexIndex; 	            var numLatVertices = tileHeight + 1,	                numLonVertices = tileWidth + 1,	                latIndexMid = tileHeight / 2,   	                lonIndexMid = tileWidth / 2;    	            var numIndices = 2 * (numLatVertices - 3) * (numLonVertices - 2) + 2 * (numLatVertices - 3);	            var indices = [];	            var index = 0;	            for (var lonIndex = 1; lonIndex < numLonVertices - 2; lonIndex += 1) {	                for (var latIndex = 1; latIndex < numLatVertices - 1; latIndex += 1) {	                    vertexIndex = lonIndex + latIndex * numLonVertices;	                    indices[index++] = vertexIndex;	                    indices[index++] = vertexIndex + 1;	                }	                indices[index++] = vertexIndex + 1;	                vertexIndex = (lonIndex + 1) + 1 * numLonVertices;	                indices[index++] = vertexIndex;	            }	            this.baseIndicesOffset = indices.length - numIndices;	            this.baseIndices = new Uint16Array(indices.slice(this.baseIndicesOffset));	            this.numBaseIndices = numIndices;	            numIndices = 2 * numLonVertices - 2;	            latIndex = numLatVertices - 1;	            lonIndex = numLonVertices - 1;	            vertexIndex = lonIndex + latIndex * numLonVertices;	            indices[index++] = vertexIndex;	            for (lonIndex = numLonVertices - 2; lonIndex > 0; lonIndex -= 1) {	                vertexIndex = lonIndex + latIndex * numLonVertices;	                indices[index++] = vertexIndex;	                indices[index++] = vertexIndex - numLonVertices;	            }	            lonIndex = 0;	            vertexIndex = lonIndex + latIndex * numLonVertices;	            indices[index++] = vertexIndex;	            this.indicesNorthOffset = indices.length - numIndices;	            this.indicesNorth = new Uint16Array(indices.slice(this.indicesNorthOffset));	            this.numIndicesNorth = numIndices;	            numIndices = 2 * numLonVertices - 2;	            latIndex = 0;	            lonIndex = 0;	            vertexIndex = lonIndex + latIndex * numLonVertices;	            indices[index++] = vertexIndex;	            for (lonIndex = 1; lonIndex < numLonVertices - 1; lonIndex += 1) {	                vertexIndex = lonIndex + latIndex * numLonVertices;	                indices[index++] = vertexIndex;	                indices[index++] = vertexIndex + numLonVertices;	            }	            lonIndex = numLonVertices - 1;	            vertexIndex = lonIndex + latIndex * numLonVertices;	            indices[index++] = vertexIndex;	            this.indicesSouthOffset = indices.length - numIndices;	            this.indicesSouth = new Uint16Array(indices.slice(this.indicesSouthOffset));	            this.numIndicesSouth = numIndices;	            numIndices = 2 * numLatVertices - 2;	            lonIndex = 0;	            latIndex = numLatVertices - 1;	            vertexIndex = lonIndex + latIndex * numLonVertices;	            indices[index++] = vertexIndex;	            for (latIndex = numLatVertices - 2; latIndex > 0; latIndex -= 1) {	                vertexIndex = lonIndex + latIndex * numLonVertices;	                indices[index++] = vertexIndex;	                indices[index++] = vertexIndex + 1;	            }	            latIndex = 0;	            vertexIndex = lonIndex + latIndex * numLonVertices;	            indices[index++] = vertexIndex;	            this.indicesWestOffset = indices.length - numIndices;	            this.indicesWest = new Uint16Array(indices.slice(this.indicesWestOffset));	            this.numIndicesWest = numIndices;	            numIndices = 2 * numLatVertices - 2;	            lonIndex = numLonVertices - 1;	            latIndex = 0;	            vertexIndex = lonIndex + latIndex * numLonVertices;	            indices[index++] = vertexIndex;	            for (latIndex = 1; latIndex < numLatVertices - 1; latIndex += 1) {	                vertexIndex = lonIndex + latIndex * numLonVertices;	                indices[index++] = vertexIndex;	                indices[index++] = vertexIndex - 1;	            }	            latIndex = numLatVertices - 1;	            vertexIndex = lonIndex + latIndex * numLonVertices;	            indices[index++] = vertexIndex;	            this.indicesEastOffset = indices.length - numIndices;	            this.indicesEast = new Uint16Array(indices.slice(this.indicesEastOffset));	            this.numIndicesEast = numIndices;	            numIndices = 2 * numLonVertices - 2;	            latIndex = numLatVertices - 1;	            lonIndex = numLonVertices - 1;	            vertexIndex = lonIndex + latIndex * numLonVertices;	            indices[index++] = vertexIndex;	            for (lonIndex = numLonVertices - 2; lonIndex > 0; lonIndex -= 1) {	                vertexIndex = ((lonIndex + 1) & ~1) + latIndex * numLonVertices;	                indices[index++] = vertexIndex;	                vertexIndex = lonIndex + (latIndex - 1) * numLonVertices;	                indices[index++] = vertexIndex;	            }	            lonIndex = 0;	            vertexIndex = lonIndex + latIndex * numLonVertices;	            indices[index++] = vertexIndex;	            this.indicesLoresNorthOffset = indices.length - numIndices;	            this.indicesLoresNorth = new Uint16Array(indices.slice(this.indicesLoresNorthOffset));	            this.numIndicesLoresNorth = numIndices;	            numIndices = 2 * numLonVertices - 2;	            latIndex = 0;	            lonIndex = 0;	            vertexIndex = lonIndex + latIndex * numLonVertices;	            indices[index++] = vertexIndex;	            for (lonIndex = 1; lonIndex < numLonVertices - 1; lonIndex += 1) {	                vertexIndex = (lonIndex & ~1) + latIndex * numLonVertices;	                indices[index++] = vertexIndex;	                vertexIndex = lonIndex + (latIndex + 1) * numLonVertices;	                indices[index++] = vertexIndex;	            }	            lonIndex = numLonVertices - 1;	            vertexIndex = lonIndex + latIndex * numLonVertices;	            indices[index++] = vertexIndex;	            this.indicesLoresSouthOffset = indices.length - numIndices;	            this.indicesLoresSouth = new Uint16Array(indices.slice(this.indicesLoresSouthOffset));	            this.numIndicesLoresSouth = numIndices;	            numIndices = 2 * numLatVertices - 2;	            lonIndex = 0;	            latIndex = numLatVertices - 1;	            vertexIndex = lonIndex + latIndex * numLonVertices;	            indices[index++] = vertexIndex;	            for (latIndex = numLatVertices - 2; latIndex > 0; latIndex -= 1) {	                vertexIndex = lonIndex + ((latIndex + 1) & ~1) * numLonVertices;	                indices[index++] = vertexIndex;	                vertexIndex = (lonIndex + 1) + latIndex * numLonVertices;	                indices[index++] = vertexIndex;	            }	            latIndex = 0;	            vertexIndex = lonIndex + latIndex * numLonVertices;	            indices[index++] = vertexIndex;	            this.indicesLoresWestOffset = indices.length - numIndices;	            this.indicesLoresWest = new Uint16Array(indices.slice(this.indicesLoresWestOffset));	            this.numIndicesLoresWest = numIndices;	            numIndices = 2 * numLatVertices - 2;	            lonIndex = numLonVertices - 1;	            latIndex = 0;	            vertexIndex = lonIndex + latIndex * numLonVertices;	            indices[index++] = vertexIndex;	            for (latIndex = 1; latIndex < numLatVertices - 1; latIndex += 1) {	                vertexIndex = lonIndex + (latIndex & ~1) * numLonVertices;	                indices[index++] = vertexIndex;	                vertexIndex = (lonIndex - 1) + latIndex * numLonVertices;	                indices[index++] = vertexIndex;	            }	            latIndex = numLatVertices - 1;	            vertexIndex = lonIndex + latIndex * numLonVertices;	            indices[index++] = vertexIndex;	            this.indicesLoresEastOffset = indices.length - numIndices;	            this.indicesLoresEast = new Uint16Array(indices.slice(this.indicesLoresEastOffset));	            this.numIndicesLoresEast = numIndices;	            var wireframeIndices = this.buildWireframeIndices(tileWidth, tileHeight);	            var outlineIndices = this.buildOutlineIndices(tileWidth, tileHeight);	            indices = indices.concat(wireframeIndices);	            this.wireframeIndicesOffset = indices.length - this.numWireframeIndices;	            indices = indices.concat(outlineIndices);	            this.outlineIndicesOffset = indices.length - this.numOutlineIndices;	            this.indices = new Uint16Array(indices);	        };	        Tessellator.prototype.buildWireframeIndices = function (tileWidth, tileHeight) {	            var numLatVertices = tileHeight + 1;	            var numLonVertices = tileWidth + 1;	            var numIndices = 2 * tileWidth * numLatVertices + 2 * tileHeight * numLonVertices;	            var indices = [];	            var rowStride = numLonVertices;	            var index = 0,	                lonIndex,	                latIndex,	                vertexIndex;	            for (latIndex = 0; latIndex < numLatVertices; latIndex += 1) {	                for (lonIndex = 0; lonIndex < tileWidth; lonIndex += 1) {	                    vertexIndex = lonIndex + latIndex * rowStride;	                    indices[index] = vertexIndex;	                    indices[index + 1] = (vertexIndex + 1);	                    index += 2	                }	            }	            for (lonIndex = 0; lonIndex < numLonVertices; lonIndex += 1) {	                for (latIndex = 0; latIndex < tileHeight; latIndex += 1) {	                    vertexIndex = lonIndex + latIndex * rowStride;	                    indices[index] = vertexIndex;	                    indices[index + 1] = (vertexIndex + rowStride);	                    index += 2;	                }	            }	            this.numWireframeIndices = numIndices;	            return indices;	        };	        Tessellator.prototype.buildOutlineIndices = function (tileWidth, tileHeight) {	            var numLatVertices = tileHeight + 1;	            var numLonVertices = tileWidth + 1;	            var numIndices = 2 * (numLatVertices - 2) + 2 * numLonVertices + 1;	            var indices = [];	            var rowStride = numLatVertices;	            var index = 0,	                lonIndex,	                latIndex,	                vertexIndex;	            latIndex = 0;	            for (lonIndex = 0; lonIndex < numLonVertices; lonIndex += 1) {	                vertexIndex = lonIndex + latIndex * numLonVertices;	                indices[index] = vertexIndex;	                index += 1;	            }	            lonIndex = numLonVertices - 1;	            for (latIndex = 1; latIndex < numLatVertices; latIndex += 1) {	                vertexIndex = lonIndex + latIndex * numLonVertices;	                indices[index] = vertexIndex;	                index += 1	            }	            latIndex = numLatVertices - 1;	            for (lonIndex = numLonVertices - 1; lonIndex >= 0; lonIndex -= 1) {	                vertexIndex = lonIndex + latIndex * numLonVertices;	                indices[index] = vertexIndex;	                index += 1	            }	            lonIndex = 0;	            for (latIndex = numLatVertices - 1; latIndex >= 0; latIndex -= 1) {	                vertexIndex = lonIndex + latIndex * numLonVertices;	                indices[index] = vertexIndex;	                index += 1	            }	            this.numOutlineIndices = numIndices;	            return indices;	        };	        Tessellator.prototype.cacheSharedGeometryVBOs = function (dc) {	            var gl = dc.currentGlContext,	                gpuResourceCache = dc.gpuResourceCache;	            var texCoordVbo = gpuResourceCache.resourceForKey(this.texCoordVboCacheKey);	            if (!texCoordVbo) {	                texCoordVbo = gl.createBuffer();	                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordVbo);	                gl.bufferData(gl.ARRAY_BUFFER, this.texCoords, gl.STATIC_DRAW);	                dc.frameStatistics.incrementVboLoadCount(1);	                gpuResourceCache.putResource(this.texCoordVboCacheKey, texCoordVbo, this.texCoords.length * 4 / 2);	            }	            var indicesVbo = gpuResourceCache.resourceForKey(this.indicesVboCacheKey);	            if (!indicesVbo) {	                indicesVbo = gl.createBuffer();	                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesVbo);	                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);	                dc.frameStatistics.incrementVboLoadCount(1);	                gpuResourceCache.putResource(this.indicesVboCacheKey, indicesVbo, this.indices.length * 2);	            }	        };	        return Tessellator;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {	        "use strict";	        var PickedObject = function (color, userObject, position, parentLayer, isTerrain) {	            this.color = color;	            this.userObject = userObject;	            this.position = position;	            this.parentLayer = parentLayer;	            this.isTerrain = isTerrain;	            this.isOnTop = false;	        };	        return PickedObject;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(9),	        __webpack_require__(16)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Logger,	              Vec3) {	        "use strict";	        var Terrain = function (globe, tessellator, terrainTiles, verticalExaggeration) {	            this.globe = globe;	            this.verticalExaggeration = verticalExaggeration;	            this.sector = terrainTiles.sector;	            this.tessellator = tessellator;	            this.surfaceGeometry = terrainTiles.tileArray;	            this.stateKey = globe.stateKey + " ve " + verticalExaggeration.toString();	        };	        Terrain.scratchPoint = new Vec3(0, 0, 0);	        Terrain.prototype.surfacePoint = function (latitude, longitude, offset, result) {	            for (var i = 0, len = this.surfaceGeometry.length; i < len; i++) {	                if (this.surfaceGeometry[i].sector.containsLocation(latitude, longitude)) {	                    this.surfaceGeometry[i].surfacePoint(latitude, longitude, result);	                    if (offset) {	                        var normal = this.globe.surfaceNormalAtPoint(result[0], result[1], result[2], Terrain.scratchPoint);	                        result[0] += normal[0] * offset;	                        result[1] += normal[1] * offset;	                        result[2] += normal[2] * offset;	                    }	                    return result;	                }	            }	            var h = offset + this.globe.elevationAtLocation(latitude, longitude) * this.verticalExaggeration;	            this.globe.computePointFromPosition(latitude, longitude, h, result);	            return result;	        };	        Terrain.prototype.surfacePointForMode = function (latitude, longitude, offset, altitudeMode, result) {	            if (!altitudeMode)	                altitudeMode = WorldWind.ABSOLUTE;	            if (altitudeMode === WorldWind.CLAMP_TO_GROUND) {	                return this.surfacePoint(latitude, longitude, 0, result);	            } else if (altitudeMode === WorldWind.RELATIVE_TO_GROUND) {	                return this.surfacePoint(latitude, longitude, offset, result);	            } else {	                var height = offset * this.verticalExaggeration;	                this.globe.computePointFromPosition(latitude, longitude, height, result);	                return result;	            }	        };	        Terrain.prototype.beginRendering = function (dc) {	            if (this.globe && this.globe.tessellator) {	                this.globe.tessellator.beginRendering(dc);	            }	        };	        Terrain.prototype.endRendering = function (dc) {	            if (this.globe && this.globe.tessellator) {	                this.globe.tessellator.endRendering(dc);	            }	        };	        Terrain.prototype.beginRenderingTile = function (dc, terrainTile) {	            if (this.globe && this.globe.tessellator) {	                this.globe.tessellator.beginRenderingTile(dc, terrainTile);	            }	        };	        Terrain.prototype.endRenderingTile = function (dc, terrainTile) {	        };	        Terrain.prototype.renderTile = function (dc, terrainTile) {	            if (this.globe && this.globe.tessellator) {	                this.globe.tessellator.renderTile(dc, terrainTile);	            }	        };	        Terrain.prototype.pick = function (dc) {	            if (this.globe && this.globe.tessellator) {	                this.globe.tessellator.pick(dc, this.surfaceGeometry, this); 	            }	        };	        return Terrain;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(9),	        __webpack_require__(13),	        __webpack_require__(36)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Logger,	              Matrix,	              Tile) {	        "use strict";	        var TerrainTile = function (sector, level, row, column) {	            Tile.call(this, sector, level, row, column); 	            this.transformationMatrix = Matrix.fromIdentity();	            this.points = null;	            this.pointsStateKey = null;	            this.pointsVboStateKey = null;	            this.neighborMap = {};	            this.neighborMap[WorldWind.NORTH] = null;	            this.neighborMap[WorldWind.SOUTH] = null;	            this.neighborMap[WorldWind.EAST] = null;	            this.neighborMap[WorldWind.WEST] = null;	            this._stateKey = null;	            this._elevationTimestamp = null;	            this.scratchArray = [];	        };	        TerrainTile.prototype = Object.create(Tile.prototype);	        Object.defineProperties(TerrainTile.prototype, {	            stateKey: {	                get: function () {	                    if (!this._stateKey) {	                        this._stateKey = this.computeStateKey();	                    }	                    return this._stateKey;	                }	            }	        });	        TerrainTile.prototype.neighborLevel = function (direction) {	            return this.neighborMap[direction];	        };	        TerrainTile.prototype.setNeighborLevel = function (direction, level) {	            this.neighborMap[direction] = level;	            this._stateKey = null; 	        };	        TerrainTile.prototype.surfacePoint = function (latitude, longitude, result) {	            var tileSector = this.sector,	                minLat = tileSector.minLatitude,	                maxLat = tileSector.maxLatitude,	                minLon = tileSector.minLongitude,	                maxLon = tileSector.maxLongitude,	                tileWidth = this.tileWidth,	                tileHeight = this.tileHeight,	                s, t, si, ti, rowStride, vertices, points, k, sf, tf, x, y, z;	            s = (longitude - minLon) / (maxLon - minLon) * tileWidth;	            t = (latitude - minLat) / (maxLat - minLat) * tileHeight;	            si = s < tileWidth ? Math.floor(s) : tileWidth - 1;	            ti = t < tileHeight ? Math.floor(t) : tileHeight - 1;	            rowStride = tileWidth + 1;	            vertices = this.points;	            points = this.scratchArray; 	            k = 3 * (si + ti * rowStride); 	            for (var i = 0; i < 6; i++) {	                points[i] = vertices[k + i];	            }	            k = 3 * (si + (ti + 1) * rowStride); 	            for (var j = 6; j < 12; j++) {	                points[j] = vertices[k + (j - 6)];	            }	            sf = (s < tileWidth ? s - Math.floor(s) : 1);	            tf = (t < tileHeight ? t - Math.floor(t) : 1);	            if (sf > tf) {	                result[0] = points[0] + sf * (points[3] - points[0]) + tf * (points[6] - points[0]);	                result[1] = points[1] + sf * (points[4] - points[1]) + tf * (points[7] - points[1]);	                result[2] = points[2] + sf * (points[5] - points[2]) + tf * (points[8] - points[2]);	            }	            else {	                result[0] = points[9] + (1 - sf) * (points[6] - points[9]) + (1 - tf) * (points[3] - points[9]);	                result[1] = points[10] + (1 - sf) * (points[7] - points[10]) + (1 - tf) * (points[4] - points[10]);	                result[2] = points[11] + (1 - sf) * (points[8] - points[11]) + (1 - tf) * (points[5] - points[11]);	            }	            result[0] += this.referencePoint[0];	            result[1] += this.referencePoint[1];	            result[2] += this.referencePoint[2];	            return result;	        };	        TerrainTile.prototype.update = function (dc) {	            Tile.prototype.update.call(this, dc);	            var elevationTimestamp = dc.globe.elevationTimestamp();	            if (this._elevationTimestamp != elevationTimestamp) {	                this._elevationTimestamp = elevationTimestamp;	                this._stateKey = null; 	            }	        };	        TerrainTile.prototype.computeStateKey = function () {	            var array = [];	            array.push(this._elevationTimestamp);	            array.push(this.neighborMap[WorldWind.NORTH] ? this.neighborMap[WorldWind.NORTH].compare(this.level) : 0);	            array.push(this.neighborMap[WorldWind.SOUTH] ? this.neighborMap[WorldWind.SOUTH].compare(this.level) : 0);	            array.push(this.neighborMap[WorldWind.EAST] ? this.neighborMap[WorldWind.EAST].compare(this.level) : 0);	            array.push(this.neighborMap[WorldWind.WEST] ? this.neighborMap[WorldWind.WEST].compare(this.level) : 0);	            return array.join(".");	        };	        return TerrainTile;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7),	        __webpack_require__(9),	        __webpack_require__(31)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Logger,	              Sector) {	        "use strict";	        var TerrainTileList = function TerrainTileList(tessellator) {	            this.tessellator = tessellator;	            this.sector = null;	            this.tileArray = [];	        };	        Object.defineProperties(TerrainTileList.prototype, {	            length: {	                get: function () {	                    return this.tileArray.length	                }	            }	        });	        TerrainTileList.prototype.addTile = function (tile) {	            if (this.tileArray.indexOf(tile) == -1) {	                this.tileArray.push(tile);	                if (!this.sector) {	                    this.sector = new Sector(0, 0, 0, 0);	                    this.sector.copy(tile.sector);	                } else {	                    this.sector.union(tile.sector);	                }	            }	        };	        TerrainTileList.prototype.removeAllTiles = function () {	            this.tileArray = [];	            this.sector = null;	        };	        return TerrainTileList;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(49),	        __webpack_require__(58),	        __webpack_require__(59)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Globe,	              ProjectionEquirectangular,	              ZeroElevationModel) {	        "use strict";	        var Globe2D = function () {	            Globe.call(this, new ZeroElevationModel(), new ProjectionEquirectangular());	        };	        Globe2D.prototype = Object.create(Globe.prototype);	        return Globe2D;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(11),	        __webpack_require__(7),	        __webpack_require__(51),	        __webpack_require__(9),	        __webpack_require__(16)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,	              ArgumentError,	              GeographicProjection,	              Logger,	              Vec3) {	        "use strict";	        var ProjectionEquirectangular = function () {	            GeographicProjection.call(this, "Equirectangular", true, null);	        };	        ProjectionEquirectangular.prototype = Object.create(GeographicProjection.prototype);	        Object.defineProperties(ProjectionEquirectangular.prototype, {	            stateKey: {	                get: function () {	                    return "projection equirectangular ";	                }	            }	        });	        ProjectionEquirectangular.prototype.geographicToCartesian = function (globe, latitude, longitude, elevation,	                                                                              offset, result) {	            result[0] = globe.equatorialRadius * longitude * Angle.DEGREES_TO_RADIANS + (offset ? offset[0] : 0);	            result[1] = globe.equatorialRadius * latitude * Angle.DEGREES_TO_RADIANS;	            result[2] = elevation;	            return result;	        };	        ProjectionEquirectangular.prototype.geographicToCartesianGrid = function (globe, sector, numLat, numLon,	                                                                                  elevations, referencePoint,	                                                                                  offset, result) {	            var eqr = globe.equatorialRadius,	                minLat = sector.minLatitude * Angle.DEGREES_TO_RADIANS,	                maxLat = sector.maxLatitude * Angle.DEGREES_TO_RADIANS,	                minLon = sector.minLongitude * Angle.DEGREES_TO_RADIANS,	                maxLon = sector.maxLongitude * Angle.DEGREES_TO_RADIANS,	                deltaLat = (maxLat - minLat) / (numLat > 1 ? numLat - 1 : 1),	                deltaLon = (maxLon - minLon) / (numLon > 1 ? numLon - 1 : 1),	                refPoint = referencePoint ? referencePoint : new Vec3(0, 0, 0),	                offsetX = offset ? offset[0] : 0,	                latIndex, lonIndex,	                elevIndex = 0, resultIndex = 0,	                lat, lon, y;	            for (latIndex = 0, lat = minLat; latIndex < numLat; latIndex++, lat += deltaLat) {	                if (latIndex === numLat - 1) {	                    lat = maxLat; 	                }	                y = eqr * lat - refPoint[1];	                for (lonIndex = 0, lon = minLon; lonIndex < numLon; lonIndex++, lon += deltaLon) {	                    if (lonIndex === numLon - 1) {	                        lon = maxLon; 	                    }	                    result[resultIndex++] = eqr * lon - refPoint[0] + offsetX;	                    result[resultIndex++] = y;	                    result[resultIndex++] = elevations[elevIndex++] - refPoint[2];	                }	            }	            return result;	        };	        ProjectionEquirectangular.prototype.cartesianToGeographic = function (globe, x, y, z, offset, result) {	            result.latitude = (y / globe.equatorialRadius) * Angle.RADIANS_TO_DEGREES;	            result.longitude = ((x - (offset ? offset[0] : 0)) / globe.equatorialRadius) * Angle.RADIANS_TO_DEGREES;	            result.altitude = z;	            return result;	        };	        return ProjectionEquirectangular;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(32),	        __webpack_require__(18),	        __webpack_require__(9),	        __webpack_require__(31)], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              ElevationModel,	              Location,	              Logger,	              Sector) {	        "use strict";	        var ZeroElevationModel = function () {	            ElevationModel.call(this, Sector.FULL_SPHERE, new Location(45, 45), 1, " ", " ", 150, 150);	            this.displayName = "Zero Elevations";	            this.timestamp = Date.now();	            this.minElevation = 0;	            this.maxElevation = 0;	        };	        ZeroElevationModel.prototype = Object.create(ElevationModel.prototype);	        ZeroElevationModel.prototype.minAndMaxElevationsForSector = function (sector) {	            return [0, 0];	        };	        ZeroElevationModel.prototype.elevationAtLocation = function (latitude, longitude) {	            return 0;	        };	        ZeroElevationModel.prototype.elevationsForGrid = function (sector, numLat, numLon, targetResolution, result) {	            for (var i = 0, len = result.length; i < len; i++) {	                result[i] = 0;	            }	            return 0;	        };	        return ZeroElevationModel;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(18),	        __webpack_require__(9),	        __webpack_require__(17),	        __webpack_require__(16)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Location,	              Logger,	              Position,	              Vec3) {	        "use strict";	        var GoToAnimator = function (worldWindow) {	            this.wwd = worldWindow;	            this.animationFrequency = 20;	            this.travelTime = 3000;	            this.cancelled = false;	        };	        GoToAnimator.prototype.cancel = function () {	            this.cancelled = true;	        };	        GoToAnimator.prototype.goTo = function (position, completionCallback) {	            this.completionCallback = completionCallback;	            this.cancelled = false;	            this.targetPosition = new Position(position.latitude, position.longitude,	                position.altitude || this.wwd.navigator.range);	            this.startPosition = new Position(	                this.wwd.navigator.lookAtLocation.latitude,	                this.wwd.navigator.lookAtLocation.longitude,	                this.wwd.navigator.range);	            this.startTime = Date.now();	            var animationDuration = this.travelTime,	                panDistance = Location.greatCircleDistance(this.startPosition, this.targetPosition),	                rangeDistance;	            var pA = this.wwd.globe.computePointFromLocation(	                    this.startPosition.latitude, this.startPosition.longitude, new Vec3(0, 0, 0)),	                pB = this.wwd.globe.computePointFromLocation(	                    this.targetPosition.latitude, this.targetPosition.longitude, new Vec3(0, 0, 0));	            this.maxAltitude = pA.distanceTo(pB);	            var viewportSize = this.wwd.navigator.currentState().pixelSizeAtDistance(this.startPosition.altitude)	                * this.wwd.canvas.clientWidth / this.wwd.globe.equatorialRadius;	            if (panDistance <= 2 * viewportSize) {	                this.maxAltitude = this.startPosition.altitude;	            }	            this.maxAltitudeReachedTime = this.maxAltitude <= this.wwd.navigator.range ? Date.now() : null;	            if (this.maxAltitude > this.startPosition.altitude) {	                rangeDistance = Math.max(0, this.maxAltitude - this.startPosition.altitude);	                rangeDistance += Math.abs(this.targetPosition.altitude - this.maxAltitude);	            } else {	                rangeDistance = Math.abs(this.targetPosition.altitude - this.startPosition.altitude);	            }	            var animationDistance = Math.max(panDistance, rangeDistance / this.wwd.globe.equatorialRadius);	            if (animationDistance === 0) {	                return; 	            }	            if (animationDistance < 2 * viewportSize) {	                animationDuration = Math.min((animationDistance / viewportSize) * this.travelTime, this.travelTime);	            }	            animationDuration = Math.max(1, animationDuration);	            this.panVelocity = panDistance / animationDuration;	            this.rangeVelocity = rangeDistance / animationDuration; 	            var thisAnimator = this;	            var timerCallback = function () {	                if (thisAnimator.cancelled) {	                    if (thisAnimator.completionCallback) {	                        thisAnimator.completionCallback(thisAnimator);	                    }	                    return;	                }	                if (thisAnimator.update()) {	                    setTimeout(timerCallback, thisAnimator.animationFrequency);	                } else if (thisAnimator.completionCallback) {	                    thisAnimator.completionCallback(thisAnimator);	                }	            };	            setTimeout(timerCallback, this.animationFrequency); 	        };	        GoToAnimator.prototype.update = function () {	            var currentPosition = new Position(	                this.wwd.navigator.lookAtLocation.latitude,	                this.wwd.navigator.lookAtLocation.longitude,	                this.wwd.navigator.range);	            var continueAnimation = this.updateRange(currentPosition);	            continueAnimation = this.updateLocation(currentPosition) || continueAnimation;	            this.wwd.redraw();	            return continueAnimation;	        };	        GoToAnimator.prototype.updateRange = function (currentPosition) {	            var continueAnimation = false,	                nextRange, elapsedTime;	            if (!this.maxAltitudeReachedTime) {	                elapsedTime = Date.now() - this.startTime;	                nextRange = Math.min(this.startPosition.altitude + this.rangeVelocity * elapsedTime, this.maxAltitude);	                if (Math.abs(this.wwd.navigator.range - nextRange) < 1) {	                    this.maxAltitudeReachedTime = Date.now();	                }	                this.wwd.navigator.range = nextRange;	                continueAnimation = true;	            } else {	                elapsedTime = Date.now() - this.maxAltitudeReachedTime;	                if (this.maxAltitude > this.targetPosition.altitude) {	                    nextRange = this.maxAltitude - (this.rangeVelocity * elapsedTime);	                    nextRange = Math.max(nextRange, this.targetPosition.altitude);	                } else {	                    nextRange = this.maxAltitude + (this.rangeVelocity * elapsedTime);	                    nextRange = Math.min(nextRange, this.targetPosition.altitude);	                }	                this.wwd.navigator.range = nextRange;	                continueAnimation = Math.abs(this.wwd.navigator.range - this.targetPosition.altitude) > 1;	            }	            return continueAnimation;	        };	        GoToAnimator.prototype.updateLocation = function (currentPosition) {	            var elapsedTime = Date.now() - this.startTime,	                distanceTravelled = Location.greatCircleDistance(this.startPosition, currentPosition),	                distanceRemaining = Location.greatCircleDistance(currentPosition, this.targetPosition),	                azimuthToTarget = Location.greatCircleAzimuth(currentPosition, this.targetPosition),	                distanceForNow = this.panVelocity * elapsedTime,	                nextDistance = Math.min(distanceForNow - distanceTravelled, distanceRemaining),	                nextLocation = Location.greatCircleLocation(currentPosition, azimuthToTarget, nextDistance,	                    new Location(0, 0)),	                locationReached = false;	            this.wwd.navigator.lookAtLocation.latitude = nextLocation.latitude;	            this.wwd.navigator.lookAtLocation.longitude = nextLocation.longitude;	            if (nextDistance < 1 / this.wwd.globe.equatorialRadius) {	                locationReached = true;	            }	            return !locationReached;	        };	        return GoToAnimator;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(33),	        __webpack_require__(7),	        __webpack_require__(62),	        __webpack_require__(9),	        __webpack_require__(46),	        __webpack_require__(21)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbsentResourceList,	              ArgumentError,	              ImageSource,	              Logger,	              MemoryCache,	              Texture) {	        "use strict";	        var GpuResourceCache = function (capacity, lowWater) {	            this.entries = new MemoryCache(capacity, lowWater);	            this.cacheKeyPool = 0;	            this.currentRetrievals = {};	            this.absentResourceList = new AbsentResourceList(3, 60e3);	        };	        Object.defineProperties(GpuResourceCache.prototype, {	            capacity: {	                get: function () {	                    return this.entries.capacity;	                }	            },	            lowWater: {	                get: function () {	                    return this.entries.lowWater;	                }	            },	            usedCapacity: {	                get: function () {	                    return this.entries.usedCapacity;	                }	            },	            freeCapacity: {	                get: function () {	                    return this.entries.freeCapacity;	                }	            }	        });	        GpuResourceCache.prototype.generateCacheKey = function () {	            return "GpuResourceCache " + ++this.cacheKeyPool;	        };	        GpuResourceCache.prototype.putResource = function (key, resource, size) {	            var entry = {	                resource: resource	            };	            this.entries.putEntry(key instanceof ImageSource ? key.key : key, entry, size);	        };	        GpuResourceCache.prototype.resourceForKey = function (key) {	            var entry = (key instanceof ImageSource)	                ? this.entries.entryForKey(key.key) : this.entries.entryForKey(key);	            return entry ? entry.resource : null;	        };	        GpuResourceCache.prototype.containsResource = function (key) {	            return this.entries.containsKey(key instanceof ImageSource ? key.key : key);	        };	        GpuResourceCache.prototype.removeResource = function (key) {	            this.entries.removeEntry(key instanceof ImageSource ? key.key : key);	        };	        GpuResourceCache.prototype.clear = function () {	            this.entries.clear(false);	        };	        GpuResourceCache.prototype.retrieveTexture = function (gl, imageSource, wrapMode) {	            if (!imageSource) {	                return null;	            }	            if (imageSource instanceof ImageSource) {	                var t = new Texture(gl, imageSource.image, wrapMode);	                this.putResource(imageSource.key, t, t.size);	                return t;	            }	            if (this.currentRetrievals[imageSource] || this.absentResourceList.isResourceAbsent(imageSource)) {	                return null;	            }	            var cache = this,	                image = new Image();	            image.onload = function () {	                Logger.log(Logger.LEVEL_INFO, "Image retrieval succeeded: " + imageSource);	                var texture = new Texture(gl, image, wrapMode);	                cache.putResource(imageSource, texture, texture.size);	                delete cache.currentRetrievals[imageSource];	                cache.absentResourceList.unmarkResourceAbsent(imageSource);	                var e = document.createEvent('Event');	                e.initEvent(WorldWind.REDRAW_EVENT_TYPE, true, true);	                window.dispatchEvent(e);	            };	            image.onerror = function () {	                delete cache.currentRetrievals[imageSource];	                cache.absentResourceList.markResourceAbsent(imageSource);	                Logger.log(Logger.LEVEL_WARNING, "Image retrieval failed: " + imageSource);	            };	            this.currentRetrievals[imageSource] = imageSource;	            image.crossOrigin = 'anonymous';	            image.src = imageSource;	            return null;	        };	        return GpuResourceCache;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(40),	        __webpack_require__(9)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Color,	              Logger) {	        "use strict";	        var ImageSource = function (image) {	            this.image = image;	            this.key = "ImageSource " + ++ImageSource.keyPool;	        };	        ImageSource.keyPool = 0; 	        return ImageSource;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(40),	        __webpack_require__(48),	        __webpack_require__(65),	        __webpack_require__(66),	        __webpack_require__(12),	        __webpack_require__(49),	        __webpack_require__(41),	        __webpack_require__(61),	        __webpack_require__(69),	        __webpack_require__(9),	        __webpack_require__(13),	        __webpack_require__(23),	        __webpack_require__(64),	        __webpack_require__(14),	        __webpack_require__(17),	        __webpack_require__(20),	        __webpack_require__(70),	        __webpack_require__(31),	        __webpack_require__(75),	        __webpack_require__(77),	        __webpack_require__(79),	        __webpack_require__(81),	        __webpack_require__(24),	        __webpack_require__(16),	        __webpack_require__(19)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Color,	              FrameStatistics,	              FramebufferTexture,	              FramebufferTileController,	              Frustum,	              Globe,	              GpuProgram,	              GpuResourceCache,	              Layer,	              Logger,	              Matrix,	              NavigatorState,	              PickedObjectList,	              Plane,	              Position,	              Rectangle,	              ScreenCreditController,	              Sector,	              SurfaceShape,	              SurfaceShapeTileBuilder,	              SurfaceTileRenderer,	              TextSupport,	              Vec2,	              Vec3,	              WWMath) {	        "use strict";	        var DrawContext = function (gl) {	            this.currentGlContext = gl;	            this.canvas2D = document.createElement("canvas");	            this.ctx2D = this.canvas2D.getContext("2d");	            this.clearColor = Color.TRANSPARENT;	            this.gpuResourceCache = new GpuResourceCache(WorldWind.configuration.gpuCacheSize,	                0.8 * WorldWind.configuration.gpuCacheSize);	            this.surfaceTileRenderer = new SurfaceTileRenderer();	            this.surfaceShapeTileBuilder = new SurfaceShapeTileBuilder();	            this.surfaceShapeTileController = new FramebufferTileController();	            this.screenCreditController = new ScreenCreditController();	            this.textSupport = new TextSupport();	            this.currentFramebuffer = null;	            this.currentProgram = null;	            this.surfaceRenderables = [];	            this.orderedRenderingMode = false;	            this.orderedRenderables = [];	            this.screeRenderables = [];	            this.orderedRenderablesCounter = 0; 	            this.timestamp = Date.now();	            this.previousRedrawTimestamp = this.timestamp;	            this.redrawRequested = false;	            this.globe = null;	            this.globeStateKey = null;	            this.layers = null;	            this.currentLayer = null;	            this.navigatorState = null;	            this.eyePosition = new Position(0, 0, 0);	            this.screenProjection = Matrix.fromIdentity();	            this.terrain = null;	            this.verticalExaggeration = 1;	            this.fadeTime = 500;	            this.surfaceOpacity = 1;	            this.frameStatistics = null;	            this.pickingMode = false;	            this.pickTerrainOnly = false;	            this.deepPicking = false;	            this.regionPicking = false;	            this.pickPoint = null;	            this.pickRectangle = null;	            this.pickFramebuffer = null;	            this.pickFrustum = null;	            this.pickColor = new Color(0, 0, 0, 1);	            this.objectsAtPickPoint = new PickedObjectList();	            this.pixelScale = 1;	        };	        DrawContext.unitCubeKey = "DrawContextUnitCubeKey";	        DrawContext.unitCubeElementsKey = "DrawContextUnitCubeElementsKey";	        DrawContext.unitQuadKey = "DrawContextUnitQuadKey";	        DrawContext.unitQuadKey3 = "DrawContextUnitQuadKey3";	        DrawContext.prototype.reset = function () {	            this.screenCreditController.clear();	            this.surfaceRenderables = []; 	            this.orderedRenderingMode = false;	            this.orderedRenderables = []; 	            this.screenRenderables = [];	            this.orderedRenderablesCounter = 0;	            var previousTimestamp = this.timestamp;	            this.timestamp = Date.now();	            if (this.timestamp === previousTimestamp)	                ++this.timestamp;	            this.redrawRequested = false;	            this.globe = null;	            this.globeStateKey = null;	            this.layers = null;	            this.currentLayer = null;	            this.navigatorState = null;	            this.terrain = null;	            this.verticalExaggeration = 1;	            this.frameStatistics = null;	            this.accumulateOrderedRenderables = true;	            this.pickingMode = false;	            this.pickTerrainOnly = false;	            this.deepPicking = false;	            this.regionPicking = false;	            this.pickPoint = null;	            this.pickRectangle = null;	            this.pickFrustum = null;	            this.pickColor = new Color(0, 0, 0, 1);	            this.objectsAtPickPoint.clear();	        };	        DrawContext.prototype.update = function () {	            var gl = this.currentGlContext,	                eyePoint = this.navigatorState.eyePoint;	            this.globeStateKey = this.globe.stateKey;	            this.globe.computePositionFromPoint(eyePoint[0], eyePoint[1], eyePoint[2], this.eyePosition);	            this.screenProjection.setToScreenProjection(gl.drawingBufferWidth, gl.drawingBufferHeight);	        };	        DrawContext.prototype.contextLost = function () {	            this.gpuResourceCache.clear();	            this.pickFramebuffer = null;	            this.currentFramebuffer = null;	            this.currentProgram = null;	        };	        DrawContext.prototype.contextRestored = function () {	            this.gpuResourceCache.clear();	        };	        DrawContext.prototype.bindFramebuffer = function (framebuffer) {	            if (this.currentFramebuffer != framebuffer) {	                this.currentGlContext.bindFramebuffer(this.currentGlContext.FRAMEBUFFER,	                    framebuffer ? framebuffer.framebufferId : null);	                this.currentFramebuffer = framebuffer;	            }	        };	        DrawContext.prototype.bindProgram = function (program) {	            if (this.currentProgram != program) {	                this.currentGlContext.useProgram(program ? program.programId : null);	                this.currentProgram = program;	            }	        };	        DrawContext.prototype.findAndBindProgram = function (programConstructor) {	            var program = this.gpuResourceCache.resourceForKey(programConstructor.key);	            if (program) {	                this.bindProgram(program);	            } else {	                try {	                    program = new programConstructor(this.currentGlContext);	                    this.bindProgram(program);	                    this.gpuResourceCache.putResource(programConstructor.key, program, program.size);	                } catch (e) {	                    Logger.log(Logger.LEVEL_SEVERE, "Error attempting to create GPU program.")	                }	            }	            return program;	        };	        DrawContext.prototype.addSurfaceRenderable = function (surfaceRenderable) {	            if (surfaceRenderable) {	                this.surfaceRenderables.push(surfaceRenderable);	            }	        };	        DrawContext.prototype.peekSurfaceRenderable = function () {	            if (this.surfaceRenderables.length > 0) {	                return this.surfaceRenderables[this.surfaceRenderables.length - 1];	            } else {	                return null;	            }	        };	        DrawContext.prototype.popSurfaceRenderable = function () {	            if (this.surfaceRenderables.length > 0) {	                return this.surfaceRenderables.pop();	            } else {	                return null;	            }	        };	        DrawContext.prototype.reverseSurfaceRenderables = function () {	            this.surfaceRenderables.reverse();	        };	        DrawContext.prototype.addOrderedRenderable = function (orderedRenderable, eyeDistance) {	            if (orderedRenderable) {	                var ore = {	                    orderedRenderable: orderedRenderable,	                    insertionOrder: this.orderedRenderablesCounter++,	                    eyeDistance: eyeDistance || orderedRenderable.eyeDistance,	                    globeStateKey: this.globeStateKey	                };	                if (this.globe.continuous) {	                    ore.globeOffset = this.globe.offset;	                }	                if (ore.eyeDistance === 0) {	                    this.screenRenderables.push(ore);	                } else {	                    this.orderedRenderables.push(ore);	                }	            }	        };	        DrawContext.prototype.addOrderedRenderableToBack = function (orderedRenderable) {	            if (orderedRenderable) {	                var ore = {	                    orderedRenderable: orderedRenderable,	                    insertionOrder: this.orderedRenderablesCounter++,	                    eyeDistance: Number.MAX_VALUE,	                    globeStateKey: this.globeStateKey	                };	                if (this.globe.continuous) {	                    ore.globeOffset = this.globe.offset;	                }	                this.orderedRenderables.push(ore);	            }	        };	        DrawContext.prototype.peekOrderedRenderable = function () {	            if (this.orderedRenderables.length > 0) {	                return this.orderedRenderables[this.orderedRenderables.length - 1].orderedRenderable;	            } else {	                return null;	            }	        };	        DrawContext.prototype.popOrderedRenderable = function () {	            if (this.orderedRenderables.length > 0) {	                var ore = this.orderedRenderables.pop();	                this.globeStateKey = ore.globeStateKey;	                if (this.globe.continuous) {	                    this.globe.offset = ore.globeOffset;	                }	                return ore.orderedRenderable;	            } else {	                return null;	            }	        };	        DrawContext.prototype.nextScreenRenderable = function () {	            if (this.screenRenderables.length > 0) {	                var ore = this.screenRenderables.shift();	                this.globeStateKey = ore.globeStateKey;	                if (this.globe.continuous) {	                    this.globe.offset = ore.globeOffset;	                }	                return ore.orderedRenderable;	            } else {	                return null;	            }	        };	        DrawContext.prototype.sortOrderedRenderables = function () {	            this.orderedRenderables.sort(function (oreA, oreB) {	                var eA = oreA.eyeDistance,	                    eB = oreB.eyeDistance;	                if (eA < eB) { 	                    return -1;	                } else if (eA > eB) { 	                    return 1;	                } else { 	                    var tA = oreA.insertionOrder,	                        tB = oreB.insertionOrder;	                    if (tA > tB) {	                        return -1;	                    } else if (tA < tB) {	                        return 1;	                    } else {	                        return 0;	                    }	                }	            });	        };	        DrawContext.prototype.readPickColor = function (pickPoint) {	            var glPickPoint = this.navigatorState.convertPointToViewport(pickPoint, new Vec2(0, 0)),	                colorBytes = new Uint8Array(4);	            this.currentGlContext.readPixels(glPickPoint[0], glPickPoint[1], 1, 1, this.currentGlContext.RGBA,	                this.currentGlContext.UNSIGNED_BYTE, colorBytes);	            if (this.clearColor.equalsBytes(colorBytes)) {	                return null;	            }	            return Color.colorFromByteArray(colorBytes);	        };	        DrawContext.prototype.readPickColors = function (pickRectangle) {	            var gl = this.currentGlContext,	                colorBytes = new Uint8Array(pickRectangle.width * pickRectangle.height * 4),	                uniqueColors = {},	                color,	                blankColor = new Color(0, 0, 0, 0),	                packAlignment = gl.getParameter(gl.PACK_ALIGNMENT);	            gl.pixelStorei(gl.PACK_ALIGNMENT, 1); 	            this.currentGlContext.readPixels(pickRectangle.x, pickRectangle.y,	                pickRectangle.width, pickRectangle.height,	                gl.RGBA, gl.UNSIGNED_BYTE, colorBytes);	            gl.pixelStorei(gl.PACK_ALIGNMENT, packAlignment); 	            for (var i = 0, len = pickRectangle.width * pickRectangle.height; i < len; i++) {	                var k = i * 4;	                color = Color.colorFromBytes(colorBytes[k], colorBytes[k + 1], colorBytes[k + 2], colorBytes[k + 3]);	                if (color.equals(this.clearColor) || color.equals(blankColor))	                    continue;	                uniqueColors[color.toByteString()] = color;	            }	            return uniqueColors;	        };	        DrawContext.prototype.resolvePick = function (pickableObject) {	            if (!(pickableObject.userObject instanceof SurfaceShape) && this.deepPicking && !this.regionPicking) {	                var color = this.readPickColor(this.pickPoint);	                if (!color) { 	                    return null;	                }	                if (pickableObject.color.equals(color)) {	                    this.addPickedObject(pickableObject);	                }	            } else {	                this.addPickedObject(pickableObject);	            }	        };	        DrawContext.prototype.addPickedObject = function (pickedObject) {	            if (pickedObject) {	                this.objectsAtPickPoint.add(pickedObject);	            }	        };	        DrawContext.prototype.uniquePickColor = function () {	            var color = this.pickColor.nextColor().clone();	            return color.equals(this.clearColor) ? color.nextColor() : color;	        };	        DrawContext.prototype.makePickFramebuffer = function () {	            var gl = this.currentGlContext,	                width = gl.drawingBufferWidth,	                height = gl.drawingBufferHeight;	            if (!this.pickFramebuffer ||	                this.pickFramebuffer.width != width ||	                this.pickFramebuffer.height != height) {	                this.pickFramebuffer = new FramebufferTexture(gl, width, height, true); 	            }	            return this.pickFramebuffer;	        };	        DrawContext.prototype.makePickFrustum = function () {	            if (!this.pickPoint && !this.pickRectangle) {	                return false;	            }	            var lln, llf, lrn, lrf, uln, ulf, urn, urf, 	                nl, nr, nt, nb, nn, nf, 	                l, r, t, b, n, f, 	                va, vb = new Vec3(0, 0, 0), 	                apertureRadius = 2, 	                screenPoint = new Vec3(0, 0, 0),	                pickPoint,	                pickRectangle = this.pickRectangle,	                viewport = this.navigatorState.viewport;	            if (!pickRectangle) {	                pickPoint = this.navigatorState.convertPointToViewport(this.pickPoint, new Vec2(0, 0));	                pickRectangle = new Rectangle(	                    pickPoint[0] - apertureRadius,	                    pickPoint[1] - apertureRadius,	                    2 * apertureRadius,	                    2 * apertureRadius);	            }	            var xl = pickRectangle.x,	                xr = pickRectangle.x + pickRectangle.width,	                yb = pickRectangle.y,	                yt = pickRectangle.y + pickRectangle.height;	            if (xr < 0 || yt < 0 || xl > viewport.x + viewport.width || yb > viewport.y + viewport.height) {	                return false; 	            }	            pickRectangle.x = WWMath.clamp(xl, viewport.x, viewport.x + viewport.width);	            pickRectangle.y = WWMath.clamp(yb, viewport.y, viewport.y + viewport.height);	            pickRectangle.width = WWMath.clamp(xr, viewport.x, viewport.x + viewport.width) - pickRectangle.x;	            pickRectangle.height = WWMath.clamp(yt, viewport.y, viewport.y + viewport.height) - pickRectangle.y;	            this.pickRectangle = pickRectangle;	            screenPoint[0] = pickRectangle.x;	            screenPoint[1] = pickRectangle.y;	            screenPoint[2] = 0;	            this.navigatorState.unProject(screenPoint, lln = new Vec3(0, 0, 0));	            screenPoint[0] = pickRectangle.x;	            screenPoint[1] = pickRectangle.y;	            screenPoint[2] = 1;	            this.navigatorState.unProject(screenPoint, llf = new Vec3(0, 0, 0));	            screenPoint[0] = pickRectangle.x + pickRectangle.width;	            screenPoint[1] = pickRectangle.y;	            screenPoint[2] = 0;	            this.navigatorState.unProject(screenPoint, lrn = new Vec3(0, 0, 0));	            screenPoint[0] = pickRectangle.x + pickRectangle.width;	            screenPoint[1] = pickRectangle.y;	            screenPoint[2] = 1;	            this.navigatorState.unProject(screenPoint, lrf = new Vec3(0, 0, 0));	            screenPoint[0] = pickRectangle.x;	            screenPoint[1] = pickRectangle.y + pickRectangle.height;	            screenPoint[2] = 0;	            this.navigatorState.unProject(screenPoint, uln = new Vec3(0, 0, 0));	            screenPoint[0] = pickRectangle.x;	            screenPoint[1] = pickRectangle.y + pickRectangle.height;	            screenPoint[2] = 1;	            this.navigatorState.unProject(screenPoint, ulf = new Vec3(0, 0, 0));	            screenPoint[0] = pickRectangle.x + pickRectangle.width;	            screenPoint[1] = pickRectangle.y + pickRectangle.height;	            screenPoint[2] = 0;	            this.navigatorState.unProject(screenPoint, urn = new Vec3(0, 0, 0));	            screenPoint[0] = pickRectangle.x + pickRectangle.width;	            screenPoint[1] = pickRectangle.y + pickRectangle.height;	            screenPoint[2] = 1;	            this.navigatorState.unProject(screenPoint, urf = new Vec3(0, 0, 0));	            va = new Vec3(ulf[0] - lln[0], ulf[1] - lln[1], ulf[2] - lln[2]);	            vb.set(uln[0] - llf[0], uln[1] - llf[1], uln[2] - llf[2]);	            nl = va.cross(vb);	            l = new Plane(nl[0], nl[1], nl[2], -nl.dot(lln));	            l.normalize();	            va = new Vec3(urn[0] - lrf[0], urn[1] - lrf[1], urn[2] - lrf[2]);	            vb.set(urf[0] - lrn[0], urf[1] - lrn[1], urf[2] - lrn[2]);	            nr = va.cross(vb);	            r = new Plane(nr[0], nr[1], nr[2], -nr.dot(lrn));	            r.normalize();	            va = new Vec3(ulf[0] - urn[0], ulf[1] - urn[1], ulf[2] - urn[2]);	            vb.set(urf[0] - uln[0], urf[1] - uln[1], urf[2] - uln[2]);	            nt = va.cross(vb);	            t = new Plane(nt[0], nt[1], nt[2], -nt.dot(uln));	            t.normalize();	            va = new Vec3(lrf[0] - lln[0], lrf[1] - lln[1], lrf[2] - lln[2]);	            vb.set(llf[0] - lrn[0], llf[1] - lrn[1], llf[2] - lrn[2]);	            nb = va.cross(vb);	            b = new Plane(nb[0], nb[1], nb[2], -nb.dot(lrn));	            b.normalize();	            va = new Vec3(uln[0] - lrn[0], uln[1] - lrn[1], uln[2] - lrn[2]);	            vb.set(urn[0] - lln[0], urn[1] - lln[1], urn[2] - lln[2]);	            nn = va.cross(vb);	            n = new Plane(nn[0], nn[1], nn[2], -nn.dot(lln));	            n.normalize();	            va = new Vec3(urf[0] - llf[0], urf[1] - llf[1], urf[2] - llf[2]);	            vb.set(ulf[0] - lrf[0], ulf[1] - lrf[1], ulf[2] - lrf[2]);	            nf = va.cross(vb);	            f = new Plane(nf[0], nf[1], nf[2], -nf.dot(llf));	            f.normalize();	            this.pickFrustum = new Frustum(l, r, b, t, n, f);	            return true;	        };	        DrawContext.prototype.isSmall = function (extent, numPixels) {	            if (!extent) {	                return false;	            }	            var distance = this.navigatorState.eyePoint.distanceTo(extent.center),	                pixelSize = this.navigatorState.pixelSizeAtDistance(distance);	            return (2 * extent.radius) < (numPixels * pixelSize); 	        };	        DrawContext.prototype.unitCubeBuffer = function () {	            var vboId = this.gpuResourceCache.resourceForKey(DrawContext.unitCubeKey);	            if (!vboId) {	                var gl = this.currentGlContext,	                    points = new Float32Array(24),	                    i = 0;	                points[i++] = 0; 	                points[i++] = 1;	                points[i++] = 0;	                points[i++] = 0; 	                points[i++] = 0;	                points[i++] = 0;	                points[i++] = 1; 	                points[i++] = 1;	                points[i++] = 0;	                points[i++] = 1; 	                points[i++] = 0;	                points[i++] = 0;	                points[i++] = 0; 	                points[i++] = 1;	                points[i++] = 1;	                points[i++] = 0; 	                points[i++] = 0;	                points[i++] = 1;	                points[i++] = 1; 	                points[i++] = 1;	                points[i++] = 1;	                points[i++] = 1; 	                points[i++] = 0;	                points[i] = 1;	                vboId = gl.createBuffer();	                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);	                gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);	                gl.bindBuffer(gl.ARRAY_BUFFER, null);	                this.frameStatistics.incrementVboLoadCount(1);	                this.gpuResourceCache.putResource(DrawContext.unitCubeKey, vboId, points.length * 4);	            }	            return vboId;	        };	        DrawContext.prototype.unitCubeElements = function () {	            var vboId = this.gpuResourceCache.resourceForKey(DrawContext.unitCubeElementsKey);	            if (!vboId) {	                var gl = this.currentGlContext,	                    elems = new Int16Array(60),	                    i = 0;	                elems[i++] = 1; 	                elems[i++] = 0;	                elems[i++] = 3;	                elems[i++] = 3;	                elems[i++] = 0;	                elems[i++] = 2;	                elems[i++] = 4; 	                elems[i++] = 5;	                elems[i++] = 6;	                elems[i++] = 6;	                elems[i++] = 5;	                elems[i++] = 7;	                elems[i++] = 5; 	                elems[i++] = 1;	                elems[i++] = 7;	                elems[i++] = 7;	                elems[i++] = 1;	                elems[i++] = 3;	                elems[i++] = 6; 	                elems[i++] = 2;	                elems[i++] = 4;	                elems[i++] = 4;	                elems[i++] = 2;	                elems[i++] = 0;	                elems[i++] = 4; 	                elems[i++] = 0;	                elems[i++] = 5;	                elems[i++] = 5;	                elems[i++] = 0;	                elems[i++] = 1;	                elems[i++] = 7; 	                elems[i++] = 3;	                elems[i++] = 6;	                elems[i++] = 6;	                elems[i++] = 3;	                elems[i++] = 2;	                elems[i++] = 0; 	                elems[i++] = 1;	                elems[i++] = 1; 	                elems[i++] = 3;	                elems[i++] = 3; 	                elems[i++] = 2;	                elems[i++] = 2; 	                elems[i++] = 0;	                elems[i++] = 4; 	                elems[i++] = 5;	                elems[i++] = 5; 	                elems[i++] = 7;	                elems[i++] = 7; 	                elems[i++] = 6;	                elems[i++] = 6; 	                elems[i++] = 4;	                elems[i++] = 0; 	                elems[i++] = 4;	                elems[i++] = 5; 	                elems[i++] = 1;	                elems[i++] = 2; 	                elems[i++] = 6;	                elems[i++] = 7; 	                elems[i] = 3;	                vboId = gl.createBuffer();	                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboId);	                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, elems, gl.STATIC_DRAW);	                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);	                this.frameStatistics.incrementVboLoadCount(1);	                this.gpuResourceCache.putResource(DrawContext.unitCubeElementsKey, vboId, elems.length * 2);	            }	            return vboId;	        };	        DrawContext.prototype.unitQuadBuffer = function () {	            var vboId = this.gpuResourceCache.resourceForKey(DrawContext.unitQuadKey);	            if (!vboId) {	                var gl = this.currentGlContext,	                    points = new Float32Array(8);	                points[0] = 0; 	                points[1] = 1;	                points[2] = 0; 	                points[3] = 0;	                points[4] = 1; 	                points[5] = 1;	                points[6] = 1; 	                points[7] = 0;	                vboId = gl.createBuffer();	                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);	                gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);	                gl.bindBuffer(gl.ARRAY_BUFFER, null);	                this.frameStatistics.incrementVboLoadCount(1);	                this.gpuResourceCache.putResource(DrawContext.unitQuadKey, vboId, points.length * 4);	            }	            return vboId;	        };	        DrawContext.prototype.unitQuadBuffer3 = function () {	            var vboId = this.gpuResourceCache.resourceForKey(DrawContext.unitQuadKey3);	            if (!vboId) {	                var gl = this.currentGlContext,	                    points = new Float32Array(12);	                points[0] = 0; 	                points[1] = 1;	                points[2] = 0;	                points[3] = 0; 	                points[4] = 0;	                points[5] = 0;	                points[6] = 1; 	                points[7] = 1;	                points[8] = 0;	                points[9] = 1; 	                points[10] = 0;	                points[11] = 0;	                vboId = gl.createBuffer();	                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);	                gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);	                gl.bindBuffer(gl.ARRAY_BUFFER, null);	                this.frameStatistics.incrementVboLoadCount(1);	                this.gpuResourceCache.putResource(DrawContext.unitQuadKey3, vboId, points.length * 4);	            }	            return vboId;	        };	        DrawContext.prototype.surfacePointForMode = function (latitude, longitude, offset, altitudeMode, result) {	            if (this.terrain) {	                this.terrain.surfacePointForMode(latitude, longitude, offset, altitudeMode, result);	            } else {	                var h = offset + this.globe.elevationAtLocation(latitude, longitude) * this.verticalExaggeration;	                this.globe.computePointFromPosition(latitude, longitude, h, result);	            }	            return result;	        };	        return DrawContext;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {	        "use strict";	        var PickedObjectList = function () {	            this.objects = [];	        };	        PickedObjectList.prototype.hasNonTerrainObjects = function () {	            return this.objects.length > 1 || (this.objects.length === 1 && this.terrainObject() == null);	        };	        PickedObjectList.prototype.terrainObject = function () {	            for (var i = 0, len = this.objects.length; i < len; i++) {	                if (this.objects[i].isTerrain) {	                    return this.objects[i];	                }	            }	            return null;	        };	        PickedObjectList.prototype.add = function (pickedObject) {	            if (pickedObject) {	                if (pickedObject.isTerrain) {	                    var terrainObjectIndex = this.objects.length;	                    for (var i = 0, len = this.objects.length; i < len; i++) {	                        if (this.objects[i].isTerrain) {	                            terrainObjectIndex = i;	                            break;	                        }	                    }	                    this.objects[terrainObjectIndex] = pickedObject;	                } else {	                    this.objects.push(pickedObject);	                }	            }	        };	        PickedObjectList.prototype.clear = function () {	            this.objects = [];	        };	        PickedObjectList.prototype.topPickedObject = function () {	            var size = this.objects.length;	            if (size > 1) {	                for (var i = 0; i < size; i++) {	                    if (this.objects[[i].isOnTop]) {	                        return this.objects[i];	                    }	                }	            }	            if (size > 0) {	                return this.objects[0];	            }	            return null;	        };	        return PickedObjectList;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(9),	        __webpack_require__(19)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Logger) {	        "use strict";	        var FramebufferTexture = function (gl, width, height, depth) {	            this.width = width;	            this.height = height;	            this.depth = depth;	            this.size = (width * height * 4) + (depth ? width * height * 2 : 0);	            this.framebufferId = gl.createFramebuffer();	            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebufferId);	            this.texture = gl.createTexture();	            gl.bindTexture(gl.TEXTURE_2D, this.texture);	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER,	                gl.LINEAR);	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER,	                gl.LINEAR);	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S,	                gl.CLAMP_TO_EDGE);	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T,	                gl.CLAMP_TO_EDGE);	            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0,	                gl.RGBA, gl.UNSIGNED_BYTE, null);	            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,	                gl.TEXTURE_2D, this.texture, 0);	            this.depthBuffer = null;	            if (depth) {	                this.depthBuffer = gl.createRenderbuffer();	                gl.bindRenderbuffer(gl.RENDERBUFFER, this.depthBuffer);	                gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16,	                    width, height);	                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,	                    gl.RENDERBUFFER, this.depthBuffer);	            }	            var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);	            if (e != gl.FRAMEBUFFER_COMPLETE) {	                Logger.logMessage(Logger.LEVEL_WARNING, "FramebufferTexture", "constructor",	                    "Error creating framebuffer: " + e);	                this.framebufferId = null;	                this.texture = null;	                this.depthBuffer = null;	            }	            gl.bindFramebuffer(gl.FRAMEBUFFER, null);	            gl.bindRenderbuffer(gl.RENDERBUFFER, null);	            gl.bindTexture(gl.TEXTURE_2D, null);	        };	        FramebufferTexture.prototype.bind = function (dc) {	            if (this.texture) {	                dc.currentGlContext.bindTexture(gl.TEXTURE_2D, this.texture);	            }	            return !!this.texture;	        };	        return FramebufferTexture;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(67),	        __webpack_require__(44),	        __webpack_require__(18),	        __webpack_require__(9),	        __webpack_require__(46),	        __webpack_require__(31),	        __webpack_require__(36)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              FramebufferTile,	              LevelSet,	              Location,	              Logger,	              MemoryCache,	              Sector,	              Tile) {	        "use strict";	        var FramebufferTileController = function () {	            this.tileWidth = 256;	            this.tileHeight = 256;	            this.detailControl = 1.75;	            this.levels = new LevelSet(Sector.FULL_SPHERE, new Location(45, 45), 16, this.tileWidth, this.tileHeight);	            this.topLevelTiles = [];	            this.currentTiles = [];	            this.currentTimestamp = null;	            this.currentGlobeStateKey = null;	            this.tileCache = new MemoryCache(500000, 400000);	            this.key = "FramebufferTileController " + ++FramebufferTileController.keyPool;	        };	        FramebufferTileController.keyPool = 0; 	        FramebufferTileController.prototype.selectTiles = function (dc, sector) {	            this.assembleTiles(dc);	            var tiles = [];	            for (var i = 0, len = this.currentTiles.length; i < len; i++) {	                var tile = this.currentTiles[i];	                if (tile.sector.overlaps(sector)) {	                    tile.selected = true;	                    tiles.push(tile);	                }	            }	            return tiles;	        };	        FramebufferTileController.prototype.render = function (dc) {	            if (this.currentTiles.length == 0) {	                return;	            }	            var tiles = [];	            for (var i = 0, len = this.currentTiles.length; i < len; i++) {	                var tile = this.currentTiles[i];	                if (tile.selected) {	                    tiles.push(tile);	                }	            }	            dc.surfaceTileRenderer.renderTiles(dc, tiles, 1);	            var gl = dc.currentGlContext,	                framebuffer = dc.currentFramebuffer;	            try {	                gl.clearColor(0, 0, 0, 0);	                for (i = 0, len = tiles.length; i < len; i++) {	                    tile = tiles[i];	                    tile.selected = false;	                    tile.bindFramebuffer(dc);	                    gl.clear(gl.COLOR_BUFFER_BIT);	                }	            } finally {	                dc.bindFramebuffer(framebuffer);	            }	        };	        FramebufferTileController.prototype.assembleTiles = function (dc) {	            var timestamp = dc.timestamp,	                globeStateKey = dc.globeStateKey;	            if (this.currentTimestamp != timestamp ||	                this.currentGlobeStateKey != globeStateKey) {	                this.doAssembleTiles(dc);	                this.currentTimestamp = timestamp;	                this.currentGlobeStateKey = globeStateKey;	            }	        };	        FramebufferTileController.prototype.doAssembleTiles = function (dc) {	            this.currentTiles = [];	            if (!dc.terrain) {	                return;	            }	            if (this.topLevelTiles.length == 0) {	                this.createTopLevelTiles();	            }	            for (var i = 0, len = this.topLevelTiles.length; i < len; i++) {	                var tile = this.topLevelTiles[i];	                tile.update(dc);	                if (this.isTileVisible(dc, tile)) {	                    this.addTileOrDescendants(dc, tile);	                }	            }	        };	        FramebufferTileController.prototype.createTile = function (sector, level, row, column) {	            var tileKey = this.key + " " + level.levelNumber + "." + row + "." + column;	            return new FramebufferTile(sector, level, row, column, tileKey);	        };	        FramebufferTileController.prototype.createTopLevelTiles = function () {	            Tile.createTilesForLevel(this.levels.firstLevel(), this, this.topLevelTiles);	        };	        FramebufferTileController.prototype.addTileOrDescendants = function (dc, tile) {	            if (this.tileMeetsRenderingCriteria(dc, tile)) {	                this.addTile(tile);	                return;	            }	            var subTiles = tile.subdivideToCache(tile.level.nextLevel(), this, this.tileCache);	            for (var i = 0, len = subTiles.length; i < len; i++) {	                var child = subTiles[i];	                child.update(dc);	                if (this.isTileVisible(dc, child)) {	                    this.addTileOrDescendants(dc, child);	                }	            }	        };	        FramebufferTileController.prototype.addTile = function (tile) {	            this.currentTiles.push(tile);	        };	        FramebufferTileController.prototype.isTileVisible = function (dc, tile) {	            if (dc.globe.projectionLimits && !tile.sector.overlaps(dc.globe.projectionLimits)) {	                return false;	            }	            if (dc.pickingMode) {	                return tile.extent.intersectsFrustum(dc.pickFrustum);	            }	            return tile.extent.intersectsFrustum(dc.navigatorState.frustumInModelCoordinates);	        };	        FramebufferTileController.prototype.tileMeetsRenderingCriteria = function (dc, tile) {	            var s = this.detailControl;	            if (tile.sector.minLatitude >= 75 || tile.sector.maxLatitude <= -75) {	                s *= 1.2;	            }	            return tile.level.isLastLevel() || !tile.mustSubdivide(dc, s);	        };	        return FramebufferTileController;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(65),	        __webpack_require__(9),	        __webpack_require__(13),	        __webpack_require__(20),	        __webpack_require__(68)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              FramebufferTexture,	              Logger,	              Matrix,	              Rectangle,	              TextureTile) {	        "use strict";	        var FramebufferTile = function (sector, level, row, column, cacheKey) {	            if (!cacheKey || (cacheKey.length < 1)) {	                throw new ArgumentError(	                    Logger.logMessage(Logger.LEVEL_SEVERE, "FramebufferTile", "constructor",	                        "The specified cache name is null, undefined or zero length."));	            }	            TextureTile.call(this, sector, level, row, column); 	            this.gpuCacheKey = cacheKey;	            this.textureTransform = Matrix.fromIdentity().setToUnitYFlip();	            this.mustClear = true;	        };	        FramebufferTile.prototype = Object.create(TextureTile.prototype);	        FramebufferTile.prototype.clearFramebuffer = function (dc) {	            this.mustClear = true;	        };	        FramebufferTile.prototype.bindFramebuffer = function (dc) {	            var framebuffer = dc.gpuResourceCache.resourceForKey(this.gpuCacheKey);	            if (!framebuffer) {	                framebuffer = this.createFramebuffer(dc);	            }	            dc.bindFramebuffer(framebuffer);	            if (this.mustClear) {	                this.doClearFramebuffer(dc);	                this.mustClear = false;	            }	            return true;	        };	        FramebufferTile.prototype.createFramebuffer = function (dc) {	            var framebuffer = new FramebufferTexture(dc.currentGlContext, this.tileWidth, this.tileHeight, false);	            dc.gpuResourceCache.putResource(this.gpuCacheKey, framebuffer, framebuffer.size);	            return framebuffer;	        };	        FramebufferTile.prototype.doClearFramebuffer = function (dc) {	            var gl = dc.currentGlContext;	            gl.clearColor(0, 0, 0, 0);	            gl.clear(gl.COLOR_BUFFER_BIT);	        };	        FramebufferTile.prototype.applyInternalTransform = function (dc, matrix) {	            matrix.multiplyMatrix(this.textureTransform);	        };	        return FramebufferTile;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(9),	        __webpack_require__(36)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Logger,	              Tile) {	        "use strict";	        var TextureTile = function (sector, level, row, column) {	            Tile.call(this, sector, level, row, column); 	            this.gpuCacheKey = null;	        };	        TextureTile.prototype = Object.create(Tile.prototype);	        TextureTile.prototype.size = function () {	            return Tile.prototype.size.call(this);	        };	        TextureTile.prototype.bind = function (dc) {	            var texture = dc.gpuResourceCache.resourceForKey(this.gpuCacheKey);	            if (texture) {	                return texture.bind(dc);	            }	            return false;	        };	        TextureTile.prototype.applyInternalTransform = function (dc, matrix) {	        };	        return TextureTile;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(9)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Logger) {	        "use strict";	        var Layer = function (displayName) {	            this.displayName = displayName ? displayName : "Layer";	            this.enabled = true;	            this.pickEnabled = true;	            this.opacity = 1;	            this.minActiveAltitude = -Number.MAX_VALUE;	            this.maxActiveAltitude = Number.MAX_VALUE;	            this.inCurrentFrame = false;	            this.time = null;	        };	        Layer.prototype.refresh = function () {	        };	        Layer.prototype.render = function (dc) {	            this.inCurrentFrame = false;	            if (!this.enabled)	                return;	            if (dc.pickingMode && !this.pickEnabled)	                return;	            if (!this.withinActiveAltitudes(dc))	                return;	            if (!this.isLayerInView(dc))	                return;	            this.doRender(dc);	        };	        Layer.prototype.doRender = function (dc) {	        };	        Layer.prototype.withinActiveAltitudes = function (dc) {	            var eyePosition = dc.eyePosition;	            if (!eyePosition)	                return false;	            return eyePosition.altitude >= this.minActiveAltitude && eyePosition.altitude <= this.maxActiveAltitude;	       };	        Layer.prototype.isLayerInView = function (dc) {	            return true; 	        };	        return Layer;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(73),	        __webpack_require__(40),	        __webpack_require__(72),	        __webpack_require__(9),	        __webpack_require__(13),	        __webpack_require__(71),	        __webpack_require__(53),	        __webpack_require__(74),	        __webpack_require__(16),	        __webpack_require__(19)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              BasicTextureProgram,	              Color,	              Font,	              Logger,	              Matrix,	              Offset,	              PickedObject,	              Renderable,	              Vec3,	              WWMath) {	        "use strict";	        var ScreenCreditController = function () {	            this.imageUrls = [];	            this.stringCredits = [];	            this.imageCreditSize = 64;	            this.margin = 5;	            this.opacity = 0.5;	            this.creditFont = new Font(14);	        };	        ScreenCreditController.scratchMatrix = Matrix.fromIdentity(); 	        ScreenCreditController.imageTransform = Matrix.fromIdentity(); 	        ScreenCreditController.texCoordMatrix = Matrix.fromIdentity(); 	        ScreenCreditController.prototype.clear = function () {	            this.imageUrls = [];	            this.stringCredits = [];	        };	        ScreenCreditController.prototype.addImageCredit = function (imageUrl) {	            if (this.imageUrls.indexOf(imageUrl) === -1) {	                this.imageUrls.push(imageUrl);	            }	        };	        ScreenCreditController.prototype.addStringCredit = function (stringCredit, color) {	            if (this.stringCredits.indexOf(stringCredit) === -1) {	                this.stringCredits.push({	                    text: stringCredit,	                    color: color || Color.WHITE	                });	            }	        };	        ScreenCreditController.prototype.drawCredits = function (dc) {	            if ((this.imageUrls.length === 0 && this.stringCredits.length === 0)) {	                return;	            }	            if (dc.pickingMode) {	                return;	            }	            if (dc.timestamp == this.lastFrameTimestamp) {	                return;	            }	            this.lastFrameTimestamp = dc.timestamp;	            this.beginDrawingCredits(dc);	            var imageX = dc.navigatorState.viewport.width - (this.margin + this.imageCreditSize),	                imageHeight, maxImageHeight = 0;	            for (var i = 0; i < this.imageUrls.length; i++) {	                imageHeight = this.drawImageCredit(dc, this.imageUrls[i], imageX, this.margin);	                if (imageHeight > 0) {	                    imageX -= (this.margin + this.imageCreditSize);	                    maxImageHeight = WWMath.max(imageHeight, maxImageHeight);	                }	            }	            var stringY = maxImageHeight + this.margin;	            for (var j = 0; j < this.stringCredits.length; j++) {	                this.drawStringCredit(dc, this.stringCredits[j], stringY);	                stringY += this.margin + 15; 	            }	            this.endDrawingCredits(dc);	        };	        ScreenCreditController.prototype.beginDrawingCredits = function (dc) {	            var gl = dc.currentGlContext,	                program;	            dc.findAndBindProgram(BasicTextureProgram);	            program = dc.currentProgram;	            gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer3());	            gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);	            gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer());	            gl.vertexAttribPointer(program.vertexTexCoordLocation, 2, gl.FLOAT, false, 0, 0);	            gl.enableVertexAttribArray(program.vertexPointLocation);	            gl.enableVertexAttribArray(program.vertexTexCoordLocation);	            program.loadTextureUnit(gl, gl.TEXTURE0);	            program.loadModulateColor(gl, false);	        };	        ScreenCreditController.prototype.endDrawingCredits = function (dc) {	            var gl = dc.currentGlContext,	                program = dc.currentProgram;	            gl.disableVertexAttribArray(program.vertexPointLocation);	            gl.disableVertexAttribArray(program.vertexTexCoordLocation);	            gl.bindBuffer(gl.ARRAY_BUFFER, null);	            gl.bindTexture(gl.TEXTURE_2D, null);	            gl.enable(gl.DEPTH_TEST);	        };	        ScreenCreditController.prototype.drawImageCredit = function (dc, creditUrl, x, y) {	            var imageWidth, imageHeight, scale, activeTexture, gl, program;	            activeTexture = dc.gpuResourceCache.resourceForKey(creditUrl);	            if (!activeTexture) {	                dc.gpuResourceCache.retrieveTexture(dc.currentGlContext, creditUrl);	                return 0;	            }	            imageWidth = activeTexture.imageWidth;	            imageHeight = activeTexture.imageHeight;	            if (imageWidth <= this.imageCreditSize && this.imageHeight <= this.imageCreditSize) {	                scale = 1;	            } else if (imageWidth >= imageHeight) {	                scale = this.imageCreditSize / imageWidth;	            } else {	                scale = this.imageCreditSize / imageHeight;	            }	            ScreenCreditController.imageTransform.setTranslation(x, y, 0);	            ScreenCreditController.imageTransform.setScale(scale * imageWidth, scale * imageHeight, 1);	            gl = dc.currentGlContext;	            program = dc.currentProgram;	            ScreenCreditController.scratchMatrix.copy(dc.screenProjection);	            ScreenCreditController.scratchMatrix.multiplyMatrix(ScreenCreditController.imageTransform);	            program.loadModelviewProjection(gl, ScreenCreditController.scratchMatrix);	            program.loadTextureEnabled(gl, true);	            program.loadColor(gl, Color.WHITE);	            program.loadOpacity(gl, this.opacity);	            ScreenCreditController.texCoordMatrix.setToIdentity();	            ScreenCreditController.texCoordMatrix.multiplyByTextureTransform(activeTexture);	            program.loadTextureMatrix(gl, ScreenCreditController.texCoordMatrix);	            if (activeTexture.bind(dc)) { 	                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);	            }	            return imageHeight;	        };	        ScreenCreditController.prototype.drawStringCredit = function (dc, credit, y) {	            var imageWidth, imageHeight, activeTexture, textureKey, gl, program, x;	            textureKey = credit.text + this.creditFont.toString();	            activeTexture = dc.gpuResourceCache.resourceForKey(textureKey);	            if (!activeTexture) {	                activeTexture = dc.textSupport.createTexture(dc, credit.text, this.creditFont, false);	                dc.gpuResourceCache.putResource(textureKey, activeTexture, activeTexture.size);	            }	            imageWidth = activeTexture.imageWidth;	            imageHeight = activeTexture.imageHeight;	            x = dc.navigatorState.viewport.width - (imageWidth + this.margin);	            ScreenCreditController.imageTransform.setTranslation(x, y, 0);	            ScreenCreditController.imageTransform.setScale(imageWidth, imageHeight, 1);	            gl = dc.currentGlContext;	            program = dc.currentProgram;	            ScreenCreditController.scratchMatrix.copy(dc.screenProjection);	            ScreenCreditController.scratchMatrix.multiplyMatrix(ScreenCreditController.imageTransform);	            program.loadModelviewProjection(gl, ScreenCreditController.scratchMatrix);	            program.loadTextureEnabled(gl, true);	            program.loadColor(gl, credit.color);	            program.loadOpacity(gl, this.opacity);	            ScreenCreditController.texCoordMatrix.setToIdentity();	            ScreenCreditController.texCoordMatrix.multiplyByTextureTransform(activeTexture);	            program.loadTextureMatrix(gl, ScreenCreditController.texCoordMatrix);	            if (activeTexture.bind(dc)) { 	                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);	            }	            return true;	        };	        return ScreenCreditController;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(24)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Vec2) {	        "use strict";	        var Offset = function (xUnits, x, yUnits, y) {	            this.x = x;	            this.y = y;	            this.xUnits = xUnits;	            this.yUnits = yUnits;	        };	        Offset.prototype.clone = function () {	            return new Offset(this.xUnits, this.x, this.yUnits, this.y);	        };	        Offset.prototype.offsetForSize = function (width, height) {	            var x, y;	            if (this.xUnits == WorldWind.OFFSET_FRACTION) {	                x = width * this.x;	            } else if (this.xUnits == WorldWind.OFFSET_INSET_PIXELS) {	                x = width - this.x;	            } else { 	                x = this.x;	            }	            if (this.yUnits == WorldWind.OFFSET_FRACTION) {	                y = height * this.y;	            } else if (this.yUnits == WorldWind.OFFSET_INSET_PIXELS) {	                y = height - this.y;	            } else { 	                y = this.y;	            }	            return new Vec2(x, y);	        };	        Offset.prototype.toString = function () {	            return this.xUnits + " " + this.x + " " + this.yUnits + " " + this.y;	        };	        return Offset;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(40),	        __webpack_require__(9)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Color,	              Logger) {	        "use strict";	        var Font = function (size, style, variant, weight, family, horizontalAlignment) {	             {	                this._size = size;	            }	            this.style = style || "normal";	            this.variant = variant || "normal";	            this.weight = weight || "normal";	            this.family = family || "sans-serif";	            this.horizontalAlignment = horizontalAlignment || "center";	        };	        Object.defineProperties(Font.prototype, {	            size: {	                get: function () {	                    return this._size;	                },	                set: function (value) {	                    this._fontString = null;	                    this._size = value;	                }	            },	            style: {	                get: function () {	                    return this._style;	                },	                set: function (value) {	                    this._fontString = null;	                    this._style = value;	                }	            },	            variant: {	                get: function () {	                    return this._variant;	                },	                set: function (value) {	                    this._fontString = null;	                    this._variant = value;	                }	            },	            weight: {	                get: function () {	                    return this._weight;	                },	                set: function (value) {	                    this._fontString = null;	                    this._weight = value;	                }	            },	            family: {	                get: function () {	                    return this._family;	                },	                set: function (value) {	                    this._fontString = null;	                    this._family = value;	                }	            },	            horizontalAlignment: {	                get: function () {	                    return this._horizontalAlignment;	                },	                set: function (value) {	                    this._toString = null;	                    this._horizontalAlignment = value;	                }	            },	            fontString: {	                get: function () {	                    if (!this._fontString) {	                        this._fontString =	                            this._style + " " +	                            this.variant + " " +	                            this._weight + " " +	                            this._size.toString() + "px " +	                            this._family;	                    }	                    return this._fontString;	                }	            }	        });	        Font.prototype.toString = function () {	            if (!this._toString || !this._fontString) {	                this._toString = this.fontString + " " + this.horizontalAlignment;	            }	            return this._toString;	        };	        return Font;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(40),	        __webpack_require__(41),	        __webpack_require__(9)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Color,	              GpuProgram,	              Logger) {	        "use strict";	        var BasicTextureProgram = function (gl) {	            var vertexShaderSource =	                    'attribute vec4 vertexPoint;\n' +	                    'attribute vec4 vertexTexCoord;\n' +	                    'attribute vec4 normalVector;\n' +	                    'uniform mat4 mvpMatrix;\n' +	                    'uniform mat4 mvInverseMatrix;\n' +	                    'uniform mat4 texCoordMatrix;\n' +	                    'uniform bool applyLighting;\n' +	                    'varying vec2 texCoord;\n' +	                    'varying vec4 normal;\n' +	                    'void main() {gl_Position = mvpMatrix * vertexPoint;\n' +	                    'texCoord = (texCoordMatrix * vertexTexCoord).st;\n' +	                    'if (applyLighting) {normal = mvInverseMatrix * normalVector;}\n' +	                    '}',	                fragmentShaderSource =	                    'precision mediump float;\n' +	                    'uniform float opacity;\n' +	                    'uniform vec4 color;\n' +	                    'uniform bool enableTexture;\n' +	                    'uniform bool modulateColor;\n' +	                    'uniform sampler2D textureSampler;\n' +	                    'uniform bool applyLighting;\n' +	                    'varying vec2 texCoord;\n' +	                    'varying vec4 normal;\n' +	                    'void main() {\n' +	                    'vec4 textureColor = texture2D(textureSampler, texCoord);\n' +	                    'float ambient = 0.15; vec4 lightDirection = vec4(0, 0, 1, 0);\n' +	                    'if (enableTexture && !modulateColor)\n' +	                    '    gl_FragColor = textureColor * color * opacity;\n' +	                    'else if (enableTexture && modulateColor)\n' +	                    '    gl_FragColor = color * floor(textureColor.a + 0.5);\n' +	                    'else\n' +	                    '    gl_FragColor = color * opacity;\n' +	                    'if (gl_FragColor.a == 0.0) {discard;}\n' +	                    'if (applyLighting) {\n' +	                    '    vec4 n = normal * (gl_FrontFacing ? 1.0 : -1.0);\n' +	                    '    gl_FragColor.rgb *= clamp(ambient + dot(lightDirection, n), 0.0, 1.0);\n' +	                    '}\n' +	                    '}';	            var bindings = ["vertexPoint", "normalVector", "vertexTexCoord"];	            GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, bindings);	            this.vertexPointLocation = this.attributeLocation(gl, "vertexPoint");	            this.normalVectorLocation = this.attributeLocation(gl, "normalVector");	            this.vertexTexCoordLocation = this.attributeLocation(gl, "vertexTexCoord");	            this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");	            this.mvInverseMatrixLocation = this.uniformLocation(gl, "mvInverseMatrix");	            this.colorLocation = this.uniformLocation(gl, "color");	            this.textureEnabledLocation = this.uniformLocation(gl, "enableTexture");	            this.modulateColorLocation = this.uniformLocation(gl, "modulateColor");	            this.textureUnitLocation = this.uniformLocation(gl, "textureSampler");	            this.textureMatrixLocation = this.uniformLocation(gl, "texCoordMatrix");	            this.opacityLocation = this.uniformLocation(gl, "opacity");	            this.applyLightingLocation = this.uniformLocation(gl, "applyLighting");	        };	        BasicTextureProgram.key = "WorldWindGpuBasicTextureProgram";	        BasicTextureProgram.prototype = Object.create(GpuProgram.prototype);	        BasicTextureProgram.prototype.loadModelviewInverse = function (gl, matrix) {	            this.loadUniformMatrix(gl, matrix, this.mvInverseMatrixLocation);	        };	        BasicTextureProgram.prototype.loadModelviewProjection = function (gl, matrix) {	            this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);	        };	        BasicTextureProgram.prototype.loadColor = function (gl, color) {	            this.loadUniformColor(gl, color, this.colorLocation);	        };	        BasicTextureProgram.prototype.loadTextureEnabled = function (gl, enable) {	            gl.uniform1i(this.textureEnabledLocation, enable ? 1 : 0);	        };	        BasicTextureProgram.prototype.loadModulateColor = function (gl, enable) {	            gl.uniform1i(this.modulateColorLocation, enable ? 1 : 0);	        };	        BasicTextureProgram.prototype.loadTextureUnit = function (gl, unit) {	            gl.uniform1i(this.textureUnitLocation, unit - gl.TEXTURE0);	        };	        BasicTextureProgram.prototype.loadTextureMatrix = function (gl, matrix) {	            this.loadUniformMatrix(gl, matrix, this.textureMatrixLocation);	        };	        BasicTextureProgram.prototype.loadOpacity = function (gl, opacity) {	            gl.uniform1f(this.opacityLocation, opacity);	        };	        BasicTextureProgram.prototype.loadApplyLighting = function (gl, applyLighting) {	            gl.uniform1i(this.applyLightingLocation, applyLighting);	        };	        return BasicTextureProgram;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(9),	        __webpack_require__(25)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Logger,	              UnsupportedOperationError) {	        "use strict";	        var Renderable = function () {	            this.displayName = "Renderable";	            this.enabled = true;	            this.pickDelegate = null;	            this.userProperties = {};	        };	        Renderable.prototype.render = function (dc) {	            throw new UnsupportedOperationError(	                Logger.logMessage(Logger.LEVEL_SEVERE, "Renderable", "render", "abstractInvocation"));	        };	        return Renderable;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(8),	        __webpack_require__(11),	        __webpack_require__(7),	        __webpack_require__(18),	        __webpack_require__(9),	        __webpack_require__(38),	        __webpack_require__(53),	        __webpack_require__(74),	        __webpack_require__(31),	        __webpack_require__(76),	        __webpack_require__(25),	        __webpack_require__(19)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (AbstractError,	              Angle,	              ArgumentError,	              Location,	              Logger,	              NotYetImplementedError,	              PickedObject,	              Renderable,	              Sector,	              ShapeAttributes,	              UnsupportedOperationError,	              WWMath) {	        "use strict";	        var SurfaceShape = function (attributes) {	            Renderable.call(this);	            this._displayName = "Surface Shape";	            this._attributes = attributes ? attributes : new ShapeAttributes(null);	            this._highlightAttributes = null;	            this._highlighted = false;	            this._enabled = true;	            this._pathType = WorldWind.GREAT_CIRCLE;	            this._maximumNumEdgeIntervals = SurfaceShape.DEFAULT_NUM_EDGE_INTERVALS;	            this._polarThrottle = SurfaceShape.DEFAULT_POLAR_THROTTLE;	            this._sector = null;	            this.pickDelegate = null;	            this._sectors = [];	            this._locations = null;	            this._boundaries = null;	            this._interiorGeometry = null;	            this._outlineGeometry = null;	            this._isInteriorInhibited = false;	            this.stateKeyInvalid = true;	            this._attributesStateKey = null;	            this.isPrepared = false;	            this.layer = null;	            this.pickColor = null;	        };	        SurfaceShape.prototype = Object.create(Renderable.prototype);	        Object.defineProperties(SurfaceShape.prototype, {	            stateKey: {	                get: function() {	                    if (!this._attributesStateKey) {	                        if (this._highlighted) {	                            if (!!this._highlightAttributes) {	                                this._attributesStateKey = this._highlightAttributes.stateKey;	                            }	                        } else {	                            if (!!this._attributes) {	                                this._attributesStateKey = this._attributes.stateKey;	                            }	                        }	                        if (!!this._attributesStateKey) {	                            this.stateKeyInvalid = true;	                        }	                    } else {	                        var currentAttributesStateKey = null;	                        if (this._highlighted) {	                            if (!!this._highlightAttributes) {	                                currentAttributesStateKey = this._highlightAttributes.stateKey;	                            }	                        } else {	                            if (!!this._attributes) {	                                currentAttributesStateKey = this._attributes.stateKey;	                            }	                        }	                        if (currentAttributesStateKey != this._attributesStateKey) {	                            this._attributesStateKey = currentAttributesStateKey;	                            this.stateKeyInvalid = true;	                        }	                    }	                    if (this.stateKeyInvalid) {	                        this._stateKey = this.computeStateKey();	                    }	                    return this._stateKey;	                }	            },	            displayName: {	                get: function() {	                    return this._displayName;	                },	                set: function(value) {	                    this.stateKeyInvalid = true;	                    this._displayName = value;	                }	            },	            attributes: {	                get: function() {	                    return this._attributes;	                },	                set: function(value) {	                    this.stateKeyInvalid = true;	                    this._attributes = value;	                    this._attributesStateKey = value.stateKey;	                }	            },	            highlightAttributes: {	                get: function() {	                    return this._highlightAttributes;	                },	                set: function(value) {	                    this.stateKeyInvalid = true;	                    this._highlightAttributes = value;	                }	            },	            highlighted: {	                get: function() {	                    return this._highlighted;	                },	                set: function(value) {	                    this.stateKeyInvalid = true;	                    this._highlighted = value;	                }	            },	            enabled: {	                get: function() {	                    return this._enabled;	                },	                set: function(value) {	                    this.stateKeyInvalid = true;	                    this._enabled = value;	                }	            },	            pathType: {	                get: function() {	                    return this._pathType;	                },	                set: function(value) {	                    this.stateKeyInvalid = true;	                    this._pathType = value;	                }	            },	            maximumNumEdgeIntervals: {	                get: function() {	                    return this._maximumNumEdgeIntervals;	                },	                set: function(value) {	                    this.stateKeyInvalid = true;	                    this._maximumNumEdgeIntervals = value;	                }	            },	            polarThrottle: {	                get: function () {	                    return this._polarThrottle;	                },	                set: function (value) {	                    this.stateKeyInvalid = true;	                    this._polarThrottle = value;	                }	            },	            sector: {	                get: function() {	                    return this._sector;	                }	            }	        });	        SurfaceShape.staticStateKey = function(shape) {	            shape.stateKeyInvalid = false;	            if (shape.highlighted) {	                if (!shape._highlightAttributes) {	                    if (!shape._attributes) {	                        shape._attributesStateKey = null;	                    } else {	                        shape._attributesStateKey = shape._attributes.stateKey;	                    }	                } else {	                    shape._attributesStateKey = shape._highlightAttributes.stateKey;	                }	            } else {	                if (!shape._attributes) {	                    shape._attributesStateKey = null;	                } else {	                    shape._attributesStateKey = shape._attributes.stateKey;	                }	            }	            return   "dn " + shape.displayName +	                    " at " + (!shape._attributesStateKey ? "null" : shape._attributesStateKey) +	                    " hi " + shape.highlighted +	                    " en " + shape.enabled +	                    " pt " + shape.pathType +	                    " ne " + shape.maximumNumEdgeIntervals +	                    " po " + shape.polarThrottle +	                    " se " + "[" +	                        shape.sector.minLatitude + "," +	                        shape.sector.maxLatitude + "," +	                        shape.sector.minLongitude + "," +	                        shape.sector.maxLongitude +	                    "]";	        };	        SurfaceShape.prototype.computeStateKey = function() {	            return SurfaceShape.staticStateKey(this);	        };	        SurfaceShape.prototype.area = function (globe, terrainConformant) {	            throw new NotYetImplementedError(	                Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceShape", "area", "notYetImplemented"));	        };	        SurfaceShape.prototype.computeBoundaries = function(globe) {	            throw new AbstractError(	                Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceShape", "computeBoundaries", "abstractInvocation"));	        };	        SurfaceShape.prototype.render = function(dc) {	            if (!this.enabled) {	                return;	            }	            this.layer = dc.currentLayer;	            this.prepareBoundaries(dc);	            dc.surfaceShapeTileBuilder.insertSurfaceShape(this);	        };	        SurfaceShape.prototype.interpolateLocations = function(locations) {	            var first  = locations[0],	                next = first,	                prev,	                isNextFirst = true,	                isPrevFirst = true,	                countFirst = 0,	                isInterpolated = true,	                idx, len;	            this._locations = [first];	            for (idx = 1, len = locations.length; idx < len; idx += 1) {	                prev = next;	                isPrevFirst = isNextFirst;	                next = locations[idx];	                isNextFirst = next.latitude == first.latitude && next.longitude == first.longitude;	                isInterpolated = true;	                if (isNextFirst || isPrevFirst) {	                    countFirst += 1;	                    if (countFirst > 2) {	                        isInterpolated = false;	                    }	                }	                if (isInterpolated) {	                    this.interpolateEdge(prev, next, this._locations);	                }	                this._locations.push(next);	                prev = next;	            }	            if (!this._isInteriorInhibited) {	                if (prev.latitude != first.latitude || prev.longitude != first.longitude) {	                    this.interpolateEdge(prev, first, this._locations);	                    this._locations.push(first);	                }	            }	        };	        SurfaceShape.prototype.interpolateEdge = function(start, end, locations) {	            var distanceRadians = Location.greatCircleDistance(start, end),	                steps = Math.round(this._maximumNumEdgeIntervals * distanceRadians / Math.PI),	                dt,	                location;	            if (steps > 0) {	                dt = 1 / steps;	                location = start;	                for (var t = this.throttledStep(dt, location); t < 1; t += this.throttledStep(dt, location)) {	                    location = new Location(0, 0);	                    Location.interpolateAlongPath(this._pathType, t, start, end, location);	                    locations.push(location);	                }	            }	        };	        SurfaceShape.prototype.throttledStep = function(dt, location) {	            var cosLat = Math.cos(location.latitude * Angle.DEGREES_TO_RADIANS);	            cosLat *= cosLat; 	            var weight = this._polarThrottle / (1 + this._polarThrottle);	            return dt * ((1 - weight) + weight * cosLat);	        };	        SurfaceShape.prototype.prepareBoundaries = function(dc) {	            if (this.isPrepared) return;	            if (!this._boundaries) {	                this.computeBoundaries(dc);	            }	            if (!this._locations) {	                this.interpolateLocations(this._boundaries);	            }	            this.prepareGeometry(dc);	            this.prepareSectors();	            this.isPrepared = true;	        };	        SurfaceShape.prototype.computeSectors = function(dc) {	            if (this._sectors && this._sectors.length > 0) {	                return this._sectors;	            }	            this.prepareBoundaries(dc);	            return this._sectors;	        };	        SurfaceShape.prototype.prepareSectors = function() {	            var boundaries = this._boundaries;	            if (!boundaries) {	                return;	            }	            this._sector = new Sector(-90, 90, -180, 180);	            this._sector.setToBoundingSector(boundaries);	            var pole = this.containsPole(boundaries);	            if (pole != Location.poles.NONE) {	                if (pole == Location.poles.NORTH) {	                    this._sector = new Sector(this._sector.minLatitude, 90, -180, 180);	                }	                else {	                    this._sector = new Sector(-90, this._sector.maxLatitude, -180, 180);	                }	                this._sectors = [this._sector];	            }	            else if (Location.locationsCrossDateLine(boundaries)) {	                this._sectors = Sector.splitBoundingSectors(boundaries);	            }	            else {	                 if (!this._sector.isEmpty()) {	                    this._sectors = [this._sector];	                }	            }	            if (!this._sectors) {	                return;	            }	            if (this._pathType === WorldWind.GREAT_CIRCLE) {	                for (var idx = 0, len = this._sectors.length; idx < len; idx += 1) {	                    var sector = this._sectors[idx];	                    var extremes = Location.greatCircleArcExtremeLocations(boundaries);	                    var minLatitude = Math.min(sector.minLatitude, extremes[0].latitude);	                    var maxLatitude = Math.max(sector.maxLatitude, extremes[1].latitude);	                    this._sectors[idx] = new Sector(minLatitude, maxLatitude, sector.minLongitude, sector.maxLongitude);	                }	            }	        };	        SurfaceShape.prototype.prepareGeometry = function(dc) {	            var datelineLocations;	            this._interiorGeometry = [];	            this._outlineGeometry = [];	            var locations = this._locations;	            var pole = this.containsPole(locations);	            if (pole != Location.poles.NONE) {	                var poleLocations = this.cutAlongDateLine(locations, pole, dc.globe);	                this._interiorGeometry.push(poleLocations);	                datelineLocations = this.repeatAroundDateline(locations);	                this._outlineGeometry.push(datelineLocations[0]);	                if (datelineLocations.length > 1) {	                    this._outlineGeometry.push(datelineLocations[1]);	                }	            }	            else if (Location.locationsCrossDateLine(locations)) {	                datelineLocations = this.repeatAroundDateline(locations);	                this._interiorGeometry.push(datelineLocations[0]); 	                this._interiorGeometry.push(datelineLocations[1]); 	                this._outlineGeometry.push(datelineLocations[0]); 	                this._outlineGeometry.push(datelineLocations[1]); 	            }	            else {	                this._interiorGeometry.push(locations);	                this._outlineGeometry.push(locations);	            }	        };	        SurfaceShape.prototype.containsPole = function(locations) {	            var containsPole = false;	            var minLatitude = 90.0;	            var maxLatitude = -90.0;	            var prev = locations[0];	            for (var idx = 1, len = locations.length; idx < len; idx += 1) {	                var next = locations[idx];	                if (Location.locationsCrossDateLine([prev, next])) {	                    containsPole = !containsPole;	                }	                minLatitude = Math.min(minLatitude, next.latitude);	                maxLatitude = Math.max(maxLatitude, next.latitude);	                prev = next;	            }	            var first = locations[0];	            if (Location.locationsCrossDateLine([first, prev])) {	                containsPole = !containsPole;	            }	            if (!containsPole) {	                return Location.poles.NONE;	            }	            if (minLatitude > 0) {	                return Location.poles.NORTH; 	            }	            else if (maxLatitude < 0) {	                return Location.poles.SOUTH; 	            }	            else if (Math.abs(maxLatitude) >= Math.abs(minLatitude)) {	                return Location.poles.NORTH; 	            }	            else {	                return Location.poles.SOUTH; 	            }	        };	        SurfaceShape.prototype.cutAlongDateLine = function(locations, pole, globe)	        {	            if (pole == Location.poles.NONE) {	                return locations;	            }	            var newLocations = [];	            var poleLat = pole == Location.poles.NORTH ? 90 : -90;	            var prev = locations[locations.length - 1];	            for (var idx = 0, len = locations.length; idx < len; idx += 1) {	                var next = locations[idx];	                newLocations.push(prev);	                if (Location.locationsCrossDateLine([prev, next])) {	                    var latitude = Location.intersectionWithMeridian(prev, next, 180, globe);	                    var sign = WWMath.signum(prev.longitude);	                    var lat = latitude;	                    var thisSideLon = 180 * sign;	                    var otherSideLon = -thisSideLon;	                    newLocations.push(new Location(lat, thisSideLon));	                    newLocations.push(new Location(poleLat, thisSideLon));	                    newLocations.push(new Location(poleLat, otherSideLon));	                    newLocations.push(new Location(lat, otherSideLon));	                }	                prev = next;	            }	            newLocations.push(prev);	            return newLocations;	        };	        SurfaceShape.prototype.repeatAroundDateline = function(locations) {	            var lonOffset = 0,	                applyLonOffset = false;	            var newLocations = [];	            var prev= locations[0];	            newLocations.push(prev);	            for (var idx = 1, len = locations.length; idx < len; idx += 1) {	                var next = locations[idx];	                if (Location.locationsCrossDateLine([prev, next])) {	                    if (lonOffset == 0) {	                        lonOffset = prev.longitude < 0 ? -360 : 360;	                    }	                    applyLonOffset = !applyLonOffset;	                }	                if (applyLonOffset) {	                    newLocations.push(new Location(next.latitude, next.longitude + lonOffset));	                }	                else {	                    newLocations.push(next);	                }	                prev = next;	            }	            var locationGroup = [newLocations];	            if (lonOffset != 0) {	                var oldLocations = newLocations;	                newLocations = [];	                for (idx = 0, len = oldLocations.length; idx < len; idx += 1) {	                    var cur = oldLocations[idx];	                    newLocations.push(new Location(cur.latitude, cur.longitude - lonOffset));	                }	                locationGroup.push(newLocations);	            }	            return locationGroup;	        };	        SurfaceShape.prototype.resetPickColor = function() {	            this.pickColor = null;	        };	        SurfaceShape.prototype.renderToTexture = function(dc, ctx2D, xScale, yScale, dx, dy) {	            var idx,	                len,	                path = [],	                idxPath,	                lenPath,	                isPicking = dc.pickingMode,	                attributes = (this._highlighted ? (this._highlightAttributes || this._attributes) : this._attributes);	            if (isPicking && !this.pickColor) {	                this.pickColor = dc.uniquePickColor();	            }	            if (!this._isInteriorInhibited && attributes.drawInterior) {	                ctx2D.fillStyle = isPicking ? this.pickColor.toRGBAString() : attributes.interiorColor.toRGBAString();	                for (idx = 0, len = this._interiorGeometry.length; idx < len; idx += 1) {	                    idxPath = 0;	                    lenPath = this._outlineGeometry[idx].length * 2;	                    path.splice(0, path.length);	                    if (this.transformPath(this._interiorGeometry[idx], xScale, yScale, dx, dy, path)) {	                        ctx2D.beginPath();	                        ctx2D.moveTo(path[idxPath++], path[idxPath++]);	                        while (idxPath < lenPath) {	                            ctx2D.lineTo(path[idxPath++], path[idxPath++]);	                        }	                        ctx2D.closePath();	                        ctx2D.fill();	                    }	                }	            }	            if (attributes.drawOutline && attributes.outlineWidth > 0) {	                ctx2D.lineWidth = 4 * attributes.outlineWidth;	                ctx2D.strokeStyle = isPicking ? this.pickColor.toRGBAString() : attributes.outlineColor.toRGBAString();	                var pattern = this._attributes.outlineStipplePattern,	                    factor = this._attributes.outlineStippleFactor;	                for (idx = 0, len = this._outlineGeometry.length; idx < len; idx += 1) {	                    path.splice(0, path.length);	                    if (this.transformPath(this._outlineGeometry[idx], xScale, yScale, dx, dy, path)) {	                        var xFirst = path[0],	                            yFirst = path[1],	                            xPrev = xFirst,	                            yPrev = yFirst,	                            xNext = xFirst,	                            yNext = yFirst,	                            isPrevFirst = true,	                            isNextFirst = true,	                            countFirst = 0;	                        for (idxPath = 2, lenPath = path.length; idxPath < lenPath; ) {	                            xPrev = xNext;	                            yPrev = yNext;	                            isPrevFirst = isNextFirst;	                            xNext = path[idxPath++];	                            yNext = path[idxPath++];	                            isNextFirst = xNext == xFirst && yNext == yFirst;	                            if (isPrevFirst || isNextFirst) {	                                countFirst += 1;	                                if (countFirst > 2) {	                                    continue;	                                }	                            }	                            ctx2D.beginPath();	                            ctx2D.moveTo(xPrev, yPrev);	                            ctx2D.lineTo(xNext, yNext);	                            ctx2D.stroke();	                        }	                    }	                }	            }	            if (isPicking) {	                var po = new PickedObject(this.pickColor.clone(), this.pickDelegate ? this.pickDelegate : this,	                    null, this.layer, false);	                dc.resolvePick(po);	            }	        };	        SurfaceShape.prototype.transformPath = function(path, xScale, yScale, xOffset, yOffset, result) {	            var xPrev, yPrev,	                xNext, yNext,	                xFirst, yFirst,	                xLast, yLast,	                xMin, yMin,	                xMax, yMax,	                dx, dy, dr2,	                dr2Min = 4, 	                isNextFirst,	                location, idxResult, idxPath, lenPath;	            idxResult = 0;	            location = path[0];	            xFirst = location.longitude * xScale + xOffset;	            yFirst = location.latitude * yScale + yOffset;	            isNextFirst = true;	            xMin = xMax = xPrev = xNext = xFirst;	            yMin = yMax = yPrev = yNext = yFirst;	            result[idxResult++] = xNext;	            result[idxResult++] = yNext;	            for (idxPath = 1, lenPath = path.length; idxPath < lenPath; idxPath += 1) {	                location = path[idxPath];	                xLast = xNext;	                yLast = yNext;	                xNext = location.longitude * xScale + xOffset;	                yNext = location.latitude * yScale + yOffset;	                isNextFirst = (xNext == xFirst) && (yNext == yFirst);	                dx = xNext - xPrev;	                dy = yNext - yPrev;	                dr2 = dx * dx + dy * dy;	                if (isNextFirst || dr2 >= dr2Min) {	                    xMin = Math.min(xMin, xNext);	                    xMax = Math.max(xMax, xNext);	                    yMin = Math.min(yMin, yNext);	                    yMax = Math.max(yMax, yNext);	                    if (result[idxResult - 2] != xLast || result[idxResult - 1] != yLast) {	                        result[idxResult++] = xLast;	                        result[idxResult++] = yLast;	                    }	                    result[idxResult++] = xNext;	                    result[idxResult++] = yNext;	                    xPrev = xNext;	                    yPrev = yNext;	                }	            }	            return (xMax - xMin) >= 2 || (yMax - yMin) >= 2;	        };	        SurfaceShape.DEFAULT_NUM_EDGE_INTERVALS = 128;	        SurfaceShape.DEFAULT_POLAR_THROTTLE = 10;	        return SurfaceShape;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(40),	        __webpack_require__(62)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Color,	              ImageSource) {	        "use strict";	        var ShapeAttributes = function (attributes) {	            this._drawInterior = attributes ? attributes._drawInterior : true;	            this._drawOutline = attributes ? attributes._drawOutline : true;	            this._enableLighting = attributes ? attributes._enableLighting : false;	            this._interiorColor = attributes ? attributes._interiorColor : Color.WHITE;	            this._outlineColor = attributes ? attributes._outlineColor : Color.RED;	            this._outlineWidth = attributes ? attributes._outlineWidth : 1.0;	            this._outlineStippleFactor = attributes ? attributes._outlineStippleFactor : 0;	            this._outlineStipplePattern = attributes ? attributes._outlineStipplePattern : 0xF0F0;	            this._imageSource = attributes ? attributes._imageSource : null;	            this._depthTest = attributes ? attributes._depthTest : true;	            this._drawVerticals = attributes ? attributes._drawVerticals : false;	            this._applyLighting = attributes ? attributes._applyLighting : false;	            this.stateKeyInvalid = true;	        };	        ShapeAttributes.prototype.computeStateKey = function () {	            return "di " + this._drawInterior +	                  " do " + this._drawOutline +	                  " el " + this._enableLighting +	                  " ic " + this._interiorColor.toHexString(true) +	                  " oc " + this._outlineColor.toHexString(true) +	                  " ow " + this._outlineWidth +	                  " osf " + this._outlineStippleFactor +	                  " osp " + this._outlineStipplePattern +	                  " is " + (this._imageSource ?	                        (this.imageSource instanceof ImageSource ? this.imageSource.key : this.imageSource) : "null") +	                  " dt " + this._depthTest +	                  " dv " + this._drawVerticals +	                  " li " + this._applyLighting;	        };	        Object.defineProperties(ShapeAttributes.prototype, {	            stateKey: {	                get: function () {	                    if (this.stateKeyInvalid) {	                        this._stateKey = this.computeStateKey();	                        this.stateKeyInvalid = false;	                    }	                    return this._stateKey;	                }	            },	            drawInterior: {	                get: function () {	                    return this._drawInterior;	                },	                set: function (value) {	                    this._drawInterior = value;	                    this.stateKeyInvalid = true;	                }	            },	            drawOutline: {	                get: function () {	                    return this._drawOutline;	                },	                set: function (value) {	                    this._drawOutline = value;	                    this.stateKeyInvalid = true;	                }	            },	            enableLighting: {	                get: function () {	                    return this._enableLighting;	                },	                set: function (value) {	                    this._enableLighting = value;	                    this.stateKeyInvalid = true;	                }	            },	            interiorColor: {	                get: function () {	                    return this._interiorColor;	                },	                set: function (value) {	                    this._interiorColor = value;	                    this.stateKeyInvalid = true;	                }	            },	            outlineColor: {	                get: function () {	                    return this._outlineColor;	                },	                set: function (value) {	                    this._outlineColor = value;	                    this.stateKeyInvalid = true;	                }	            },	            outlineWidth: {	                get: function () {	                    return this._outlineWidth;	                },	                set: function (value) {	                    this._outlineWidth = value;	                    this.stateKeyInvalid = true;	                }	            },	            outlineStipplePattern: {	                get: function () {	                    return this._outlineStipplePattern;	                },	                set: function (value) {	                    this._outlineStipplePattern = value;	                    this.stateKeyInvalid = true;	                }	            },	            outlineStippleFactor: {	                get: function () {	                    return this._outlineStippleFactor;	                },	                set: function (value) {	                    this._outlineStippleFactor = value;	                    this.stateKeyInvalid = true;	                }	            },	            imageSource: {	                get: function () {	                    return this._imageSource;	                },	                set: function (value) {	                    this._imageSource = value;	                    this.stateKeyInvalid = true;	                }	            },	            depthTest: {	                get: function () {	                    return this._depthTest;	                },	                set: function (value) {	                    this._depthTest = value;	                    this.stateKeyInvalid = true;	                }	            },	            drawVerticals: {	                get: function () {	                    return this._drawVerticals;	                },	                set: function (value) {	                    this._drawVerticals = value;	                    this.stateKeyInvalid = true;	                }	            },	            applyLighting: {	                get: function () {	                    return this._applyLighting;	                },	                set: function (value) {	                    this._applyLighting = value;	                    this.stateKeyInvalid = true;	                }	            }	        });	        return ShapeAttributes;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))	;
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(63),	        __webpack_require__(49),	        __webpack_require__(41),	        __webpack_require__(45),	        __webpack_require__(44),	        __webpack_require__(18),	        __webpack_require__(9),	        __webpack_require__(13),	        __webpack_require__(46),	        __webpack_require__(23),	        __webpack_require__(38),	        __webpack_require__(53),	        __webpack_require__(20),	        __webpack_require__(31),	        __webpack_require__(75),	        __webpack_require__(78),	        __webpack_require__(54),	        __webpack_require__(55),	        __webpack_require__(56),	        __webpack_require__(68),	        __webpack_require__(36)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              DrawContext,	              Globe,	              GpuProgram,	              Level,	              LevelSet,	              Location,	              Logger,	              Matrix,	              MemoryCache,	              NavigatorState,	              NotYetImplementedError,	              PickedObject,	              Rectangle,	              Sector,	              SurfaceShape,	              SurfaceShapeTile,	              Terrain,	              TerrainTile,	              TerrainTileList,	              TextureTile,	              Tile) {	        "use strict";	        var SurfaceShapeTileBuilder = function() {	            this.numRowsTilesInTopLevel = 4;	            this.numColumnsTilesInTopLevel = 8;	            this.maximumSubdivisionDepth = 15;	            this.tileWidth = 256;	            this.tileHeight = 256;	            this.levels = new LevelSet(	                Sector.FULL_SPHERE,	                new Location(	                    180 / this.numRowsTilesInTopLevel,	                    360 / this.numColumnsTilesInTopLevel),	                this.maximumSubdivisionDepth,	                this.tileWidth,	                this.tileHeight);	            this.surfaceShapes = [];	            this.surfaceShapeTiles = [];	            this.topLevelTiles = [];	            this.sector = new Sector(-90, 90, -180, 180);	            this.detailControl = 1.25;	            this.tileCache = new MemoryCache(500000, 400000);	        };	        SurfaceShapeTileBuilder.prototype.clear = function() {	            this.surfaceShapeTiles.splice(0, this.surfaceShapeTiles.length);	            this.surfaceShapes.splice(0, this.surfaceShapes.length);	        };	        SurfaceShapeTileBuilder.prototype.insertSurfaceShape = function(surfaceShape) {	            this.surfaceShapes.push(surfaceShape);	        };	        SurfaceShapeTileBuilder.prototype.doRender = function(dc) {	            if (dc.pickingMode) {	                for (var idx = 0, len = this.surfaceShapes.length; idx < len; idx += 1) {	                    this.surfaceShapes[idx].resetPickColor();	                }	                SurfaceShapeTileBuilder.pickSequence += 1;	                var savedTiles = this.surfaceShapeTiles;	                var savedTopLevelTiles = this.topLevelTiles;	                this.surfaceShapeTiles = [];	                this.topLevelTiles = [];	                this.buildTiles(dc);	                if (dc.deepPicking) {	                    this.doDeepPickingRender(dc);	                } else {	                    dc.surfaceTileRenderer.renderTiles(dc, this.surfaceShapeTiles, 1);	                }	                this.surfaceShapeTiles = savedTiles;	                this.topLevelTiles = savedTopLevelTiles;	            } else {	                this.buildTiles(dc);	                dc.surfaceTileRenderer.renderTiles(dc, this.surfaceShapeTiles, 1);	            }	        };	        SurfaceShapeTileBuilder.prototype.doDeepPickingRender = function (dc) {	            var idxTile, lenTiles, idxShape, lenShapes, idxPick, lenPicks, po, shape, tile;	            var deepPickShapes = [];	            for (idxPick = 0, lenPicks = dc.objectsAtPickPoint.objects.length; idxPick < lenPicks; idxPick += 1) {	                po = dc.objectsAtPickPoint.objects[idxPick];	                if (po.userObject instanceof SurfaceShape) {	                    shape = po.userObject;	                    if (deepPickShapes.indexOf(shape) < 0) {	                        deepPickShapes.push(shape);	                        dc.objectsAtPickPoint.objects.splice(idxPick, 1);	                        idxPick -= 1;	                        lenPicks -= 1;	                    }	                }	            }	            if (deepPickShapes.length <= 0) {	                return;	            }	            var resolvablePickObjects = [];	            for (idxShape = 0, lenShapes = deepPickShapes.length; idxShape < lenShapes; idxShape += 1) {	                shape = deepPickShapes[idxShape];	                for (idxTile = 0, lenTiles = this.surfaceShapeTiles.length; idxTile < lenTiles; idxTile += 1) {	                    tile = this.surfaceShapeTiles[idxTile];	                    tile.setShapes([shape]);	                    tile.updateTexture(dc);	                }	                dc.surfaceTileRenderer.renderTiles(dc, this.surfaceShapeTiles, 1);	                var pickColor = dc.readPickColor(dc.pickPoint);	                if (!!pickColor && shape.pickColor.equals(pickColor)) {	                    po = new PickedObject(shape.pickColor.clone(),	                        shape.pickDelegate ? shape.pickDelegate : shape, null, shape.layer, false);	                    resolvablePickObjects.push(po);	                }	            }	            for (idxPick = 0, lenPicks = dc.objectsAtPickPoint.objects.length; idxPick < lenPicks; idxPick += 1) {	                po = dc.objectsAtPickPoint.objects[idxPick];	                if (po.userObject instanceof SurfaceShape) {	                    dc.objectsAtPickPoint.objects.splice(idxPick, 1);	                    idxPick -= 1;	                    lenPicks -= 1;	                }	            }	            for (idxPick = 0, lenPicks = resolvablePickObjects.length; idxPick < lenPicks; idxPick += 1) {	                po = resolvablePickObjects[idxPick];	                dc.objectsAtPickPoint.objects.push(po);	            }	        };	        SurfaceShapeTileBuilder.prototype.buildTiles = function(dc) {	            if (!this.surfaceShapes || this.surfaceShapes.length < 1) {	                return;	            }	            this.assembleTiles(dc);	            this.surfaceShapes.splice(0, this.surfaceShapes.length);	            for (var idx = 0, len = this.surfaceShapeTiles.length; idx < len; idx += 1) {	                var tile = this.surfaceShapeTiles[idx];	                tile.clearShapes();	            }	        };	        SurfaceShapeTileBuilder.prototype.assembleTiles = function(dc) {	            var tile, idxShape, lenShapes, idxTile, lenTiles, idxSector, lenSectors;	            if (this.topLevelTiles.length < 1) {	                this.createTopLevelTiles();	            }	            var intersectingTiles = {};	            for (idxShape = 0, lenShapes = this.surfaceShapes.length; idxShape < lenShapes; idxShape += 1) {	                var surfaceShape = this.surfaceShapes[idxShape];	                var sectors = surfaceShape.computeSectors(dc);	                if (!sectors) {	                    continue;	                }	                for (idxSector = 0, lenSectors = sectors.length; idxSector < lenSectors; idxSector += 1) {	                    var sector = sectors[idxSector];	                    for (idxTile = 0, lenTiles = this.topLevelTiles.length; idxTile < lenTiles; idxTile += 1) {	                        tile = this.topLevelTiles[idxTile];	                        if (tile.sector.intersects(sector)) {	                            var cacheKey = tile.tileKey;	                            intersectingTiles[cacheKey] = tile;	                            tile.addSurfaceShape(surfaceShape);	                        }	                    }	                }	            }	            for (var key in intersectingTiles) {	                if (intersectingTiles.hasOwnProperty(key)) {	                    tile = intersectingTiles[key];	                    this.addTileOrDescendants(dc, this.levels, null, tile);	                }	            }	        };	        SurfaceShapeTileBuilder.prototype.addTileOrDescendants = function (dc, levels, parent, tile) {	            if (!this.intersectsFrustum(dc, tile)) {	                tile.clearShapes();	                return;	            }	            if (parent != null) {	                this.addIntersectingShapes(dc, parent, tile);	            }	            if (!tile.hasShapes()) {	                return;	            }	            if (this.meetsRenderCriteria(dc, levels, tile)) {	                this.addTile(dc, tile);	                return;	            }	            var nextLevel = levels.level(tile.level.levelNumber + 1);	            var subTiles = dc.pickingMode ?	                tile.subdivide(nextLevel, this) :	                tile.subdivideToCache(nextLevel, this, this.tileCache);	            for (var idxTile = 0, lenTiles = subTiles.length; idxTile < lenTiles; idxTile += 1) {	                var subTile = subTiles[idxTile];	                this.addTileOrDescendants(dc, levels, tile, subTile);	            }	            tile.clearShapes();	        };	        SurfaceShapeTileBuilder.prototype.addIntersectingShapes = function(dc, parent, tile) {	            if (!parent.hasShapes())	                return;	            if (!tile.sector.intersects(parent.sector))	                return;	            if (tile.getSector().contains(parent.sector)) {	                tile.addAllSurfaceShapes(parent.getShapes());	            }	            else {	                var shapes = parent.getShapes();	                for (var idxShape = 0, lenShapes = shapes.length; idxShape < lenShapes; idxShape += 1) {	                    var shape = shapes[idxShape];	                    var sectors = shape.computeSectors(dc);	                    if (!sectors) {	                        continue;	                    }	                    for (var idxSector = 0, lenSectors = sectors.length; idxSector < lenSectors; idxSector += 1) {	                        var sector = sectors[idxSector];	                        if (tile.getSector().intersects(sector)) {	                            tile.addSurfaceShape(shape);	                            break;	                        }	                    }	                }	            }	        };	        SurfaceShapeTileBuilder.prototype.addTile = function(dc, tile) {	            if (dc.pickingMode) {	                tile.pickSequence = SurfaceShapeTileBuilder.pickSequence;	            }	            if (tile.needsUpdate(dc)) {	                tile.updateTexture(dc);	            }	            this.surfaceShapeTiles.push(tile);	        };	        SurfaceShapeTileBuilder.prototype.createTile = function(sector, level, row, column) {	            return new SurfaceShapeTile(sector, level, row, column);	        };	        SurfaceShapeTileBuilder.prototype.createTopLevelTiles = function() {	            Tile.createTilesForLevel(this.levels.firstLevel(), this, this.topLevelTiles);	        };	        SurfaceShapeTileBuilder.prototype.intersectsFrustum = function(dc, tile) {	            if (dc.globe.projectionLimits && !tile.sector.overlaps(dc.globe.projectionLimits)) {	                return false;	            }	            tile.update(dc);	            return tile.extent.intersectsFrustum(dc.pickingMode ? dc.pickFrustum : dc.navigatorState.frustumInModelCoordinates);	        };	        SurfaceShapeTileBuilder.prototype.meetsRenderCriteria = function(dc, levels, tile) {	            return tile.level.levelNumber == levels.lastLevel().levelNumber || !tile.mustSubdivide(dc, this.detailControl);	        };	        SurfaceShapeTileBuilder.pickSequence = 0;	        return SurfaceShapeTileBuilder;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(11),	        __webpack_require__(7),	        __webpack_require__(45),	        __webpack_require__(9),	        __webpack_require__(31),	        __webpack_require__(21),	        __webpack_require__(68)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (Angle,	              ArgumentError,	              Level,	              Logger,	              Sector,	              Texture,	              TextureTile) {	        "use strict";	        var SurfaceShapeTile = function(sector, level, row, column) {	            TextureTile.call(this, sector, level, row, column); 	            this.surfaceShapes = [];	            this.sector = sector;	            this.cacheKey = null;	            this.pickSequence = 0;	            this.surfaceShapeStateKeys = [];	            this.prevSurfaceShapes = [];	            this.createCtx2D();	        };	        SurfaceShapeTile.prototype = Object.create(TextureTile.prototype);	        SurfaceShapeTile.prototype.clearShapes = function() {	            var swap = this.prevSurfaceShapes;	            this.prevSurfaceShapes = this.surfaceShapes;	            this.surfaceShapes = swap;	            this.surfaceShapes.splice(0, this.surfaceShapes.length);	        };	        SurfaceShapeTile.prototype.hasShapes = function() {	            return this.surfaceShapes.length > 0;	        };	        SurfaceShapeTile.prototype.getShapes = function() {	            return this.surfaceShapes;	        };	        SurfaceShapeTile.prototype.setShapes = function(surfaceShapes) {	            this.surfaceShapes = surfaceShapes;	        };	        SurfaceShapeTile.prototype.getSector = function() {	            return this.sector;	        };	        SurfaceShapeTile.prototype.addSurfaceShape = function(surfaceShape) {	            this.surfaceShapes.push(surfaceShape);	            this.surfaceShapeStateKeys.push(surfaceShape.stateKey);	        };	        SurfaceShapeTile.prototype.addAllSurfaceShapes = function(shapes) {	            for (var idx = 0, len = shapes.length; idx < len; idx += 1) {	                var shape = shapes[idx];	                this.addAllSurfaceShapes(shape);	            }	        };	        SurfaceShapeTile.prototype.needsUpdate = function(dc) {	            var idx, len, surfaceShape, surfaceShapeStateKey;	            if (this.prevSurfaceShapes.length != this.surfaceShapes.length) {	                return true;	            }	            for (idx = 0, len = this.prevSurfaceShapes.length; idx < len; idx += 1) {	                surfaceShape = this.prevSurfaceShapes[idx];	                if (this.surfaceShapes.indexOf(surfaceShape) < 0) {	                    return true;	                }	            }	            for (idx = 0, len = this.surfaceShapes.length; idx < len; idx += 1) {	                surfaceShape = this.surfaceShapes[idx];	                if (this.prevSurfaceShapes.indexOf(surfaceShape) < 0) {	                    return true;	                }	            }	            for (idx = 0, len = this.surfaceShapes.length; idx < len; idx += 1) {	                surfaceShape = this.surfaceShapes[idx];	                surfaceShapeStateKey = this.surfaceShapeStateKeys[idx];	                if (surfaceShapeStateKey != surfaceShape.stateKey) {	                    return true;	                }	            }	            if (!this.hasTexture(dc)) {	                return true;	            }	            return false;	        };	        SurfaceShapeTile.prototype.hasTexture = function(dc) {	            if (dc.pickingMode) {	                return false;	            }	            var gpuResourceCache = dc.gpuResourceCache;	            if (!this.gpuCacheKey) {	                this.gpuCacheKey = this.getCacheKey();	            }	            var texture = gpuResourceCache.resourceForKey(this.gpuCacheKey);	            return !!texture;	        };	        SurfaceShapeTile.prototype.updateTexture = function(dc) {	            var gl = dc.currentGlContext,	                canvas = SurfaceShapeTile.canvas;	            canvas.width = this.tileWidth;	            canvas.height = this.tileHeight;	            var ctx2D = SurfaceShapeTile.ctx2D;	            var xScale = this.tileWidth / this.sector.deltaLongitude(),	                yScale = -this.tileHeight / this.sector.deltaLatitude(),	                xOffset = -this.sector.minLongitude * xScale,	                yOffset = -this.sector.maxLatitude * yScale;	            for (var idx = 0, len = this.surfaceShapes.length; idx < len; idx += 1) {	                var shape = this.surfaceShapes[idx];	                this.surfaceShapeStateKeys[idx] = shape.stateKey;	                shape.renderToTexture(dc, ctx2D, xScale, yScale, xOffset, yOffset);	            }	            var texture = new Texture(gl, canvas);	            var gpuResourceCache = dc.gpuResourceCache;	            this.gpuCacheKey = this.getCacheKey();	            gpuResourceCache.putResource(this.gpuCacheKey, texture, texture.size);	            return texture;	        };	        SurfaceShapeTile.prototype.getCacheKey = function() {	            if (!this.cacheKey) {	                this.cacheKey = "SurfaceShapeTile:" +	                this.tileKey + "," +	                this.pickSequence.toString();	            }	            return this.cacheKey;	        };	        SurfaceShapeTile.prototype.createCtx2D = function() {	            if (!SurfaceShapeTile.ctx2D) {	                SurfaceShapeTile.canvas = document.createElement("canvas");	                SurfaceShapeTile.ctx2D = SurfaceShapeTile.canvas.getContext("2d");	            }	        };	        SurfaceShapeTile.canvas = null;	        SurfaceShapeTile.ctx2D = null;	        return SurfaceShapeTile;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(9),	        __webpack_require__(13),	        __webpack_require__(78),	        __webpack_require__(80)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Logger,	              Matrix,	              SurfaceShapeTile,	              SurfaceTileRendererProgram) {	        "use strict";	        var SurfaceTileRenderer = function () {	            this.texMaskMatrix = Matrix.fromIdentity();	            this.texSamplerMatrix = Matrix.fromIdentity();	            this.isSurfaceShapeTileRendering = false;	        };	        SurfaceTileRenderer.prototype.renderTiles = function (dc, surfaceTiles, opacity, tilesHaveOpacity) {	            if (surfaceTiles.length < 1)	                return;	            var terrain = dc.terrain,	                gl = dc.currentGlContext,	                tileCount = 0,	                program,	                terrainTile,	                terrainTileSector,	                surfaceTile,	                currentTileOpacity = 1;	            if (!terrain)	                return;	            this.isSurfaceShapeTileRendering = surfaceTiles[0] instanceof SurfaceShapeTile;	            opacity *= dc.surfaceOpacity;	            program = this.beginRendering(dc, opacity);	            terrain.beginRendering(dc);	            try {	                for (var i = 0, ttLen = terrain.surfaceGeometry.length; i < ttLen; i++) {	                    terrainTile = terrain.surfaceGeometry[i];	                    terrainTileSector = terrainTile.sector;	                    terrain.beginRenderingTile(dc, terrainTile);	                    try {	                        for (var j = 0, stLen = surfaceTiles.length; j < stLen; j++) {	                            surfaceTile = surfaceTiles[j];	                            if (surfaceTile.sector.overlaps(terrainTileSector)) {	                                if (surfaceTile.bind(dc)) {	                                    if (dc.pickingMode) {	                                        if (surfaceTile.pickColor) {	                                            program.loadColor(gl, surfaceTile.pickColor);	                                        } else {	                                        }	                                    } else {	                                        if (tilesHaveOpacity && surfaceTile.opacity != currentTileOpacity) {	                                            program.loadOpacity(gl, opacity * surfaceTile.opacity);	                                            currentTileOpacity = surfaceTile.opacity;	                                        }	                                    }	                                    this.applyTileState(dc, terrainTile, surfaceTile);	                                    terrain.renderTile(dc, terrainTile);	                                    ++tileCount;	                                }	                            }	                        }	                    }	                    catch (e) {	                        console.log(e);	                    }	                    finally {	                        terrain.endRenderingTile(dc, terrainTile);	                    }	                }	            }	            catch (e) {	                console.log(e);	            }	            finally {	                terrain.endRendering(dc);	                this.endRendering(dc);	                dc.frameStatistics.incrementRenderedTileCount(tileCount);	            }	        };	        SurfaceTileRenderer.prototype.beginRendering = function (dc, opacity) {	            var gl = dc.currentGlContext,	                program = dc.findAndBindProgram(SurfaceTileRendererProgram);	            program.loadTexSampler(gl, gl.TEXTURE0);	            if (dc.pickingMode && !this.isSurfaceShapeTileRendering) {	                program.loadModulateColor(gl, true);	            } else {	                program.loadModulateColor(gl, false);	                program.loadOpacity(gl, opacity);	            }	            return program;	        };	        SurfaceTileRenderer.prototype.endRendering = function (dc) {	            var gl = dc.currentGlContext;	            gl.bindTexture(gl.TEXTURE_2D, null);	        };	        SurfaceTileRenderer.prototype.applyTileState = function (dc, terrainTile, surfaceTile) {	            var gl = dc.currentGlContext,	                program = dc.currentProgram,	                terrainSector = terrainTile.sector,	                terrainDeltaLat = terrainSector.deltaLatitude(),	                terrainDeltaLon = terrainSector.deltaLongitude(),	                surfaceSector = surfaceTile.sector,	                rawSurfaceDeltaLat = surfaceSector.deltaLatitude(),	                rawSurfaceDeltaLon = surfaceSector.deltaLongitude(),	                surfaceDeltaLat = rawSurfaceDeltaLat > 0 ? rawSurfaceDeltaLat : 1,	                surfaceDeltaLon = rawSurfaceDeltaLon > 0 ? rawSurfaceDeltaLon : 1,	                sScale = terrainDeltaLon / surfaceDeltaLon,	                tScale = terrainDeltaLat / surfaceDeltaLat,	                sTrans = -(surfaceSector.minLongitude - terrainSector.minLongitude) / surfaceDeltaLon,	                tTrans = -(surfaceSector.minLatitude - terrainSector.minLatitude) / surfaceDeltaLat;	            this.texMaskMatrix.set(	                sScale, 0, 0, sTrans,	                0, tScale, 0, tTrans,	                0, 0, 1, 0,	                0, 0, 0, 1	            );	            this.texSamplerMatrix.setToUnitYFlip();	            surfaceTile.applyInternalTransform(dc, this.texSamplerMatrix);	            this.texSamplerMatrix.multiplyMatrix(this.texMaskMatrix);	            program.loadTexSamplerMatrix(gl, this.texSamplerMatrix);	            program.loadTexMaskMatrix(gl, this.texMaskMatrix);	        };	        return SurfaceTileRenderer;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(40),	        __webpack_require__(41),	        __webpack_require__(9)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Color,	              GpuProgram,	              Logger) {	        "use strict";	        var SurfaceTileRendererProgram = function (gl) {	            var vertexShaderSource =	                    'attribute vec4 vertexPoint;\n' +	                    'attribute vec4 vertexTexCoord;\n' +	                    'uniform mat4 mvpMatrix;\n' +	                    'uniform mat4 texSamplerMatrix;\n' +	                    'uniform mat4 texMaskMatrix;\n' +	                    'varying vec2 texSamplerCoord;\n' +	                    'varying vec2 texMaskCoord;\n' +	                    'void main() {\n' +	                    'gl_Position = mvpMatrix * vertexPoint;\n' +	                    'texSamplerCoord = (texSamplerMatrix * vertexTexCoord).st;\n' +	                    'texMaskCoord = (texMaskMatrix * vertexTexCoord).st;\n' +	                    '}',	                fragmentShaderSource =	                    'precision mediump float;\n' +	                    'uniform sampler2D texSampler;\n' +	                    'uniform float opacity;\n' +	                    'uniform vec4 color;\n' +	                    'uniform bool modulateColor;\n' +	                    'varying vec2 texSamplerCoord;\n' +	                    'varying vec2 texMaskCoord;\n' +	                    'bool isInsideTextureImage(const vec2 coord) {\n' +	                    '    return coord.x >= 0.0 && coord.x <= 1.0 && coord.y >= 0.0 && coord.y <= 1.0;\n' +	                    '}\n' +	                    'void main(void) {\n' +	                        'float mask = float(isInsideTextureImage(texMaskCoord));' +	                    'if (modulateColor) {\n' +	                    '    gl_FragColor = color * mask * floor(texture2D(texSampler, texSamplerCoord).a + 0.5);\n' +	                    '} else {\n' +	                    '    gl_FragColor = texture2D(texSampler, texSamplerCoord) * mask * opacity;\n' +	                    '}\n' +	                    '}';	            GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource);	            this.vertexPointLocation = this.attributeLocation(gl, "vertexPoint");	            this.vertexTexCoordLocation = this.attributeLocation(gl, "vertexTexCoord");	            this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");	            this.colorLocation = this.uniformLocation(gl, "color");	            this.modulateColorLocation = this.uniformLocation(gl, "modulateColor");	            this.texSamplerMatrixLocation = this.uniformLocation(gl, "texSamplerMatrix");	            this.texMaskMatrixLocation = this.uniformLocation(gl, "texMaskMatrix");	            this.texSamplerLocation = this.uniformLocation(gl, "texSampler");	            this.opacityLocation = this.uniformLocation(gl, "opacity");	            this.vertexPointLocation = -1;	        };	        SurfaceTileRendererProgram.key = "WorldWindGpuSurfaceTileRenderingProgram";	        SurfaceTileRendererProgram.prototype = Object.create(GpuProgram.prototype);	        SurfaceTileRendererProgram.prototype.loadModelviewProjection = function (gl, matrix) {	            this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);	        };	        SurfaceTileRendererProgram.prototype.loadTexSamplerMatrix = function (gl, matrix) {	            this.loadUniformMatrix(gl, matrix, this.texSamplerMatrixLocation);	        };	        SurfaceTileRendererProgram.prototype.loadTexMaskMatrix = function (gl, matrix) {	            this.loadUniformMatrix(gl, matrix, this.texMaskMatrixLocation);	        };	        SurfaceTileRendererProgram.prototype.loadTexSampler = function (gl, unit) {	            gl.uniform1i(this.texSamplerLocation, unit - WebGLRenderingContext.TEXTURE0);	        };	        SurfaceTileRendererProgram.prototype.loadOpacity = function (gl, opacity) {	            gl.uniform1f(this.opacityLocation, opacity);	        };	        SurfaceTileRendererProgram.prototype.loadColor = function (gl, color) {	            this.loadUniformColor(gl, color, this.colorLocation);	        };	        SurfaceTileRendererProgram.prototype.loadModulateColor = function (gl, enable) {	            gl.uniform1i(this.modulateColorLocation, enable ? 1 : 0);	        };	        return SurfaceTileRendererProgram;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(73),	        __webpack_require__(40),	        __webpack_require__(9),	        __webpack_require__(13),	        __webpack_require__(21),	        __webpack_require__(24)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              BasicTextureProgram,	              Color,	              Logger,	              Matrix,	              Texture,	              Vec2) {	        "use strict";	        var TextSupport = function () {	            this.canvas2D = document.createElement("canvas");	            this.ctx2D = this.canvas2D.getContext("2d");	            this.lineSpacing = 0.15; 	            this.strokeStyle = "rgba(0, 0, 0, " + 0.5 + ")";	            this.strokeWidth = 4;	        };	        TextSupport.prototype.textSize = function (text, font, outline) {	            if (text.length === 0) {	                return new Vec2(0, 0);	            }	            this.ctx2D.font = font.fontString;	            var lines = text.split("\n"),	                height = lines.length * (font.size * (1 + this.lineSpacing)),	                maxWidth = 0;	            for (var i = 0; i < lines.length; i++) {	                maxWidth = Math.max(maxWidth, this.ctx2D.measureText(lines[i]).width);	            }	            if (outline) {	                maxWidth += this.strokeWidth;	                height += this.strokeWidth;	            }	            return new Vec2(maxWidth, height);	        };	        TextSupport.prototype.createTexture = function (dc, text, font, outline) {	            var gl = dc.currentGlContext,	                ctx2D = this.ctx2D,	                canvas2D = this.canvas2D,	                textSize = this.textSize(text, font, outline),	                lines = text.split("\n"),	                strokeOffset = outline ? this.strokeWidth / 2 : 0,	                pixelScale = dc.pixelScale,	                x, y;	            canvas2D.width = Math.ceil(textSize[0]) * pixelScale;	            canvas2D.height = Math.ceil(textSize[1]) * pixelScale;	            ctx2D.scale(pixelScale, pixelScale);	            ctx2D.font = font.fontString;	            ctx2D.textBaseline = "top";	            ctx2D.textAlign = font.horizontalAlignment;	            ctx2D.fillStyle = Color.WHITE.toHexString(false);	            ctx2D.strokeStyle = this.strokeStyle;	            ctx2D.lineWidth = this.strokeWidth;	            ctx2D.lineCap = "round";	            ctx2D.lineJoin = "round";	            if (font.horizontalAlignment === "left") {	                ctx2D.translate(strokeOffset, 0);	            } else if (font.horizontalAlignment === "right") {	                ctx2D.translate(textSize[0] - strokeOffset, 0);	            } else {	                ctx2D.translate(textSize[0] / 2, 0);	            }	            for (var i = 0; i < lines.length; i++) {	                if (outline) {	                    ctx2D.strokeText(lines[i], 0, 0);	                }	                ctx2D.fillText(lines[i], 0, 0);	                ctx2D.translate(0, font.size * (1 + this.lineSpacing) + strokeOffset);	            }	            return new Texture(gl, canvas2D);	        };	        TextSupport.prototype.getMaxLineHeight = function(font)	        {	            return this.textSize("_\u00c9", font, 0)[1];	        };	        TextSupport.prototype.wrap = function(text, width, height, font)	        {	            var i;	            var lines = text.split("\n");	            var wrappedText = "";	            for (i = 0; i < lines.length; i++)	            {	                lines[i] = this.wrapLine(lines[i], width, font);	            }	            var currentHeight = 0;	            var heightExceeded = false;	            var maxLineHeight = this.getMaxLineHeight(font);	            for (i = 0; i < lines.length && !heightExceeded; i++)	            {	                var subLines = lines[i].split("\n");	                for (var j = 0; j < subLines.length && !heightExceeded; j++)	                {	                    if (height <= 0 || currentHeight + maxLineHeight <= height)	                    {	                        wrappedText += subLines[j];	                        currentHeight += maxLineHeight + this.lineSpacing;	                        if (j < subLines.length - 1) {	                            wrappedText += '\n';	                        }	                    }	                    else	                    {	                        heightExceeded = true;	                    }	                }	                if (i < lines.length - 1 && !heightExceeded) {	                    wrappedText += '\n';	                }	            }	            if (heightExceeded)	            {	                if (wrappedText.length > 0) {	                    wrappedText = wrappedText.substring(0, wrappedText.length - 1);	                }	                wrappedText += "...";	            }	            return wrappedText;	        };	        TextSupport.prototype.wrapLine = function(text, width, font)	        {	            var wrappedText = "";	            var source = text.trim();	            var lineBounds = this.textSize(source, font, 0);	            if (lineBounds[0] > width)	            {	                var line = "";	                var start = 0;	                var end = source.indexOf(' ', start + 1);	                while (start < source.length)	                {	                    if (end == -1) {	                        end = source.length;   	                    }	                    var word = source.substring(start, end);	                    var linePlusWord = line + word;	                    if (this.textSize(linePlusWord, font, 0)[0] <= width)	                    {	                        line += word;	                    }	                    else	                    {	                        if (line.length != 0)	                        {	                            wrappedText += line;	                            wrappedText += '\n';	                            line = "";	                            line += word.trim();  	                        }	                        else	                        {	                            line += word.trim();	                        }	                    }	                    start = end;	                    if (start < source.length - 1)	                    {	                        end = source.indexOf(' ', start + 1);	                    }	                }	                wrappedText += line;	            }	            else	            {	                wrappedText += source;	            }	            return wrappedText;	        };	        return TextSupport;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(84),	        __webpack_require__(69),	        __webpack_require__(9),	        __webpack_require__(13),	        __webpack_require__(83),	        __webpack_require__(31),	        __webpack_require__(86),	        __webpack_require__(16),	        __webpack_require__(43)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              GroundProgram,	              Layer,	              Logger,	              Matrix,	              Matrix3,	              Sector,	              SkyProgram,	              Vec3,	              WWUtil) {	        "use strict";	        var AtmosphereLayer = function (nightImageSource) {	            Layer.call(this, "Atmosphere");	            this.pickEnabled = false;	            this._nightImageSource = nightImageSource ||	                WorldWind.configuration.baseUrl + 'images/dnb_land_ocean_ice_2012.png';	            this._lightLocation = null;	            this._activeLightDirection = new Vec3(0, 0, 0);	            this._fullSphereSector = Sector.FULL_SPHERE;	            this._skyData = {};	            this._skyWidth = 128;	            this._skyHeight = 128;	            this._numIndices = 0;	            this._texMatrix = Matrix3.fromIdentity();	            this._activeTexture = null;	        };	        AtmosphereLayer.prototype = Object.create(Layer.prototype);	        Object.defineProperties(AtmosphereLayer.prototype, {	            lightLocation: {	                get: function () {	                    return this._lightLocation;	                },	                set: function (value) {	                    this._lightLocation = value;	                }	            },	            nightImageSource: {	                get: function () {	                    return this._nightImageSource;	                },	                set: function (value) {	                    this._nightImageSource = value;	                }	            }	        });	        AtmosphereLayer.prototype.doRender = function (dc) {	            if (dc.globe.is2D()) {	                return;	            }	            this.determineLightDirection(dc);	            this.drawSky(dc);	            this.drawGround(dc);	        };	        AtmosphereLayer.prototype.applySkyVertices = function (dc) {	            var gl = dc.currentGlContext,	                program = dc.currentProgram,	                skyData = this._skyData,	                skyPoints, vboId;	            if (!skyData.verticesVboCacheKey) {	                skyData.verticesVboCacheKey = dc.gpuResourceCache.generateCacheKey();	            }	            vboId = dc.gpuResourceCache.resourceForKey(skyData.verticesVboCacheKey);	            if (!vboId) {	                skyPoints = this.assembleVertexPoints(dc, this._skyHeight, this._skyWidth, program.getAltitude());	                vboId = gl.createBuffer();	                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);	                gl.bufferData(gl.ARRAY_BUFFER, skyPoints, gl.STATIC_DRAW);	                gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);	                dc.gpuResourceCache.putResource(skyData.verticesVboCacheKey, vboId,	                    skyPoints.length * 4);	                dc.frameStatistics.incrementVboLoadCount(1);	            }	            else {	                gl.bindBuffer(gl.ARRAY_BUFFER, vboId);	                gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);	            }	        };	        AtmosphereLayer.prototype.applySkyIndices = function (dc) {	            var gl = dc.currentGlContext,	                skyData = this._skyData,	                skyIndices, vboId;	            if (!skyData.indicesVboCacheKey) {	                skyData.indicesVboCacheKey = dc.gpuResourceCache.generateCacheKey();	            }	            vboId = dc.gpuResourceCache.resourceForKey(skyData.indicesVboCacheKey);	            if (!vboId) {	                skyIndices = this.assembleTriStripIndices(this._skyWidth, this._skyHeight);	                vboId = gl.createBuffer();	                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboId);	                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, skyIndices, gl.STATIC_DRAW);	                dc.frameStatistics.incrementVboLoadCount(1);	                dc.gpuResourceCache.putResource(skyData.indicesVboCacheKey, vboId, skyIndices.length * 2);	            }	            else {	                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboId);	            }	        };	        AtmosphereLayer.prototype.drawSky = function (dc) {	            var gl = dc.currentGlContext,	                program = dc.findAndBindProgram(SkyProgram);	            program.loadGlobeRadius(gl, dc.globe.equatorialRadius);	            program.loadEyePoint(gl, dc.navigatorState.eyePoint);	            program.loadVertexOrigin(gl, Vec3.ZERO);	            program.loadModelviewProjection(gl, dc.navigatorState.modelviewProjection);	            program.loadLightDirection(gl, this._activeLightDirection);	            program.setScale(gl);	            this.applySkyVertices(dc);	            this.applySkyIndices(dc);	            gl.depthMask(false);	            gl.frontFace(gl.CW);	            gl.enableVertexAttribArray(0);	            gl.drawElements(gl.TRIANGLE_STRIP, this._numIndices, gl.UNSIGNED_SHORT, 0);	            gl.depthMask(true);	            gl.frontFace(gl.CCW);	            gl.disableVertexAttribArray(0);	        };	        AtmosphereLayer.prototype.drawGround = function (dc) {	            var gl = dc.currentGlContext,	                program = dc.findAndBindProgram(GroundProgram),	                terrain = dc.terrain,	                textureBound;	            program.loadGlobeRadius(gl, dc.globe.equatorialRadius);	            program.loadEyePoint(gl, dc.navigatorState.eyePoint);	            program.loadLightDirection(gl, this._activeLightDirection);	            program.setScale(gl);	            if (this.nightImageSource && this.lightLocation) {	                this._activeTexture = dc.gpuResourceCache.resourceForKey(this.nightImageSource);	                if (!this._activeTexture) {	                    this._activeTexture = dc.gpuResourceCache.retrieveTexture(gl, this.nightImageSource);	                }	                textureBound = this._activeTexture && this._activeTexture.bind(dc);	            }	            terrain.beginRendering(dc);	            for (var idx = 0, len = terrain.surfaceGeometry.length; idx < len; idx++) {	                var currentTile = terrain.surfaceGeometry[idx];	                var terrainOrigin = currentTile.referencePoint;	                program.loadVertexOrigin(gl, terrainOrigin);	                if (textureBound) {	                    this._texMatrix.setToUnitYFlip();	                    this._texMatrix.multiplyByTileTransform(currentTile.sector, this._fullSphereSector);	                    program.loadTexMatrix(gl, this._texMatrix);	                }	                terrain.beginRenderingTile(dc, currentTile);	                program.loadFragMode(gl, program.FRAGMODE_GROUND_SECONDARY);	                gl.blendFunc(gl.DST_COLOR, gl.ZERO);	                terrain.renderTile(dc, currentTile);	                var fragMode = textureBound ?	                    program.FRAGMODE_GROUND_PRIMARY_TEX_BLEND : program.FRAGMODE_GROUND_PRIMARY;	                program.loadFragMode(gl, fragMode);	                gl.blendFunc(gl.ONE, gl.ONE);	                terrain.renderTile(dc, currentTile);	                terrain.endRenderingTile(dc, currentTile);	            }	            terrain.endRendering(dc);	            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);	            this._activeTexture = null;	        };	        AtmosphereLayer.prototype.assembleVertexPoints = function (dc, numLat, numLon, altitude) {	            var count = numLat * numLon;	            var altitudes = new Array(count);	            WWUtil.fillArray(altitudes, altitude);	            var result = new Float32Array(count * 3);	            return dc.globe.computePointsForGrid(this._fullSphereSector, numLat, numLon, altitudes, Vec3.ZERO, result);	        };	        AtmosphereLayer.prototype.assembleTriStripIndices = function (numLat, numLon) {	            var result = [];	            var vertex = 0;	            for (var latIndex = 0; latIndex < numLat - 1; latIndex++) {	                for (var lonIndex = 0; lonIndex < numLon; lonIndex++) {	                    vertex = lonIndex + latIndex * numLon;	                    result.push(vertex + numLon);	                    result.push(vertex);	                }	                if (latIndex < numLat - 2) {	                    result.push(vertex);	                    result.push((latIndex + 2) * numLon);	                }	            }	            this._numIndices = result.length;	            return new Uint16Array(result);	        };	        AtmosphereLayer.prototype.determineLightDirection = function (dc) {	            if (this.lightLocation != null) {	                dc.globe.computePointFromLocation(this.lightLocation.latitude, this.lightLocation.longitude,	                    this._activeLightDirection);	            }	            else {	                this._activeLightDirection.copy(dc.navigatorState.eyePoint);	            }	            this._activeLightDirection.normalize();	        };	        return AtmosphereLayer;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(9)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Logger) {	        "use strict";	        var Matrix3 = function (m11, m12, m13,	                                m21, m22, m23,	                                m31, m32, m33) {	            this[0] = m11;	            this[1] = m12;	            this[2] = m13;	            this[3] = m21;	            this[4] = m22;	            this[5] = m23;	            this[6] = m31;	            this[7] = m32;	            this[8] = m33;	        };	        Matrix3.prototype = new Float64Array(9);	        Matrix3.fromIdentity = function () {	            return new Matrix3(	                1, 0, 0,	                0, 1, 0,	                0, 0, 1	            );	        };	        Matrix3.prototype.setToUnitYFlip = function () {	            this[0] = 1;	            this[1] = 0;	            this[2] = 0;	            this[3] = 0;	            this[4] = -1;	            this[5] = 1;	            this[6] = 0;	            this[7] = 0;	            this[8] = 1;	            return this;	        };	        Matrix3.prototype.multiplyMatrix = function (matrix) {	            var ma = this,	                mb = matrix,	                ma0, ma1, ma2;	            ma0 = ma[0];	            ma1 = ma[1];	            ma2 = ma[2];	            ma[0] = (ma0 * mb[0]) + (ma1 * mb[3]) + (ma2 * mb[6]);	            ma[1] = (ma0 * mb[1]) + (ma1 * mb[4]) + (ma2 * mb[7]);	            ma[2] = (ma0 * mb[2]) + (ma1 * mb[5]) + (ma2 * mb[8]);	            ma0 = ma[3];	            ma1 = ma[4];	            ma2 = ma[5];	            ma[3] = (ma0 * mb[0]) + (ma1 * mb[3]) + (ma2 * mb[6]);	            ma[4] = (ma0 * mb[1]) + (ma1 * mb[4]) + (ma2 * mb[7]);	            ma[5] = (ma0 * mb[2]) + (ma1 * mb[5]) + (ma2 * mb[8]);	            ma0 = ma[6];	            ma1 = ma[7];	            ma2 = ma[8];	            ma[6] = (ma0 * mb[0]) + (ma1 * mb[3]) + (ma2 * mb[6]);	            ma[7] = (ma0 * mb[1]) + (ma1 * mb[4]) + (ma2 * mb[7]);	            ma[8] = (ma0 * mb[2]) + (ma1 * mb[5]) + (ma2 * mb[8]);	            return this;	        };	        Matrix3.prototype.multiplyByTileTransform = function (src, dst) {	            var srcDeltaLat = src.deltaLatitude();	            var srcDeltaLon = src.deltaLongitude();	            var dstDeltaLat = dst.deltaLatitude();	            var dstDeltaLon = dst.deltaLongitude();	            var xs = srcDeltaLon / dstDeltaLon;	            var ys = srcDeltaLat / dstDeltaLat;	            var xt = (src.minLongitude - dst.minLongitude) / dstDeltaLon;	            var yt = (src.minLatitude - dst.minLatitude) / dstDeltaLat;	            var m = this;	             m[2] += (m[0] * xt) + (m[1] * yt);	             m[5] += (m[3] * xt) + (m[4] * yt);	             m[8] += (m[6] * xt) + (m[6] * yt);	             m[0] *= xs;	             m[1] *= ys;	             m[3] *= xs;	             m[4] *= ys;	             m[6] *= xs;	             m[7] *= ys;	            return this;	        };	        Matrix3.prototype.columnMajorComponents = function (result) {	            result[0] = this[0];	            result[1] = this[3];	            result[2] = this[6];	            result[3] = this[1];	            result[4] = this[4];	            result[5] = this[7];	            result[6] = this[2];	            result[7] = this[5];	            result[8] = this[8];	            return result;	        };	        return Matrix3;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(85)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (AtmosphereProgram) {	        "use strict";	        var GroundProgram = function (gl) {	            var vertexShaderSource =	                    'precision mediump int;\n' +	                    'const int FRAGMODE_GROUND_PRIMARY_TEX_BLEND = 4;\n' +	                    'const int SAMPLE_COUNT = 2;\n' +	                    'const float SAMPLES = 2.0;\n' +	                    'const float PI = 3.141592653589;\n' +	                    'const float Kr = 0.0025;\n' +	                    'const float Kr4PI = Kr * 4.0 * PI;\n' +	                    'const float Km = 0.0015;\n' +	                    'const float Km4PI = Km * 4.0 * PI;\n' +	                    'const float ESun = 15.0;\n' +	                    'const float KmESun = Km * ESun;\n' +	                    'const float KrESun = Kr * ESun;\n' +	                    'const vec3 invWavelength = vec3(5.60204474633241, 9.473284437923038, 19.643802610477206);\n' +	                    'const float rayleighScaleDepth = 0.25;\n' +	                    'uniform int fragMode;\n' +	                    'uniform mat4 mvpMatrix;\n' +	                    'uniform mat3 texCoordMatrix;\n' +	                    'uniform vec3 vertexOrigin;\n' +	                    'uniform vec3 eyePoint;\n' +	                    'uniform float eyeMagnitude;\n' + 	                    'uniform float eyeMagnitude2;\n' + 	                    'uniform vec3 lightDirection;\n' + 	                    'uniform float atmosphereRadius;\n' + 	                    'uniform float atmosphereRadius2;\n' + 	                    'uniform float globeRadius;\n' + 	                    'uniform float scale;\n' + 	                    'uniform float scaleDepth;\n' + 	                    'uniform float scaleOverScaleDepth;\n' + 	                    'attribute vec4 vertexPoint;\n' +	                    'attribute vec2 vertexTexCoord;\n' +	                    'varying vec3 primaryColor;\n' +	                    'varying vec3 secondaryColor;\n' +	                    'varying vec2 texCoord;\n' +	                    'float scaleFunc(float cos) {\n' +	                    '    float x = 1.0 - cos;\n' +	                    '    return scaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n' +	                    '}\n' +	                    'void sampleGround() {\n' +	                    '    vec3 point = vertexPoint.xyz + vertexOrigin;\n' +	                    '    vec3 ray = point - eyePoint;\n' +	                    '    float far = length(ray);\n' +	                    '    ray /= far;\n' +	                    '    vec3 start;\n' +	                    '    if (eyeMagnitude < atmosphereRadius) {\n' +	                    '        start = eyePoint;\n' +	                    '    } else {\n' +	                    '        float B = 2.0 * dot(eyePoint, ray);\n' +	                    '        float C = eyeMagnitude2 - atmosphereRadius2;\n' +	                    '        float det = max(0.0, B*B - 4.0 * C);\n' +	                    '        float near = 0.5 * (-B - sqrt(det));\n' +	                    '        start = eyePoint + ray * near;\n' +	                    '        far -= near;\n' +	                    '}\n' +	                    '    float depth = exp((globeRadius - atmosphereRadius) / scaleDepth);\n' +	                    '    float eyeAngle = dot(-ray, point) / length(point);\n' +	                    '    float lightAngle = dot(lightDirection, point) / length(point);\n' +	                    '    float eyeScale = scaleFunc(eyeAngle);\n' +	                    '    float lightScale = scaleFunc(lightAngle);\n' +	                    '    float eyeOffset = depth*eyeScale;\n' +	                    '    float temp = (lightScale + eyeScale);\n' +	                    '    float sampleLength = far / SAMPLES;\n' +	                    '    float scaledLength = sampleLength * scale;\n' +	                    '    vec3 sampleRay = ray * sampleLength;\n' +	                    '    vec3 samplePoint = start + sampleRay * 0.5;\n' +	                    '    vec3 frontColor = vec3(0.0, 0.0, 0.0);\n' +	                    '    vec3 attenuate = vec3(0.0, 0.0, 0.0);\n' +	                    '    for(int i=0; i<SAMPLE_COUNT; i++)\n' +	                    '    {\n' +	                    '        float height = length(samplePoint);\n' +	                    '        float depth = exp(scaleOverScaleDepth * (globeRadius - height));\n' +	                    '        float scatter = depth*temp - eyeOffset;\n' +	                    '        attenuate = exp(-scatter * (invWavelength * Kr4PI + Km4PI));\n' +	                    '        frontColor += attenuate * (depth * scaledLength);\n' +	                    '        samplePoint += sampleRay;\n' +	                    '    }\n' +	                    '    primaryColor = frontColor * (invWavelength * KrESun + KmESun);\n' +	                    '    secondaryColor = attenuate;\n' + 	                    '}\n' +	                    'void main()\n ' +	                    '{\n' +	                    '    sampleGround();\n' +	                    '    gl_Position = mvpMatrix * vertexPoint;\n' +	                    '    if (fragMode == FRAGMODE_GROUND_PRIMARY_TEX_BLEND) {\n' +	                    '        texCoord = (texCoordMatrix * vec3(vertexTexCoord, 1.0)).st;\n' +	                    '    }\n' +	                    '}',	                fragmentShaderSource =	                    'precision mediump float;\n' +	                    'precision mediump int;\n' +	                    'const int FRAGMODE_GROUND_PRIMARY = 2;\n' +	                    'const int FRAGMODE_GROUND_SECONDARY = 3;\n' +	                    'const int FRAGMODE_GROUND_PRIMARY_TEX_BLEND = 4;\n' +	                    'uniform int fragMode;\n' +	                    'uniform sampler2D texSampler;\n' +	                    'varying vec3 primaryColor;\n' +	                    'varying vec3 secondaryColor;\n' +	                    'varying vec2 texCoord;\n' +	                    'void main (void)\n' +	                    '{\n' +	                    '    if (fragMode == FRAGMODE_GROUND_PRIMARY) {\n' +	                    '        gl_FragColor = vec4(primaryColor, 1.0);\n' +	                    '    } else if (fragMode == FRAGMODE_GROUND_SECONDARY) {\n' +	                    '        gl_FragColor = vec4(secondaryColor, 1.0);\n' +	                    '    } else if (fragMode == FRAGMODE_GROUND_PRIMARY_TEX_BLEND) {\n' +	                    '        vec4 texColor = texture2D(texSampler, texCoord);\n' +	                    '        gl_FragColor = vec4(primaryColor + texColor.rgb * (1.0 - secondaryColor), 1.0);\n' +	                    '    }\n' +	                    '}';	            AtmosphereProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, ["vertexPoint", "vertexTexCoord"]);	        };	        GroundProgram.key = "WorldWindGroundProgram";	        GroundProgram.prototype = Object.create(AtmosphereProgram.prototype);	        return GroundProgram;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(41),	        __webpack_require__(9)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              GpuProgram,	              Logger) {	        "use strict";	        var AtmosphereProgram = function (gl, vertexShaderSource, fragmentShaderSource, attribute) {	            GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, attribute);	            this.FRAGMODE_SKY = 1;	            this.FRAGMODE_GROUND_PRIMARY = 2;	            this.FRAGMODE_GROUND_SECONDARY = 3;	            this.FRAGMODE_GROUND_PRIMARY_TEX_BLEND = 4;	            this.altitude = 160000;	            this.rayleighScaleDepth = 0.25;	            this.fragModeLocation = this.uniformLocation(gl, "fragMode");	            this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");	            this.texCoordMatrixLocation = this.uniformLocation(gl, "texCoordMatrix");	            this.vertexOriginLocation = this.uniformLocation(gl, "vertexOrigin");	            this.eyePointLocation = this.uniformLocation(gl, "eyePoint");	            this.eyeMagnitudeLocation = this.uniformLocation(gl, "eyeMagnitude");	            this.eyeMagnitude2Location = this.uniformLocation(gl, "eyeMagnitude2");	            this.lightDirectionLocation = this.uniformLocation(gl, "lightDirection");	            this.atmosphereRadiusLocation = this.uniformLocation(gl, "atmosphereRadius");	            this.atmosphereRadius2Location = this.uniformLocation(gl, "atmosphereRadius2");	            this.globeRadiusLocation = this.uniformLocation(gl, "globeRadius");	            this.scaleLocation = this.uniformLocation(gl, "scale");	            this.scaleDepthLocation = this.uniformLocation(gl, "scaleDepth");	            this.scaleOverScaleDepthLocation = this.uniformLocation(gl, "scaleOverScaleDepth");	            this.scratchArray9 = new Float32Array(9);	        };	        AtmosphereProgram.key = "WorldWindGpuAtmosphereProgram";	        AtmosphereProgram.prototype = Object.create(GpuProgram.prototype);	        AtmosphereProgram.prototype.getAltitude = function () {	            return this.altitude;	        };	        AtmosphereProgram.prototype.loadFragMode = function (gl, fragMode) {	            gl.uniform1i(this.fragModeLocation, fragMode);	        };	        AtmosphereProgram.prototype.loadModelviewProjection = function (gl, matrix) {	            this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);	        };	        AtmosphereProgram.prototype.loadVertexOrigin = function (gl, vector) {	            gl.uniform3f(this.vertexOriginLocation, vector[0], vector[1], vector[2]);	        };	        AtmosphereProgram.prototype.loadLightDirection = function (gl, vector) {	            gl.uniform3f(this.lightDirectionLocation, vector[0], vector[1], vector[2]);	        };	        AtmosphereProgram.prototype.loadEyePoint = function (gl, vector) {	            gl.uniform3f(this.eyePointLocation, vector[0], vector[1], vector[2]);	            gl.uniform1f(this.eyeMagnitudeLocation, vector.magnitude());	            gl.uniform1f(this.eyeMagnitude2Location, vector.magnitudeSquared());	        };	        AtmosphereProgram.prototype.loadGlobeRadius = function (gl, globeRadius) {	            var gr = globeRadius;	            var ar = gr + this.altitude;	            gl.uniform1f(this.globeRadiusLocation, gr);	            gl.uniform1f(this.atmosphereRadiusLocation, ar);	            gl.uniform1f(this.atmosphereRadius2Location, ar * ar);	        };	        AtmosphereProgram.prototype.setScale = function (gl) {	            gl.uniform1f(this.scaleLocation, 1 / this.getAltitude());	            gl.uniform1f(this.scaleDepthLocation, this.rayleighScaleDepth);	            gl.uniform1f(this.scaleOverScaleDepthLocation, (1 / this.getAltitude()) / this.rayleighScaleDepth);	        };	        AtmosphereProgram.prototype.loadTexMatrix = function(gl, matrix){	            matrix.columnMajorComponents(this.scratchArray9);	            gl.uniformMatrix3fv(this.texCoordMatrixLocation, false, this.scratchArray9);	        };	        return AtmosphereProgram;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(85)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (AtmosphereProgram) {	        "use strict";	        var  SkyProgram = function (gl) {	            var vertexShaderSource =	                    'precision mediump int;\n' +	                    'const int SAMPLE_COUNT = 2;\n' +	                    'const float SAMPLES = 2.0;\n' +	                    'const float PI = 3.141592653589;\n' +	                    'const float Kr = 0.0025;\n' +	                    'const float Kr4PI = Kr * 4.0 * PI;\n' +	                    'const float Km = 0.0015;\n' +	                    'const float Km4PI = Km * 4.0 * PI;\n' +	                    'const float ESun = 15.0;\n' +	                    'const float KmESun = Km * ESun;\n' +	                    'const float KrESun = Kr * ESun;\n' +	                    'const vec3 invWavelength = vec3(5.60204474633241, 9.473284437923038, 19.643802610477206);\n' +	                    'const float rayleighScaleDepth = 0.25;\n' +	                    'uniform mat4 mvpMatrix;\n' +	                    'uniform vec3 vertexOrigin;\n' +	                    'uniform vec3 eyePoint;\n' +	                    'uniform float eyeMagnitude;\n' +        	                    'uniform float eyeMagnitude2;\n' +       	                    'uniform mediump vec3 lightDirection;\n' +       	                    'uniform float atmosphereRadius;\n' +    	                    'uniform float atmosphereRadius2;\n' +   	                    'uniform float globeRadius;\n' +         	                    'uniform float scale;\n' +               	                    'uniform float scaleDepth;\n' +          	                    'uniform float scaleOverScaleDepth;\n' + 	                    'attribute vec4 vertexPoint;\n' +	                    'varying vec3 primaryColor;\n' +	                    'varying vec3 secondaryColor;\n' +	                    'varying vec3 direction;\n' +	                    'float scaleFunc(float cos)\n' +	                    '{\n' +	                    '    float x = 1.0 - cos;\n' +	                    '    return scaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n' +	                    '}\n' +	                    'void sampleSky() {\n' +	                    '    vec3 point = vertexPoint.xyz + vertexOrigin;\n' +	                    '    vec3 ray = point - eyePoint;\n' +	                    '    float far = length(ray);\n' +	                    '    ray /= far;\n' +	                    '    vec3 start;\n' +	                    '    float startOffset;\n' +	                    '    if (eyeMagnitude < atmosphereRadius) {\n' +	                    '        start = eyePoint;\n' +	                    '        float height = length(start);\n' +	                    '        float depth = exp(scaleOverScaleDepth * (globeRadius - eyeMagnitude));\n' +	                    '        float startAngle = dot(ray, start) / height;\n' +	                    '        startOffset = depth*scaleFunc(startAngle);\n' +	                    '    } else {\n' +	                    '        float B = 2.0 * dot(eyePoint, ray);\n' +	                    '        float C = eyeMagnitude2 - atmosphereRadius2;\n' +	                    '        float det = max(0.0, B*B - 4.0 * C);\n' +	                    '        float near = 0.5 * (-B - sqrt(det));\n' +	                    '        start = eyePoint + ray * near;\n' +	                    '        far -= near;\n' +	                    '        float startAngle = dot(ray, start) / atmosphereRadius;\n' +	                    '        float startDepth = exp(-1.0 / scaleDepth);\n' +	                    '        startOffset = startDepth*scaleFunc(startAngle);\n' +	                    '    }\n' +	                    '    float sampleLength = far / SAMPLES;\n' +	                    '    float scaledLength = sampleLength * scale;\n' +	                    '    vec3 sampleRay = ray * sampleLength;\n' +	                    '    vec3 samplePoint = start + sampleRay * 0.5;\n' +	                    '    vec3 frontColor = vec3(0.0, 0.0, 0.0);\n' +	                    '    for(int i=0; i<SAMPLE_COUNT; i++)\n' +	                    '    {\n' +	                    '       float height = length(samplePoint);\n' +	                    '       float depth = exp(scaleOverScaleDepth * (globeRadius - height));\n' +	                    '       float lightAngle = dot(lightDirection, samplePoint) / height;\n' +	                    '       float cameraAngle = dot(ray, samplePoint) / height;\n' +	                    '       float scatter = (startOffset + depth*(scaleFunc(lightAngle) - scaleFunc(cameraAngle)));\n'+	                    '       vec3 attenuate = exp(-scatter * (invWavelength * Kr4PI + Km4PI));\n' +	                    '       frontColor += attenuate * (depth * scaledLength);\n' +	                    '       samplePoint += sampleRay;\n' +	                    '    }\n' +	                    '    primaryColor = frontColor * (invWavelength * KrESun);\n' +	                    '    secondaryColor = frontColor * KmESun;\n' +	                    '    direction = eyePoint - point;\n' +	                    '}\n' +	                    'void main()\n' +	                    '{\n' +	                    '    sampleSky();\n' +	                    '    gl_Position = mvpMatrix * vertexPoint;\n' +	                    '    gl_Position.z = gl_Position.w - 0.00001;\n' +	                    '}',	                fragmentShaderSource =	                    '#ifdef GL_FRAGMENT_PRECISION_HIGH\n'+	                    'precision highp float;\n'+	                    '#else\n'+	                    'precision mediump float;\n'+	                    '#endif\n'+	                    'const float g = -0.95;\n' +	                    'const float g2 = g * g;\n' +	                    'uniform mediump vec3 lightDirection;\n' +	                    'varying vec3 primaryColor;\n' +	                    'varying vec3 secondaryColor;\n' +	                    'varying vec3 direction;\n' +	                    'void main (void)\n' +	                    '{\n' +	                    '    float cos = dot(lightDirection, direction) / length(direction);\n' +	                    '    float rayleighPhase = 0.75 * (1.0 + cos * cos);\n' +	                    '    float miePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + cos*cos) / ' +	                    '        pow(1.0 + g2 - 2.0*g*cos, 1.5);\n' +	                    '    const float exposure = 2.0;\n' +	                    '    vec3 color = primaryColor * rayleighPhase + secondaryColor * miePhase;\n' +	                    '    color = vec3(1.0) - exp(-exposure * color);\n' +	                    '    gl_FragColor = vec4(color, color.b);\n' +	                    '}';	            AtmosphereProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, ["vertexPoint"]);	        };	        SkyProgram.key = "WorldWindSkyProgram";	        SkyProgram.prototype = Object.create(AtmosphereProgram.prototype);	        return SkyProgram;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); },
 function(module, exports, __webpack_require__) {
	var RenderableLayer = __webpack_require__(88);	var Sector = __webpack_require__(31);	var SurfaceImage = __webpack_require__(89);	var SingleImageLayer = function (src) {	    RenderableLayer.call(this, "Single image layer");	    this.addRenderable(new SurfaceImage(Sector.FULL_SPHERE, src));	    this.minActiveAltitude = 0; 	};	SingleImageLayer.prototype = Object.create(RenderableLayer.prototype);	module.exports = SingleImageLayer;
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(69),	        __webpack_require__(9)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Layer,	              Logger) {	        "use strict";	        var RenderableLayer = function (displayName) {	            Layer.call(this, displayName);	            this.renderables = [];	        };	        RenderableLayer.prototype = Object.create(Layer.prototype);	        RenderableLayer.prototype.addRenderable = function (renderable) {	            this.renderables.push(renderable);	        };	        RenderableLayer.prototype.addRenderables = function (renderables) {	            for (var i = 0, len = renderables.length; i < len; i++) {	                this.addRenderable(renderables[i]);	            }	        };	        RenderableLayer.prototype.removeRenderable = function (renderable) {	            var index = this.renderables.indexOf(renderable);	            if (index >= 0) {	                this.renderables.splice(index, 1);	            }	        };	        RenderableLayer.prototype.removeAllRenderables = function () {	            this.renderables = [];	        };	        RenderableLayer.prototype.doRender = function (dc) {	            var numOrderedRenderablesAtStart = dc.orderedRenderables.length;	            for (var i = 0, len = this.renderables.length; i < len; i++) {	                try {	                    this.renderables[i].render(dc);	                } catch (e) {	                    Logger.logMessage(Logger.LEVEL_SEVERE, "RenderableLayer", "doRender",	                        "Error while rendering shape " + this.renderables[i].displayName + ".\n" + e.toString());	                }	            }	            if (dc.orderedRenderables.length > numOrderedRenderablesAtStart) {	                this.inCurrentFrame = true;	            }	        };	        return RenderableLayer;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(9),	        __webpack_require__(53),	        __webpack_require__(90)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Logger,	              PickedObject,	              SurfaceTile) {	        "use strict";	        var SurfaceImage = function (sector, imageSource) {	            SurfaceTile.call(this, sector);	            this.enabled = true;	            this._imageSource = imageSource;	            this.opacity = 1;	            this.displayName = "Surface Image";	            this.imageSourceWasUpdated = true;	        };	        SurfaceImage.prototype = Object.create(SurfaceTile.prototype);	        Object.defineProperties(SurfaceImage.prototype, {	            imageSource: {	                get: function () {	                    return this._imageSource;	                },	                set: function (imageSource) {	                    this._imageSource = imageSource;	                    this.imageSourceWasUpdated = true;	                }	            }	        });	        SurfaceImage.prototype.bind = function (dc) {	            var texture = dc.gpuResourceCache.resourceForKey(this._imageSource);	            if (texture && !this.imageSourceWasUpdated) {	                return texture.bind(dc);	            } else {	                texture = dc.gpuResourceCache.retrieveTexture(dc.currentGlContext, this._imageSource);	                this.imageSourceWasUpdated = false;	                if (texture) {	                    return texture.bind(dc);	                }	            }	        };	        SurfaceImage.prototype.applyInternalTransform = function (dc, matrix) {	        };	        SurfaceImage.prototype.render = function (dc) {	            if (!this.enabled || !this.sector.overlaps(dc.terrain.sector)) {	                return;	            }	            if (dc.pickingMode) {	                this.pickColor = dc.uniquePickColor();	            }	            dc.surfaceTileRenderer.renderTiles(dc, [this], this.opacity * dc.currentLayer.opacity);	            if (dc.pickingMode) {	                var po = new PickedObject(this.pickColor.clone(), this.pickDelegate ? this.pickDelegate : this,	                    null, this.layer, false);	                dc.resolvePick(po);	            }	            dc.currentLayer.inCurrentFrame = true;	        };	        return SurfaceImage;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports, __webpack_require__) {
	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [	        __webpack_require__(7),	        __webpack_require__(9),	        __webpack_require__(13),	        __webpack_require__(31),	        __webpack_require__(25)	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function (ArgumentError,	              Logger,	              Matrix,	              Sector,	              UnsupportedOperationError) {	        "use strict";	        var SurfaceTile = function (sector) {	            this.sector = sector;	        };	        SurfaceTile.prototype.bind = function (dc) {	            throw new UnsupportedOperationError(	                Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceTile", "bind", "abstractInvocation"));	        };	        SurfaceTile.prototype.applyInternalTransform = function (dc, matrix) {	            throw new UnsupportedOperationError(	                Logger.logMessage(Logger.LEVEL_SEVERE, "SurfaceTile", "applyInternalTransform", "abstractInvocation"));	        };	        return SurfaceTile;	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
 },
 function(module, exports) {
	var listeners = {};	module.exports = {	    CONTROLS_CHANGED: 'controls',	    NAVIGATOR_STATE_CHANGED: 'navigator-state-changed',	    SWITCH_GLOBE: 'switch-globe',	    ROTATE_TO: 'rotate-to',	    SHOW_FORM: 'show-form',	    HIDE_FORM: 'hide-form',	    TOGGLE_FORM: 'toggle-form'	};	module.exports.post = function (name, event) {	    if (listeners[name]) {	        listeners[name].forEach(function (listener) {	            try {	                listener(event);	            } catch (e) {	                console.error(e);	            }	        });	    }	};	module.exports.listen = function (name, listener) {	    if (!listeners[name]) {	        listeners[name] = [];	    }	    listeners[name].push(listener);	}; },
 function(module, exports, __webpack_require__) {
	var events = __webpack_require__(91);	var dom = __webpack_require__(93);	var size = 160;	var half = size/2;	var startY, startAngle, dragType;	var knobs = {	    heading: initKnob('heading'),	    tilt: initKnob('tilt'),	    zoom: initKnob('range')	};	var svg = dom.select('#controls-svg');	module.exports = svg;	dom.all('path.arrow').forEach(initArrow);	dom.select('#controls-globe').click(function() {	    events.post(events.ROTATE_TO, {heading: 0, tilt: 0})	});	events.listen(events.NAVIGATOR_STATE_CHANGED, function(state) {	    if (dragType) { 	        return;	    }	    if (null != state.heading) {	        setHeading(-state.heading);	    }	    if (null != state.tilt) {	        setTilt(state.tilt/90 * size - half);	    }	    if (null != state.range) {	        var z = (1e5 + state.range)/20e6 * size - half	        if (Math.abs(z) > half) {	            z = Math.sign(z) * half;	        }	        setZoom(z);	    }	});	function send(value, id) {	    events.post(events.CONTROLS_CHANGED, {	        parameter: id ? id : dragType,	        value: value	    });	}	function onMouseMove(e) {	    if (dragType == 'heading') {	        var angle = startAngle + mouseAngle(e);	        setHeading(angle);	        send(-angle);	        return;	    }	    var y = startY + mouseY(e);	    if (Math.abs(y) > half) {	        y = Math.sign(y) * half;	    }	    if (dragType == 'tilt') {	        setTilt(y);	        send((y + half)/size*90); 	        return;	    }	    if (dragType == 'range') {	        setZoom(y);	        send(1e5 + (y + half)/size*20e6); 	    }	}	function onMouseDown(e) {	    dragType = getId(this.id);	    if (dragType == 'heading') {	        startAngle = headingKnobCurrentAngle() - mouseAngle(e);	    } else {	        startY = knobCurrentY(this) - mouseY(e);	    }	    document.addEventListener('mousemove', onMouseMove);	    document.addEventListener('mouseup', onMouseUp);	}	function knobCurrentY(knob) {	    return parseFloat(knob.getAttribute('transform').split(/\(|\)/)[1].split(' ')[1]);	}	function headingKnobCurrentAngle() {	    return parseFloat(knobs.heading.parentNode.getAttribute('transform').split(/\(|\)/)[1]);	}	function setHeading(deg) {	    knobs.heading.parentNode.setAttribute('transform', 'rotate(' + deg + ')');	}	function setZoom(value) {	    knobs.zoom.setAttribute('transform', 'translate(100 ' + value + ')');	}	function setTilt(value) {	    knobs.tilt.setAttribute('transform', 'translate(-100 ' + value + ')');	}	function initKnob(type) {	    var knob = dom.select('#controls-' + type + '-knob');	    knob.addEventListener('mousedown', onMouseDown);	    return knob;	}	function mouseAngle(e) {	    return rad2deg(Math.PI - Math.atan2(mouseX(e), mouseY(e)));	}	function mouseY(e) {	    return e.clientY - getOffset(svg.parentNode, 'offsetTop') - svg.clientHeight / 2;	}	function mouseX(e) {	    return e.clientX - getOffset(svg.parentNode, 'offsetLeft') - svg.clientWidth / 2;	}	function rad2deg(rad) {	    return rad / Math.PI * 180;	}	function deg2rad(deg) {	    return deg / 180 * Math.PI;	}	function onMouseUp() {	    dragType = null;	    document.removeEventListener('mousemove', onMouseMove);	    document.removeEventListener('mouseup', onMouseUp);	}	function getOffset(elem, offsetParam) {	    var offset = elem[offsetParam];	    if (elem.offsetParent) {	        offset += getOffset(elem.offsetParent, offsetParam);	    }	    return offset;	}	function initArrow(arrow) {	    const id = getId(arrow.id);	    arrow.addEventListener('mousedown', activate);	    function deactivate() {	        document.removeEventListener('mouseup', deactivate);	        send(false, id)	    }	    function activate() {	        document.addEventListener('mouseup', deactivate);	        send(true, id);	    }	}	function getId(id) {	    return id.split('-')[1];	} },
 function(module, exports) {
	module.exports = {	    div: function(className) {	        return html("div", className);	    },	    span: function(className) {	        return html("span", className);	    },	    input: function(className) {	        return html("input", className);	    },	    img: function(src, className) {	        return html('img', className, {src: src ? src : ''});	    },	    svg: function(attributes) {	        return svg('svg', attributes);	    },	    path: function(attributes) {	        return svg('path', attributes);	    },	    circle: function(attributes) {	        return svg('circle', attributes);	    },	    select: function(selector, doc) {	        return extend((doc || document).querySelector(selector));	    },	    all: function(selector, doc) {	        return Array.prototype.slice.call((doc || document).querySelectorAll(selector)).map(function(element) {	            return extend(element);	        });	    }	};	function svg(name, attributes) {	    var svgElement = create(name, "http://www.w3.org/2000/svg");	    return assignAttributes(svgElement, attributes);	}	function html(name, classes, attributes) {	    var htmlElement = create(name);	    assignAttributes(attributes);	    return assignClasses(htmlElement, classes);	}	function create(name, namespace) {	    return extend(	        namespace ?	            document.createElementNS(namespace, name) :	            document.createElement(name)	    );	}	function extend(element) {	    element.append = function(child) {	        element.appendChild(child.domElement ? child.domElement: child);	        return element;	    };	    element.appendTo = function(parent) {	        parent.appendChild(element);	        return element;	    };	    element.setClass = function(className, isAdd) {	        element.classList[isAdd ? 'add' : 'remove'](className);	        return element;	    };	    element.val = propertyFunction(element, 'value');	    element.change = propertyFunction(element, 'oninput');	    element.html = propertyFunction(element, 'innerHTML');	    element.top = styleFunction(element, 'top');	    element.left = styleFunction(element, 'left');	    element.over = listenerFunction(element, 'mouseover');	    element.out = listenerFunction(element, 'mouseout');	    element.click = listenerFunction(element, 'click');	    return element;	}	function assignClasses(element, classes) {	    if (classes) {	        element.className = classes.toString();	    }	    return element;	}	function assignAttributes(element, attributes) {	    if (attributes) {	        for (var attr in attributes) {	            if (attributes.hasOwnProperty(attr)) {	                element.setAttribute(attr, attributes[attr])	            }	        }	    }	    return element;	}	function styleFunction(element, parameter) {	    return function(value) {	        element.style[parameter] = value;	        return element;	    };	}	function propertyFunction(element, propertyName) {	    return function (value) {	        if (value) {	            element[propertyName] = value;	        }	        return element;	    }	}	function listenerFunction(element, parameter) {	    return function(listener) {	        element.addEventListener(parameter, listener);	        return element;	    };	} },
 function(module, exports, __webpack_require__) {
	var events = __webpack_require__(91);	document.querySelector("#switch-globe").onclick = function() {	    events.post(events.SWITCH_GLOBE);	};	document.querySelector("#settings").onclick = function() {	    events.post(events.TOGGLE_FORM, "form-settings");	};
 },
 function(module, exports, __webpack_require__) {
	var form = __webpack_require__(96);	form("form-settings", "Настройки")	     .addMinimizeButton()	    .appendTo(document.body);	form("form-settings1", "Настройки1")	    .addMinimizeButton()	    .appendTo(document.body)	    .show(); },
 function(module, exports, __webpack_require__) {
	var dom = __webpack_require__(93);	var field = __webpack_require__(97);	var events = __webpack_require__(91);	module.exports = function(id, title) {	    var form = dom.div('form');	    form.oncontextmenu = function(event) {	        return false;	    };	    if (typeof title == 'string') {	        title = dom.div('form-title').html(title).appendTo(form);	    } else if (title) {	        form.append(title)	    }	    var fields = {};	    form.fields = fields;	    var content = dom.div('form-content').appendTo(form);	    form.add = function(element) {	        content.append(element);	        return form;	    };	    form.addFields = function(configs, namespace) {	        namespace = namespace || 'default';	        fields[namespace] = [];	        configs.forEach(function(config) {	            var f = field(config);	            form.add(f);	            if (config.path) {	                fields[namespace].push(f);	            }	        });	        return form;	    };	    form.render = function(data, namespace) {	        namespace = namespace || 'default';	        if (fields[namespace]) {	            fields[namespace].forEach(function(f) {	                f.render(data);	            });	        }	        return form;	    };	    form.getField = function(path, namespace) {	        namespace = namespace || 'default';	        return fields[namespace].filter(function(field) {	            return path == field.cfg.path;	        })[0];	    };	    form.addMinimizeButton = function(component){	        var minimize = dom.div('form-top-button').click(function() {	            form.oldLeft = form.offsetLeft;	            form.style.left = (dom.all('.form-minimized').length * 160) + 10 + 'px';	            form.classList.add('form-minimized');	            minimize.classList.add('hidden');	            if (component) {	                component.classList.add('hidden');	            }	        }).appendTo(form).append(createMinimizeSvg());	        title.click(function() {	            if (!form.classList.contains('form-minimized')) {	                return;	            }	            form.classList.remove('form-minimized');	            minimize.classList.remove('hidden');	            if (component) {	                component.classList.remove('hidden');	            }	            dom.all('.form-minimized').forEach(function(f) {	                if (f.offsetLeft > form.offsetLeft) {	                    var l = f.offsetLeft - 160;	                    f.style.left = l + 'px';	                }	            });	            form.style.left = form.oldLeft + 'px';	        });	        return form;	    };	    form.addCloseButton = function() {	        dom.div('form-top-button')	            .click(form.hide)	            .appendTo(form)	            .append(createCloseSvg());	        return form;	    };	    form.show = function() {	        form.classList.add('visible');	        return form;	    };	    form.hide = function() {	        form.classList.remove('visible');	        return form;	    };	    form.toggle = function() {	        return form.classList.contains('visible') ? form.hide() : form.show();	    };	    form.clear = function() {	        content.innerHTML = "";	        return form;	    };	    form.id = id;	    events.listen(events.SHOW_FORM, function (name) {	        if (name == id) form.show();	    });	    events.listen(events.HIDE_FORM, function (name) {	        if (name == id) form.hide();	    });	    events.listen(events.TOGGLE_FORM, function (name) {	        if (name == id) form.toggle();	    });	    var initX, initY, mousePressX, mousePressY;	    var padding = 10;	    title.addEventListener('mousedown', function(event) {	        if (form.classList.contains('form-minimized')){	            return;	        }	        initX = form.offsetLeft;	        initY = form.offsetTop;	        form.classList.remove('form-transition');	        mousePressX = event.clientX;	        mousePressY = event.clientY;	        window.addEventListener('mousemove', repositionElement, false);	        window.addEventListener('mouseup', function() {	            window.removeEventListener('mousemove', repositionElement, false);	            form.classList.add('form-transition');	        }, false);	    }, false);	    window.addEventListener('resize', function() {	        adjustLeft(form.offsetLeft);	        adjustBottom(window.innerHeight - form.offsetTop - form.offsetHeight);	    });	    function adjustLeft(left) {	        var maxLeft = window.innerWidth - padding - form.offsetWidth;	        left = left > maxLeft ? maxLeft : left;	        left = left < padding ? padding : left;	        form.style.left = left + 'px';	    }	    function adjustBottom(bottom) {	        var maxBottom = window.innerHeight - padding - form.offsetHeight;	        bottom = bottom > maxBottom ? maxBottom : bottom;	        bottom = bottom < padding ? padding : bottom;	        form.style.bottom = bottom + 'px';	    }	    function repositionElement(event) {	        adjustLeft(initX + event.clientX - mousePressX);	        adjustBottom(window.innerHeight - (initY + event.clientY - mousePressY) - form.offsetHeight);	    }	    return form;	};	function createMinimizeSvg() {	    return svg().append(path("M5,15 H16"));	}	function createCloseSvg() {	    return svg().append(path("M5,5 L16,16 M5,16 L16,5"));	}	function path(d){	    return dom.path({	        d: d,	        stroke: "lightgray",	        "stroke-width": 3	    });	}	function svg() {	    return dom.svg({	        width: 21,	        height: 21,	        viewbox: "0 0 25 25"	    });	}
 },
 function(module, exports, __webpack_require__) {
	var dom = __webpack_require__(93);	module.exports = createField;	module.exports.cfg = createConfig;	function createField(cfg) {	    var field = dom.div('form-field');	    field.cfg = cfg;	    dom.div('form-field-title').html(cfg.title + ':').appendTo(field);	    var value = dom.div('form-field-value').appendTo(field);	    field.set = function(text) {	        value.html(text);	    };	    field.render = function(data) {	        var val = cfg.custom.provider ? cfg.custom.provider(data) : deepValue(data, cfg.path);	        if (cfg.custom.renderer) {	            cfg.custom.renderer(val, value, data);	        } else {	            value.innerHTML = null == val ? '-' : val;	        }	    };	    if (cfg.custom.style) {	        for (var property in cfg.custom.style) {	            if (cfg.custom.style.hasOwnProperty(property)) {	                field.style[property] = cfg.custom.style[property];	            }	        }	    }	    return field;	}	function deepValue(obj, path) {	    try {	        path = path.split('.');	        for (var i = 0; i < path.length; i++) {	            obj = obj[path[i]];	        }	        return obj;	    } catch (e) {	        return null;	    }	}	function createConfig(title, path, style) {	    const cfg = {	        title: title,	        path: path,	        custom: {	            style: style	        }	    };	    cfg.style = createCustom('style');	    cfg.provider = createCustom('provider');	    cfg.renderer = createCustom('renderer');	    cfg.onclick = createCustom('onclick');	    return cfg;	    function createCustom(property) {	        return function(value) {	            cfg.custom[property] = value;	            return cfg;	        };	    }	} }
 ]);</script></body></html>